const char *bigbuf = "/*-------------------------------Identification-------------------------------*/\n" \
  "/**                           Sardane EasyDoc 02.1                           **/\n" \
  "#ifndef LINT\n" \
  "#define __WATINCLUDE__ \"GIVMiseEnFormeEpj.pc\"\n" \
  "#ifdef  __TIMESTAMP__ \n" \
  "    #define WhatStampGIVMiseEnFormeEpj_pc \"@(#)SARDANE $Revision:   3.132  $	GIVMiseEnFormeEpj.pc	\" \"(\" __TIMESTAMP__ \"-\" __DATE__ \" \" __TIME__ \")\"\n" \
  "#endif  /*  __TIMESTAMP__  */\n" \
  "const char* WhatIdentGIVMiseEnFormeEpj_pc(void)\n" \
  "{\n" \
  "    const char* WhatGIVMiseEnFormeEpj_pc = WhatStampGIVMiseEnFormeEpj_pc;\n" \
  "    return (WhatGIVMiseEnFormeEpj_pc);\n" \
  "}\n" \
  "#endif  /* LINT */\n" \
  "/*---------------------------Fin de l'identification--------------------------*/\n" \
  "\n" \
  "/*----------------------------------Includes----------------------------------*/\n" \
  "#include <stdio.h>\n" \
  "#include <stdlib.h>\n" \
  "#include <ctype.h>\n" \
  "#include <errno.h>\n" \
  "#include <time.h>\n" \
  "#include <sys/time.h>\n" \
  "#include <memory.h>\n" \
  "#include <sys/types.h>\n" \
  "#include <sys/stat.h>\n" \
  "#include <string.h>\n" \
  "#include <iconv.h>\n" \
  "\n" \
  "/* HAL, 13/11/2008 : modif pour Linux   */\n" \
  "/* Ce qui suit concernant \"oci.h\" a été lu sur \"Oracle MetaLink\" (Doc ID: NOTE:90169.1)       */\n" \
  "/* Le fichier \"oci.h\" se trouve sous \"$ORACLE_HOME/rdbms/public\"                */\n" \
  "/* The following 3 lines avoid inclusion of oci.h during precompilation             */\n" \
  "/* oci.h is needed only during compilation to resolve calls generated by the precompiler    */\n" \
  "#ifndef ORA_PROC\n" \
  "    #include <oci.h>\n" \
  "#endif\n" \
  "\n" \
  "EXEC SQL begin declare section;\n" \
  "    EXEC SQL include \"GIVTypes.h\";\n" \
  "EXEC SQL end declare section;\n" \
  "\n" \
  "#include \"GWCIdenObjetPub.h\"\n" \
  "#include \"GHTgestion_compteurs.h\"\n" \
  "#include \"GWTTrace.h\"\n" \
  "#include \"GWDrElemTypeT.h\"\n" \
  "\n" \
  "#include \"GYBconstantes.h\"\n" \
  "EXEC SQL begin declare section;\n" \
  "    EXEC SQL include \"GYBstruct_C.h\";\n" \
  "    #include \"GYBrLvsSeoEtabT.h\"\n" \
  "    #include \"GYBrPhotosEtabT.h\"\n" \
  "    #include \"GYBrLienEtabT.h\"\n" \
  "    #include \"GYBrPrioCRCT.h\"\n" \
  "    #include \"GYBrBlocT.h\"\n" \
  "    #include \"GYBrIaprofT.h\"\n" \
  "    #include \"GYBrIeinscT.h\"\n" \
  "    #include \"GYBrIndIeinscT.h\"\n" \
  "    #include \"GYBrIndIaprofT.h\"\n" \
  "    #include \"GYBrIamicT.h\"\n" \
  "    #include \"GYBrIapartT.h\"\n" \
  "    #include \"GYBrDenomSynoT.h\"\n" \
  "    #include \"GYBrPeEtabT.h\"\n" \
  "    #include \"GYBrIndPeEtabT.h\"\n" \
  "    #include \"GYBrPelrepT.h\"\n" \
  "    #include \"GYBrIndIamicT.h\"\n" \
  "    #include \"GYBrLjdeptT.h\"\n" \
  "    #include \"GYBrPelzuT.h\"\n" \
  "    #include \"GYBrIndPelzuT.h\"\n" \
  "    #include \"GYBrIndLjdeptT.h\"\n" \
  "EXEC SQL end declare section;\n" \
  "#include \"GIVConstantesBloc.h\"\n" \
  "#include \"GYBrParam_erreurT.h\"\n" \
  "#include \"GYBinterface_SGBDR.h\"\n" \
  "\n" \
  "EXEC SQL begin declare section;\n" \
  "    EXEC SQL include \"GYBstruct_Pro_C.h\";\n" \
  "    EXEC SQL include \"GYBindicatrices.h\";\n" \
  "    #include \"GYBrIndLvsSeoEtabT.h\"\n" \
  "    #include \"GYBrIndPhotosEtabT.h\"\n" \
  "    #include \"GYBrIndLienEtabT.h\"\n" \
  "    #include \"GYBrIndPelrepT.h\"\n" \
  "    #include \"GYBrPeadrT.h\"\n" \
  "    #include \"GYBrIndPeadrT.h\"\n" \
  "    EXEC SQL include \"GYBgestion_pro_c.h\";\n" \
  "EXEC SQL end declare section;\n" \
  "\n" \
  "#include \"GBZConstantes.h\"\n" \
  "#include \"GXWDonnees.h\"\n" \
  "#include \"GBErRefMvtT.h\"\n" \
  "#include \"GBERetourFournisseur.h\"\n" \
  "\n" \
  "#include \"GWCrStructTLVT.h\"\n" \
  "#include \"GWCStructTLV.h\"\n" \
  "\n" \
  "#include \"GIXConstantes.h\"\n" \
  "#include \"GIXVariables.h\"\n" \
  "#include \"GWZTypeChamp.h\"\n" \
  "\n" \
  "#include \"GIVConstantes.h\"\n" \
  "#include \"GIVProfFnmpT.h\"\n" \
  "#include \"GIVProfT.h\"\n" \
  "#include \"GIVNoyauT.h\"\n" \
  "#include \"GIVModuleT.h\"\n" \
  "#include \"GIVObjMicroT.h\"\n" \
  "#include \"GYBrPaysT.h\"\n" \
  "#include \"GYBrIndPaysT.h\"\n" \
  "#include \"GYBrIndIapartT.h\"\n" \
  "#include \"GIVrGeocodT_Bloc.h\"\n" \
  "#include \"GYBrIndPecdexT.h\"\n" \
  "#include \"GYBrPecdexT.h\"\n" \
  "#include \"GYBrPevrepT.h\"\n" \
  "#include \"GYBrIndPevrepT.h\"\n" \
  "#include \"GYBrIndPaprofT.h\"\n" \
  "#include \"GYBrPaprofT.h\"\n" \
  "#include \"GIVDoublesInsT.h\"\n" \
  "#include \"GIVDoublesT.h\"\n" \
  "#include \"GIVVariables.h\"\n" \
  "#include \"GIMTraiteAdr.h\"\n" \
  "#include \"GIVBouclerEpj.h\"\n" \
  "#include \"GYBrIndIadresT.h\"\n" \
  "#include \"GYBrIadresT.h\"\n" \
  "#include \"GYBrIaparuT.h\"\n" \
  "#include \"GIVMiseEnFormeMvtCDBloc.h\"\n" \
  "#include \"GHHrDataAuthentT.h\"\n" \
  "#include \"GHHrStructFichierT.h\"\n" \
  "#include \"GHHrStructAuthentT.h\"\n" \
  "#include \"GHHCoherence.h\"\n" \
  "#include \"GYBrMouvementsBlocT.h\"\n" \
  "#include \"GEDrDescStdT.h\"\n" \
  "#include \"GWDrPhraT.h\"\n" \
  "#include \"GIVBlocsDoubles.h\"\n" \
  "#include \"GYBrMouvementsT.h\"\n" \
  "#include \"GIVLectureTabIAPROFBloc.h\"\n" \
  "#include \"GDQQualification.h\"\n" \
  "#include \"enumGYB.h\"\n" \
  "#include \"enumGWZ.h\"\n" \
  "#include \"enumGeo.h\"\n" \
  "\n" \
  "#ifndef ORA_PROC\n" \
  "# include <string>\n" \
  "# include <sstream>\n" \
  "#endif\n" \
  "\n" \
  "#define SQLCA_STORAGE_CLASS extern\n" \
  "EXEC SQL include sqlca;\n" \
  "#define ORACA_STORAGE_CLASS extern\n" \
  "EXEC SQL include oraca;\n" \
  "\n" \
  "/*-----------------------------Constantes internes----------------------------*/\n" \
  "#define givRecreerCD \"CRE\"\n" \
  "#define givcR00000000 \"00000000\"\n" \
  "#define givcR000000 \"000000\"\n" \
  "#define givcTypNoyau  'P'\n" \
  "#define givcTypModule 'M'\n" \
  "#define givcNogrou \"0000000\"\n" \
  "#define givtcMoteur \"MONGO\"\n" \
  "#define GIV_GRO_DEFAUT \"0\"\n" \
  "\n" \
  "#define GIV_CHAR_BLANC   ' '\n" \
  "#define givcIndInitPre   1      /* index de l'octet parution prenom */\n" \
  "#define givcIndParuAdr   2      /* index de l'octet parution adresse */\n" \
  "#define givcIndParuNoParu 3      /* index de l'octet parution numéro */\n" \
  "#define givcParuAdr      '0'    /* valeur parution adresse normale   */\n" \
  "#define givcParuSSAdr    '1'    /* valeur parution sans adresse      */\n" \
  "#define givcParuSSNo     '2'    /* valeur parution sans numéro dans la voie */\n" \
  "#define givcParuIPre    '1'    /* valeur parution initiale     */\n" \
  "#define givcParuSSNoParu '3'    /* valeur parution sans numéro de parution */\n" \
  "#define givcParuSante      '0'    /* valeur parution santé par defaut */\n" \
  "#define givcParuMed    'm'    /* valeur parution santé pour médecin */\n" \
  "#define givcParuCab     'c'    /* valeur parution santé pour cabinet */\n" \
  "#define givcSuppCham     '3'    /* valeur support chamois */\n" \
  "\n" \
  "#define givcLocFictive  \"99999\" /* code loc d'une localité ficitve */\n" \
  "#define givcLocIndf  \"00000\" /* code loc d'une localité indéfinie */\n" \
  "#define givcDepPays  \"500\" /* code loc d'une localité ficitve */\n" \
  "#define givcDepFictif \"952\"\n" \
  "#define givTrad \"&amp;\" /* traduction caractère & */\n" \
  "#define givtcMaxAud \"MA\" /* maxi audience */\n" \
  "#define givtcNatureAn8Part \"GPB\" /* nature parution rubrique */\n" \
  "\n" \
  "/* Pour les sauts de lignes */\n" \
  "#define SEPARE_LIGNE                        0x0D\n" \
  "#define LINE_FEED                           0x0A\n" \
  "\n" \
  "#define GIV_TAILLE_MAX_EPJ 5000\n" \
  "#define MAX_PARENT 1000         /* par bloc nombre max de partenaires d'un parent */\n" \
  "#define MAX_LIST_CRC 4000         /* par fichier contenu nombre max de CRC */\n" \
  "#define MAX_LIST_CONT 2500         /* par bloc contenu nombre max de contenu d'établissement */\n" \
  "#define giv_LG_REQUETE 512\n" \
  "#define giv_DIV_PAR_DIX 16\n" \
  "\n" \
  "#define giv_LG_CLOB 65500-1 /* taile de lecture d'un clob en varchar */\n" \
  "#define giv_LG_BUFFTEST 4000000 /* taille max de bloc complet pour le moteur */\n" \
  "\n" \
  "#define giv_DEP_MONACO \"006\"\n" \
  "#define giv_LOC_MONACO \"16200\"\n" \
  "\n" \
  "/* données-contenus */\n" \
  "#define giv_ENR \"ENR\" /* enrichies */\n" \
  "#define giv_ADD \"ADD\" /* additionnelles */\n" \
  "#define giv_ADG \"ADG\" /* additionnelles GC-EN */\n" \
  "#define giv_REL \"REL\" /* réseaux-relais-colis */\n" \
  "#define giv_ANN \"ANN\" /* annonceur */\n" \
  "#define giv_EPJ \"EPJ\" /* établissement */\n" \
  "#define giv_ANO \"ANO\" /* établissement annoté */\n" \
  "#define giv_HPN \"HPN\" /* infos horaires payanets normalisées */\n" \
  "#define giv_HGN \"HGN\" /* infos horaires gratuites normalisées */\n" \
  "#define giv_PHO \"PHO\" /* photos */\n" \
  "#define giv_CAL \"CAL\" /* calendrier */\n" \
  "#define giv_PRT \"PRT\" /* partenaire */\n" \
  "\n" \
  "/* source de données additionnelles */\n" \
  "#define giv_GCEN \"GC-EN\" /* additionnelles GC-EN */\n" \
  "\n" \
  "/* origine des partenaires */\n" \
  "#define giv_ACCO \"ACCO\"\n" \
  "#define giv_RESA \"RESA\"\n" \
  "#define giv_EXPD \"EXPD\"\n" \
  "#define giv_B2B \"B2B\"\n" \
  "#define giv_CHRO \"CHRO\"\n" \
  "#define giv_PJDC \"PJDC\"\n" \
  "#define giv_cPJDC 'c'\n" \
  "#define giv_orPJDC 'o'\n" \
  "#define giv_svPJDC 's'\n" \
  "#define giv_prPJDC 'p'\n" \
  "#define giv_sPJDC \"LP\"\n" \
  "#define giv_ssPJDC \"CR\"\n" \
  "#define giv_sRKPJDC \"3R\"\n" \
  "#define giv_cCHRO 'c'\n" \
  "#define giv_sCHRO \"LC\"\n" \
  "#define giv_ssCHRO \"CH\"\n" \
  "#define giv_cLEUR 'l'\n" \
  "\n" \
  "namespace GIV\n" \
  "{\n" \
  "enum givcParu\n" \
  "{\n" \
  "    giv_RUB = 0, giv_DNOM = 1, giv_OBJ = 2\n" \
  "};\n" \
  "}\n" \
  "\n" \
  "#define givTitreDoc \"Dr \"\n" \
  "\n" \
  "/* Requete de lecture du texte correspondant l'AN9 */\n" \
  "#define GIVRequeteLectureRJRUPR \\\n" \
  "\"select lasan9 \\\n" \
  " from rjrupr \\\n" \
  " where codan9 = :codeAn9\"\n" \
  "\n" \
  "/* Requete de lecture du theme correspondant l'AN9 */\n" \
  "#define GIVRequeteLectureThemeED \\\n" \
  "\"select theme \\\n" \
  " from GYTtabThemeED \\\n" \
  " where codan9 = :codeAn9\"\n" \
  "\n" \
  "/* Requete de lecture du type d'URL */\n" \
  "#define GIV_RQ_SELECT_TYPE_URL \\\n" \
  "\"select unique tpdurl,liburl from GYTtabPemicURL  \\\n" \
  "where (numobj = :numobj \\\n" \
  "and typobj = :typobj \\\n" \
  "and tpdsob = :tpdsob1 \\\n" \
  ")\"\n" \
  "\n" \
  "/* Requete de lecture des données de l'établissement de niveau inscription */\n" \
  "#define GIV_RQ_SELECT_ETAB_MC \\\n" \
  "\"select siret, url, tefet, tefen, siege, cj, libcj, libape, datcrent from  GYTTabPeEtab  \\\n" \
  "where etab = :etab\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_SIREN \\\n" \
  "\"select to_char(count(etab),'FM00000') from GYTTabPeEtab where substr(siret,1,9) = substr(:siren,1,9)\"\n" \
  "\n" \
  "/* Requete de lecture des données de l'établissement */\n" \
  "#define GIV_RQ_SELECT_ETAB \\\n" \
  "\"select denom, nomdirig, parut_insee, siret_rs, siret_rscompl, siret_enseigne, siret_sigle, opp_photo from GYTTabPeEtab \\\n" \
  "where etab = :etab\"\n" \
  "\n" \
  "/* Requete de lecture des dénominations secondaires de l'établissement */\n" \
  "#define GIV_RQ_SELECT_DENOM_ETAB \\\n" \
  "\"select origine,denom from GYTTabDenomsEtab \\\n" \
  "where etab = :etab\"\n" \
  "\n" \
  "/* Requete de lecture des photos de l'établissement */\n" \
  "#define GIV_RQ_SELECT_PHOTOS_ETAB \\\n" \
  "\"select x.photo, x.legende, x.cteutil, x.origine, x.metadata.getClobVal() from GYTTabPhotosEtab x \\\n" \
  "where etab = :etab\"\n" \
  "\n" \
  "/* Requete de lecture des objets pub de l'établissement */\n" \
  "#define GIV_RQ_SELECT_PUB_ETAB \\\n" \
  "\"select epjobj,tpdsob,stobj,numobj,(TO_CHAR (datact,'FXYYYYMMDD')) from GYTTabEpjMic  \\\n" \
  "where etab = :etab and upper(tpdsob) = tpdsob and tpdsob||stobj != 'FAPK' \\\n" \
  "union select a.epjobj,a.tpdsob,a.stobj,a.numobj,(TO_CHAR (datact,'FXYYYYMMDD')) from GYTTabEpjMic a, GYTtabProduitGPPParut b  \\\n" \
  "where a.etab = :etab and upper(a.tpdsob) = a.tpdsob and a.tpdsob||a.stobj = 'FAPK' \\\n" \
  "and b.numobj = a.epjobj and nls_upper(b.tpdsob) = nls_upper(a.tpdsob) \\\n" \
  "and	((b.datedeb is null) or (to_char(b.datedeb,'YYYYMMDD') <= to_char(current_date,'YYYYMMDD'))) \\\n" \
  "and	((b.datefin is null) or (to_char(current_date,'YYYYMMDD') <= to_char(b.datefin,'YYYYMMDD'))) \\\n" \
  "union select '',tpdsob,stobj,'','' from View_EPJProduitsFictifs \\\n" \
  "where etab = :etab\"\n" \
  "\n" \
  "/* Requete de lecture du calendrier de partenaire */\n" \
  "#define GIV_RQ_SELECT_CALEND_PART \\\n" \
  "\"select XMLSERIALIZE(Document XMLTYPE(x.complement.extract('/complement/complement_pjdocclicrdv/calendrier').getClobVal()) AS CLOB INDENT SIZE = 0) \\\n" \
  " from GYTTabPartEtab x \\\n" \
  " where x.origine = :origine and x.refext = :refext \\\n" \
  " and existsNode(x.complement,'/complement/complement_pjdocclicrdv/calendrier') = 1\"\n" \
  "\n" \
  "/* Requete de lecture des photos de partenaire */\n" \
  "#define GIV_RQ_SELECT_PHOTO_PART \\\n" \
  "\"select XMLSERIALIZE(Document XMLTYPE(x.photos.extract('/photos/photo').getClobVal()) AS CLOB INDENT SIZE = 0) \\\n" \
  " from GYTTabPartEtab x \\\n" \
  " where x.origine = :origine and x.refext = :refext \\\n" \
  " and existsNode(x.photos,'/photos/photo') = 1\"\n" \
  "\n" \
  "/* Requete de lecture des données de l'établissement */\n" \
  "#define GIV_RQ_SELECT_PEETAB \\\n" \
  "\"select \\\n" \
  "etab,siret,ape, \\\n" \
  "denom,compln, \\\n" \
  "coddep,codloc,libloc, \\\n" \
  "codvoi,typvoi,libvoi,novoie,cplnov, \\\n" \
  "longitude,latitude,precision \\\n" \
  "from GYTtabPeEtab \\\n" \
  "where (etab = :etab)\"\n" \
  "\n" \
  "/* Requete de lecture des URL d'un établissement Grand Compte */\n" \
  "#define GIV_RQ_SELECT_PUB_GCPT \\\n" \
  "\"select liburl from GYTTabURLGCpt  \\\n" \
  "where etab = :etab\"\n" \
  "\n" \
  "/* Requete de lecture des anciens établissements */\n" \
  "#define GIV_RQ_SELECT_OLD_ETAB \\\n" \
  "\"select etarepri,typrepri,(TO_CHAR (datelien,'FXYYYYMMDD')) dat from GYTTabLiensEtab \\\n" \
  "where etab = :etab order by dat\"\n" \
  "\n" \
  "/* Requete de lecture des liens vers site de SEO */\n" \
  "#define GIV_SLC_LVS_SEO_ETAB \"\\\n" \
  "      select idstat,partseo,urlseo,ancre,follow,ordre \\\n" \
  "      from gyttablvsseoetab \\\n" \
  "      where etab = :pcOraEtab\"\n" \
  "\n" \
  "/* Requete de lecture des liens vers les produits à l'epj */\n" \
  "#define GIV_SLC_LIENS_PROD_ETAB \"\\\n" \
  "      select tpdsob,stobj,epjobj,cle,valeur \\\n" \
  "      from gyttabprodliensetab \\\n" \
  "      where etab = :pcOraEtab\"\n" \
  "\n" \
  "/* Requete de lecture de Ref Embauche */\n" \
  "#define GIV_RQ_SELECT_EMBAUCHE \\\n" \
  "\"select refext from  GYTTabEmbauche  \\\n" \
  "where numcli = :numcli\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_BONPLAN_PUB \\\n" \
  "\"select etab,(TO_CHAR (date_fin,'FXYYYYMMDD')),TO_CHAR(nb_bp,'FM99999'),tpdsob,decode(tpdsob,'E+',1,'EB',2,'C+',3,'CB','4','G+',5,'GB',6,7),numcli from  GYTTabBonPlan  \\\n" \
  "where etab = :etab \\\n" \
  "union select b.etab,(TO_CHAR (b.date_fin,'FXYYYYMMDD')),TO_CHAR(b.nb_bp,'FM99999'),b.tpdsob,decode(b.tpdsob,'E+',1,'EB',2,'C+',3,'CB','4','G+',5,'GB',6,7),numcli from GYTTabEpjMic a, GYTTabBonPlan b \\\n" \
  "where a.etab = :etab and b.numcli = substr(a.numobj,5,8) and b.numprod = substr(a.numobj,13,4) and b.tpdsob = a.tpdsob \\\n" \
  "order by 002 desc,003 desc,005,006\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_IMAG \\\n" \
  "\"select to_char(nbimag),to_char(imagcat),imagmenu from GYTTabPvImag  \\\n" \
  "where numobj = :numobj\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_STAT \\\n" \
  "\"select estatan from  GYTTabEStatAn \\\n" \
  "where numcli = :numcli\"\n" \
  "\n" \
  "/* Requete de lecture de EvIlo */\n" \
  "#define GIV_RQ_SELECT_EVILO \\\n" \
  "\"select evt, prg from  GYTTabEvIlo  \\\n" \
  "where etab = :etab\"\n" \
  "\n" \
  "/* Requete de lecture du type de Siret Pages Pro */\n" \
  "#define GIV_RQ_SELECT_SIRET \\\n" \
  "\"select siret from GYTtabPagesPro  \\\n" \
  "where (siret = :siret)\"\n" \
  "\n" \
  "/* libellé de localité de rattachement */\n" \
  "#define GIV_RQ_SELECT_LIB_LJLORN \\\n" \
  "\"select distinct a.liblae \\\n" \
  "from GYTtabPelrep a, LJLORN b\\\n" \
  " where (a.depart = b.cdsdep and a.numloc = b.numloc \\\n" \
  " and (a.arrond = '00' or a.arrond = '99')) \\\n" \
  " and (b.cddprn = :depart and b.nulorn = :numloc)\"\n" \
  "\n" \
  "/* localités par département */\n" \
  "#define GIV_RQ_SELECT_LOC_DEP \\\n" \
  "\"select numloc \\\n" \
  "from GYTtabPelrep where depart = :depart and numloc != '99999'\"\n" \
  "\n" \
  "/* GIV_RQ_SELECT_ZU : texte SQL de la requete de recherche Zone Urbaine */\n" \
  "\n" \
  "#define GIV_RQ_SELECT_ZU \\\n" \
  "\"select deppole,locpole \\\n" \
  "from GYTtabPelzu\\\n" \
  " where depart = :depart and localite = :numloc\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_ZU_POLE \\\n" \
  "\"select deppole,locpole \\\n" \
  "from GYTtabPelzu\\\n" \
  " where depart = :depart and localite = :numloc\\\n" \
  " and depart = deppole and localite = locpole\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_ZU_LF \\\n" \
  "\"select deppole,locpole \\\n" \
  "from GYTtabPelzu\\\n" \
  " where depart = :depart and localite = :numloc\"\n" \
  "\n" \
  "/* GIV_RQ_SELECT_LOCFUS : texte SQL de la requete de recherche de localité fusionnée */\n" \
  "\n" \
  "#define GIV_RQ_SELECT_LOCFUS \\\n" \
  "\"select depfus,locfus \\\n" \
  "from GYTtabPelFusion \\\n" \
  " where depart = :depart and localite = :numloc\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_REGION \\\n" \
  "\"select cdsreg \\\n" \
  "from ljdept\\\n" \
  " where cdsdep = :depart\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_NEW_REGION \\\n" \
  "\"select cdsreg, cdrgol \\\n" \
  "from ljdept\\\n" \
  " where cdsdep = :depart\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_CRC \\\n" \
  "\"select codecrc,libelcrc,navigateur \\\n" \
  "from donneescrc\\\n" \
  " where depart = :depart and numloc = :numloc and numnat = :numnat \\\n" \
  " and codan9 = :codan9\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_ANC_BLOC \"\\\n" \
  "select substr(blocid,1,length(blocid)-1)||'C000'||substr(blocid,length(blocid),1) \\\n" \
  "        from VueTabMvtsBloc_%s_%s_%s\\\n" \
  "        where (depart = %s) and (numnat = :numnat) and (numlo = :numlo) and (numls = :numls) and (substr(blocid,1,4) != 'C000') and blocid is not null\"\n" \
  "\n" \
  "/* acces GYTtabIeBlocCRC_dest */\n" \
  "\n" \
  "#define GIV_DEL_IEBLOC_CRC \"\\\n" \
  "        delete from GYTtabieBlocEpjCRC_%s\\\n" \
  "        where (blocid = :cBlocid)\"\n" \
  "\n" \
  "#define GIV_INS_IEBLOC_CRC \"\\\n" \
  "        insert into GYTtabIeBlocEpjCRC_%s\\\n" \
  "        (blocid,etab,crc,type,codan8,origine,version)\\\n" \
  "        values (:acBlocid,\\\n" \
  "                :acEtab,\\\n" \
  "                :acCrc,\\\n" \
  "                nvl(:acType,'X'),\\\n" \
  "                :acCodan8,\\\n" \
  "                :acTpdsob,\\\n" \
  "                :version)\"\n" \
  "\n" \
  "/* acces GYTtabIeBloc_dest */\n" \
  "\n" \
  "#define GIV_DEL_IEBLOC \"\\\n" \
  "        delete from GYTtabIeBlocEpj_%s\\\n" \
  "        where (depart = :cDepart) and (blocid = :cBlocid)\"\n" \
  "\n" \
  "#define GIV_CRE_IS \"\\\n" \
  "        insert into GYTtabIeBlocEpj_%s\\\n" \
  "        (depart,numnat,numlo,numls,blocid,etab,nogrou,noselo,nosels,datemodbloc,version)\\\n" \
  "        values (:acDepart,\\\n" \
  "                :acNumnat,\\\n" \
  "                :acNumlo,\\\n" \
  "                :acNumls,\\\n" \
  "                :acBlocid,\\\n" \
  "                :acEtab:indicatrice_acEtab, \\\n" \
  "                :acNogrou:indicatrice_acNogrou,\\\n" \
  "                :acNoselo:indicatrice_acNoselo,\\\n" \
  "                :acNosels:indicatrice_acNosels,\\\n" \
  "                (TO_DATE (:acDatemodbloc,'FXYYYYMMDD')),\\\n" \
  "                :version)\"\n" \
  "\n" \
  "#define GIV_CRE_IG \"\\\n" \
  "        insert into GYTtabIeBlocEpj_%s\\\n" \
  "        (depart,numnat,numlo,numls,blocid,etab,nogrou,noselo,nosels,datemodbloc,version)\\\n" \
  "        values (:acDepart,\\\n" \
  "                :acNumnat,\\\n" \
  "                :acNumlo,\\\n" \
  "                :acNumls,\\\n" \
  "                :acBlocid,\\\n" \
  "                :acEtab:indicatrice_acEtab, \\\n" \
  "                :acNogrou:indicatrice_acNogrou,\\\n" \
  "                :acNoselo:indicatrice_acNoselo,\\\n" \
  "                :acNosels:indicatrice_acNosels,\\\n" \
  "                (TO_DATE (:acDatemodbloc,'FXYYYYMMDD')),\\\n" \
  "                :version)\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_DONENR \"\\\n" \
  "      select XMLSERIALIZE(Document XMLTYPE(x.donenr.extract('/donneesEnrichissement/prestationsDonneesEnrichies').getClobVal()) AS CLOB INDENT SIZE = 0) \\\n" \
  "      from gyttabpeetab x \\\n" \
  "      where x.etab = :pcOraEtab and existsNode(x.donenr,'/donneesEnrichissement/prestationsDonneesEnrichies') = 1\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_DONREL \"\\\n" \
  "      select x.res_relais.getClobVal() \\\n" \
  "      from gyttabpeetab x \\\n" \
  "      where x.etab = :pcOraEtab and existsNode(x.res_relais,'/lstde') = 1\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_DONADD_GCEN \"\\\n" \
  "select x.info.getClobVal() \\\n" \
  "      from gyttabdonaddetab x \\\n" \
  "      where x.etab = :pcOraEtab and x.source = :pcOraSce \\\n" \
  "      and existsNode(x.info,'/listeEnseigneEpj/enseigneEpj/libelleEnseigne') = 1\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_DONADD \"\\\n" \
  "      select x.info.getClobVal() \\\n" \
  "      from gyttabdonaddetab x \\\n" \
  "      where x.etab = :pcOraEtab and x.source = :pcOraSce\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_ANNONC \"\\\n" \
  "      select x.contenu.getClobVal() \\\n" \
  "      from gyttabcontenusannonceur x \\\n" \
  "      where x.numobj = :pcObjet and x.type = :pcType\"\n" \
  "\n" \
  "#define GIV_SLC_TYP_CONT_ETAB \"\\\n" \
  "      select distinct type,theme \\\n" \
  "      from gyttabcontenusetab \\\n" \
  "      where etab = :pcOraEtab\"\n" \
  "\n" \
  "#define GIV_SLC_CONT_PROF_ETAB \"\\\n" \
  "      select distinct 'V','DV',codan8,'' from gyttabprofetab where etab = :pcOraEtab and origine = '5' \\\n" \
  "      union select distinct 'N',a.type,a.codan8,nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhnetab a, gyttabprofetab b \\\n" \
  "       where a.etab = :pcOraEtab and b.etab = a.etab and b.origine = '5' and a.codan8 = b.codan8 \\\n" \
  "      union select distinct 'N',a.type,'',nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhnetab a, gyttabpeetab b \\\n" \
  "       where a.etab = :pcOraEtab and b.etab = a.etab and a.type = 'DE' \\\n" \
  "      union select distinct 'S',a.type,a.codan8,nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhsetab a, gyttabprofetab b \\\n" \
  "       where a.etab = :pcOraEtab and b.etab = a.etab and b.origine = '5' and a.codan8 = b.codan8 \\\n" \
  "      union select distinct 'S',a.type,'',nvl(to_char(b.datefraho,'FXYYYYMMDD'),'19000101') from gyttabdhsetab a, gyttabpeetab b \\\n" \
  "       where a.etab = :pcOraEtab and b.etab = a.etab and a.type = 'DE' \\\n" \
  "      order by 001,004 desc,002 desc,003\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_ETAB \"\\\n" \
  "      select y.contenu.getClobVal() \\\n" \
  "      from gyttabcontenusetab y \\\n" \
  "      where y.etab = :pcOraEtab and y.type = :pcType and nvl(:pcTheme,y.theme) = y.theme\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_ANNOT \"\\\n" \
  "      select z.contenu.getClobVal() \\\n" \
  "      from gyttabcontenusetab z \\\n" \
  "      where z.etab = :pcOraEtab and z.type = :pcType and z.source = :pcOraSce\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_DHNA \"\\\n" \
  "      select xx.contenu.getClobVal() \\\n" \
  "      from gyttabdhnannonceur xx \\\n" \
  "      where xx.type = :pcType and xx.numobj = :pcObjet\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_DHNE \"\\\n" \
  "      select x.contenu.getClobVal() \\\n" \
  "      from gyttabdhnetab x \\\n" \
  "      where x.etab = :pcOraEtab and x.type = :pcOraType and \\\n" \
  "      ((x.type = 'DV' and x.codan8 = :pcAn8:sInd) or \\\n" \
  "       (x.type = 'DE'))\"\n" \
  "\n" \
  "#define GIV_SLC_CLOB_PART \"\\\n" \
  "      select x.complement.getClobVal(), x.photos.getClobVal() \\\n" \
  "      from gyttabpartetab x \\\n" \
  "      where x.origine = :origine and x.refext = :refext\"\n" \
  "\n" \
  "#define GIV_SLC_MOT_CLE \"\\\n" \
  "      select b.idmotcle,b.codan8,b.terme \\\n" \
  "      from gyttabgppmotscles a, gyttabmotsclescri b \\\n" \
  "      where a.numobj = :obj and b.idmotcle = a.idmotcle \\\n" \
  "      and b.codan8 is not null\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_BUC \"\\\n" \
  " select distinct numcli from gyttabieinsc_888 \\\n" \
  " where etab = :etab and (numls >= :min) and (numls <= :max) and numcli is not null order by numcli\"\n" \
  "\n" \
  "/* requêtes SEO */\n" \
  "\n" \
  "#define GIV_RQ_SELECT_SRV_SEO \\\n" \
  "\"select info,avis from GYTTabSEOService \\\n" \
  "where etab = :etab %s\"\n" \
  "\n" \
  "#define GIV_VERS_SEO \"\\\n" \
  "      select min(decode(double,'REF',1,'RFV',2,'DBL',3,4)||blocid) \\\n" \
  "      from GYTtabIeBloc_%s\\\n" \
  "      where ((numnat = :cNumnat) \\\n" \
  "        and (numlo = :cNumlo) and (numls = :cNumls))\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_DNOM_PRINC \"\\\n" \
  " select nvl(min(substr(a.inparu,3,1)||decode(a.indprf,'0',1,0)||decode(substr(a.inparu,1,1),'o',1,'s',2,'c',3,'p',4,5)||decode(a.indrecgpp,'1',0,1)||decode(c.tpdsob,'SC',decode(c.stobj,'PB',8,1),'FI',2,'VI',3,'IN',4,' T',5,'NV',6,'NT',7,8)||decode(marque,null,0,1)||decode(a.numls,'0000',1,0)||nvl(a.nogrou||a.noselo||a.nosels,'ZZZZZZZ0000000')||a.numnat||a.numlo||a.numls),'999999ZZZZZZZ0000000ZZZZZZZZZZZZZZZZZZ') from VueTabIeInsc_%s_%s_%s a,VueTabIamic_%s_%s_%s c \\\n" \
  " where \\\n" \
  " a.indmic = '1' \\\n" \
  " and c.numnat = a.numnat and c.numlo = a.numlo and c.numls = a.numls \\\n" \
  " and a.etab = :etab \\\n" \
  " union \\\n" \
  " select nvl(min(substr(a.inparu,3,1)||decode(a.indprf,'0',1,0)||decode(substr(a.inparu,1,1),'o',1,'s',2,'c',3,'p',4,5)||'1'||'9'||decode(marque,null,0,1)||decode(a.numls,'0000',1,0)||nvl(a.nogrou||a.noselo||a.nosels,'ZZZZZZZ0000000')||a.numnat||a.numlo||a.numls),'999999ZZZZZZZ0000000ZZZZZZZZZZZZZZZZZZ') from VueTabIeInsc_%s_%s_%s a \\\n" \
  " where \\\n" \
  " a.indmic = '0' \\\n" \
  " and a.etab = :etab \\\n" \
  " order by 001 \\\n" \
  "\"\n" \
  "\n" \
  "/* oppositions et black-listes */\n" \
  "#define GIV_RQ_SELECT_OPP_PART \\\n" \
  "\"select opposition from GYTTabPartOpp \\\n" \
  " where origine = :origine and refext = :refext\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_OPP_URLGR \\\n" \
  "\"select codan8 from GYTTabURLGrOpp \\\n" \
  " where etab = :etab and codan8 = :codan8\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_PROF_URLGR \\\n" \
  "\"select codan8 from GYTTabURLGrProf \\\n" \
  " where codan8 = :codan8\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_BL_CRC_LR \\\n" \
  "\"select codan8 from GYTTabBListCRCLR \\\n" \
  " where etab = :etab and codan8 = :codan8 \\\n" \
  "  and tpdsob = :tpdsob and contenu = :contenu\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_BL_CRC_FD \\\n" \
  "\"select tpdsob from GYTTabBListCRCFD \\\n" \
  " where (etab = :etab and contenu = :contenu) \\\n" \
  " or (tpdsob = :tpdsob)\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_BL_EPJ_FD \\\n" \
  "\"select etab from GYTTabBListEPJFD \\\n" \
  " where (etab = :etab)\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_BL_EPJ_PROF \\\n" \
  "\"select codan8 from GYTTabBListEPJProf \\\n" \
  " where etab = :etab and codan8 = :codan8\"\n" \
  "\n" \
  "/* conflits */\n" \
  "#define GIV_RQ_SELECT_PRIO_PROF_CRC \\\n" \
  "\"select codan8 from GYTTabCRCProfPrio \\\n" \
  " where codan8 = :codan8 and contenu = :contenu\"\n" \
  "\n" \
  "/* extra-localité proxi */\n" \
  "#define GIV_RQ_SELECT_EXTRA_LOC_IS \"\\\n" \
  " select b.codan8 from VueTabIeInsc_%s_%s_%s a,VueTabIaProf_%s_%s_%s b \\\n" \
  " where b.codan8 = :codan8 \\\n" \
  " and a.numnat = b.numnat and a.numlo = b.numlo and a.numls = b.numls \\\n" \
  " and a.etab = :etab \\\n" \
  " and decode(a.depact,null,decode(a.coddep,null,a.deppar,a.coddep),a.depact) = a.deppar \\\n" \
  " and decode(a.locact,null,decode(a.codloc,null,a.locpar,a.codloc),a.locact) = decode(a.locpar,'99999',decode(a.locact,null,a.codloc,a.locact),a.locpar) \\\n" \
  " union \\\n" \
  " select b.codan8 from VueTabIeInsc_%s_%s_%s a,GYTtabProfEtab b \\\n" \
  " where b.etab = :etab \\\n" \
  " and b.codan8 = :codan8 \\\n" \
  " and (b.origine = '4' or b.origine = '6') \\\n" \
  " and a.etab = b.etab \\\n" \
  " and a.numls = '0000' \\\n" \
  " and decode(a.depact,null,decode(a.coddep,null,a.deppar,a.coddep),a.depact) = a.deppar \\\n" \
  " and decode(a.locact,null,decode(a.codloc,null,a.locpar,a.codloc),a.locact) = decode(a.locpar,'99999',decode(a.locact,null,a.codloc,a.locact),a.locpar) \\\n" \
  "\"\n" \
  "#define GIV_RQ_SELECT_EXTRA_LOC_INTER_IS \"\\\n" \
  " select a.numnat,a.numlo,a.numls \\\n" \
  " from VueTabIeInsc_%s_%s_%s a,VueTabIaProf_%s_%s_%s b \\\n" \
  " where b.codan8 = :codan8 \\\n" \
  " and a.numnat = b.numnat and a.numlo = b.numlo and a.numls = b.numls \\\n" \
  " and a.etab = :etab \\\n" \
  " union \\\n" \
  " select a.numnat,a.numlo,a.numls \\\n" \
  " from VueTabIeInsc_%s_%s_%s a,GYTtabProfEtab b \\\n" \
  " where b.etab = :etab \\\n" \
  " and b.codan8 = :codan8 \\\n" \
  " and (b.origine = '4' or b.origine = '6') \\\n" \
  " and a.etab = b.etab \\\n" \
  " and a.numls = '0000' \\\n" \
  "\"\n" \
  "\n" \
  "#define GIV_RQ_SELECT_EXTRA_LOC_IO \"\\\n" \
  "(select b.codan8 from VueTabIeInsc_%s_%s_%s a, VueTabIaProf_%s_%s_%s b \\\n" \
  " where a.etab = :etab and a.numls != '0000' \\\n" \
  " and (decode(a.depact,null,decode(a.coddep,null,a.deppar,a.coddep),a.depact) != a.deppar \\\n" \
  " or decode(a.locact,null,decode(a.codloc,null,a.locpar,a.codloc),a.locact) != decode(a.locpar,'99999',decode(a.locact,null,a.codloc,a.locact),a.locpar)) \\\n" \
  " and b.numnat = a.numnat and b.numlo = a.numlo and b.numls = a.numls \\\n" \
  " and not exists ( \\\n" \
  "       (select h.codan8 from VueTabIaProf_%s_%s_%s h \\\n" \
  "        where h.numnat = :numnat and h.numlo = :numlo and h.numls = :numls \\\n" \
  "        union select k.codan8 from gyttabProfEtab k \\\n" \
  "        where k.etab = :etab and (k.origine = '4' or k.origine = '6')) \\\n" \
  "        minus \\\n" \
  "       (select g.codan8 from VueTabIaProf_%s_%s_%s g \\\n" \
  "        where g.numnat = b.numnat and g.numlo = b.numlo and g.numls = b.numls) ) ) \\\n" \
  " minus (select i.codan8 from VueTabIaProf_%s_%s_%s i \\\n" \
  "        where i.numnat = :numnat and i.numlo = :numlo and i.numls = :numls \\\n" \
  " union  select j.codan8 from GYTtabProfEtab j \\\n" \
  "        where j.etab = :etab and (j.origine = '4' or j.origine = '6')) \\\n" \
  "\"\n" \
  "#define GIVRequeteSyno \\\n" \
  "\"select codan8,synonymes from GyttabDenomSynonyme \\\n" \
  "where denom = :denom\"\n" \
  "\n" \
  "#define GIV_SLC_LIENS_PROF_PUB \\\n" \
  "\"select numnatrec,numlorec,numlsrec,codan8 from GYTtabIeInscRecGPP_%s \\\n" \
  "where numnat = :numnat and numlo = :numlo and numls = :numls\"\n" \
  "\n" \
  "#include \"GivrEltListTEpj.h\"\n" \
  "\n" \
  "typedef struct\n" \
  "{\n" \
  "    char reg[2 + 1]; /*                                   */\n" \
  "    char dep[3 + 1]; /*                                   */\n" \
  "    char loc[5 + 1]; /*                                   */\n" \
  "    int4 nbarr;\n" \
  "    int4 iParuInst;\n" \
  "} givrRefArrT;\n" \
  "\n" \
  "#include \"GivrRangListTEpj.h\"\n" \
  "\n" \
  "/* liste des codes d'installation */\n" \
  "GivrRangListTEpj givrListInst;\n" \
  "/* liste des codes de parution */\n" \
  "GivrRangListTEpj givrListParu;\n" \
  "/* codes dep/loc/arr */\n" \
  "givrRefArrT givtrRefArr[6] =\n" \
  "{\n" \
  "    { \"11\", \"075\", \"05600\", 20, -1 },\n" \
  "    { \"82\", \"069\", \"12300\", 9, -1 },\n" \
  "    { \"93\", \"013\", \"05500\", 16, -1 },\n" \
  "    { \"11\", \"075\", \"99999\", 20, -1 },\n" \
  "    { \"82\", \"069\", \"99999\", 9, -1 },\n" \
  "    { \"93\", \"013\", \"99999\", 16, -1 }\n" \
  "};\n" \
  "\n" \
  "#include \"GivrEltListObjTEpj.h\"\n" \
  "#include \"GivrRangListObjTEpj.h\"\n" \
  "\n" \
  "/* liste des objets */\n" \
  "GivrRangListObjTEpj givrListObj;\n" \
  "\n" \
  "#include \"GivrRangListCRCTEpj.h\"\n" \
  "\n" \
  "int4 giviConflitCRC;\n" \
  "int4 giviNbCRC;\n" \
  "/* liste des CRC */\n" \
  "GivrRangListCRCTEpj givrListCRC;\n" \
  "/* type des contenus */\n" \
  "typedef struct\n" \
  "{\n" \
  "    char tcEtab[GYBIeinscLgEtab2]; /* etab */\n" \
  "    char tcType[GYBIamicLgTpdsob + 1]; /* type */\n" \
  "    char tcThm[GYBIamicLgTpdsob]; /* theme */\n" \
  "} givrTypeContEtabT;\n" \
  "/* type des contenus prof */\n" \
  "typedef struct\n" \
  "{\n" \
  "    char tcEtab[GYBIeinscLgEtab2]; /* etab */\n" \
  "    char tcAn8[GYBIaprofLgCodan8 + 1]; /* an8 */\n" \
  "    char tcType[3]; /* type */\n" \
  "    char cIndic; /* présence de contenu */\n" \
  "} givrContProfEtabT;\n" \
  "/* liste des contenus par epj */\n" \
  "int4 giviNbContEtab;\n" \
  "givrTypeContEtabT givrListContEtab[MAX_LIST_CONT];\n" \
  "/* liste des contenus par epj et an8 */\n" \
  "int4 giviNbProfEtab;\n" \
  "givrContProfEtabT givrListProfEtab[MAX_LIST_CONT];\n" \
  "\n" \
  "/* description dans PartEtab */\n" \
  "GYBrIapartT givtrPart[MAX_PARENT];\n" \
  "GYBstrIapartCleNavT givtcCleNav[MAX_PARENT];\n" \
  "int4 giviNbParentPart;\n" \
  "int4 giviRefPJDC;\n" \
  "int4 giviNbIapartPJDC;\n" \
  "int4 giviNbTupleIapart;\n" \
  "\n" \
  "/*------------------------------Données exportées-----------------------------*/\n" \
  "extern char cDate[GYBIeBlocLgDateModBloc + 1];\n" \
  "\n" \
  "/*------------------------------Données internes------------------------------*/\n" \
  "static int4 giviNumFic;\n" \
  "int4 giviEnrich = (int4)GIV::GIXCodeKO;\n" \
  "int4 giviCodRetEcr = (int4)GIV::GIXCodeOK;\n" \
  "nat2 usLgchamp = 0; /* longueur du champ a encoder */\n" \
  "nat2 usSaveLg = 0; /* longueur d'un sous ensemble TLV */\n" \
  "nat2 usSaveLgEns = 0; /* longueur d'un ensemble TLV */\n" \
  "nat2 usLgTotale = 0;\n" \
  "nat2 usSaveLgTot = 0; /* longueur totale du mouvement CD hors compteur de longueur*/\n" \
  "/* GYBrParam_erreurT    vErreurSQL; */\n" \
  "char cCodope[GYBMouvementsLgCodope + 1];\n" \
  "char cNumlot[GYBMouvementsLgNumlot + 1];\n" \
  "char cNummvt[GYBMouvementsLgNummvt + 1];\n" \
  "char cNumnat[GYBMouvementsLgNumnat + 1];\n" \
  "/* buffer pour cryptage éventuel du nouveau numéro national */\n" \
  "char givcNumnat[128];\n" \
  "char cNumlo[GYBMouvementsLgNumlo + 1];\n" \
  "char cNumls[GYBMouvementsLgNumls + 1];\n" \
  "GYBstrBlocBlocidT cBlocidPrec; /* numero de bloc de parution précédent */\n" \
  "int1 cDrapeauEns; /* Indicateur de presence d'au moins un ensemble */\n" \
  "int1 cDrapeauEnsDe; /* Indicateur de presence d'au moins un ensemble de */\n" \
  "char nogrou_sav[7 + 1]; /* num groupement à garder */\n" \
  "int4 indic_nbclones = 0; /* indicateur nb clones */\n" \
  "int4 resultat = 0;\n" \
  "int4 boolen = 0; /* indicateur bloc non vide */\n" \
  "char nom_bloc[50 + 1]; /* Nom du bloc de parution                */\n" \
  "char nom_bloc_ref[50 + 1]; /* Référecne Nom du bloc de parution                */\n" \
  "int4 num_bloc = 1; /* Numero bloc de parution */\n" \
  "int4 iMaxBlocEcritAvant;\n" \
  "int4 iMaxBlocEcritAvantIG;\n" \
  "static int4 GIVAnnulerBlocCGenTest; /* Annuler le bloc courant à cause d'un echec CGenTest */\n" \
  "\n" \
  "EXEC SQL begin declare section;\n" \
  "\n" \
  "    typedef struct\n" \
  "    {\n" \
  "        char tcPart[5]; /* partenaire */\n" \
  "        char tcProd[3]; /* produit fictif associé */\n" \
  "    } givPartT;\n" \
  "\n" \
  "    typedef struct\n" \
  "    {\n" \
  "        char designation_ligne[100 + 1]; /*                                   */\n" \
  "    } Tab_designation_ligne;\n" \
  "\n" \
  "    typedef struct\n" \
  "    {\n" \
  "        char module[300 + 1]; /*                                   */\n" \
  "    } Tab_module;\n" \
  "    \n" \
  "\n" \
  "#include \"GYBrDOCUMENTEpj.h\"\n" \
  "EXEC SQL end declare section;\n" \
  "\n" \
  "/*---------------------------------------- Fonctions internes -----------------------------------------------------------*/\n" \
  "int4 giv_ecrit_partie_3_geo(char** buf_pos_in, GYBrDOCUMENTEpj* docClone, int4 iInit, int4 iRangTri, int4 iTypeLoc, int4 iValLoc, char* pcBalise);\n" \
  "\n" \
  "/* Tableau pour la sauvegarde des n documents associés à un groupement */\n" \
  "GYBrDOCUMENTEpj doc2[GIV_TAILLE_MAX_EPJ];\n" \
  "/* Tableau pour concaténation des DL des clones */\n" \
  "char buf_concat[50000];\n" \
  "/* taille fichier de sortie XML en blocs de parution */\n" \
  "static int4 giviNbBlocs;\n" \
  "/* flag fermeture du fichier */\n" \
  "static int4 giviClose = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "/* Buffer pour ecriture dans le fichier XML */\n" \
  "/* La plus grosse ecriture a lieu par la fonction 'givBlocsClones' , attention risque debordement ! */\n" \
  "char GIVBuffXML[800000];\n" \
  "/* Buffer intermédiaire pour traduction */\n" \
  "char GIVBuffInter[800000];\n" \
  "/* Buffer intermédiaire pour analyse clob */\n" \
  "char GIVBuffClob[800000];\n" \
  "/* Buffer complet pour appel API de Cas de Tests */\n" \
  "char GIVBuffTest[giv_LG_BUFFTEST];\n" \
  "/* fichier des etablissements perdus */\n" \
  "FILE* GIVfDescFicETB;\n" \
  "/* fichier des conflits de contenus */\n" \
  "FILE* GIVfDescFicCFLT;\n" \
  "/* fichier des Photos de PVI */\n" \
  "FILE* GIVfDescFicPhotos;\n" \
  "\n" \
  "/* clob pour lecture de données en XMLType */\n" \
  "static OCIClobLocator* givprClob = NULL;\n" \
  "static OCIClobLocator* givprDbl1Clob = NULL;\n" \
  "static OCIClobLocator* givprDbl2Clob = NULL;\n" \
  "\n" \
  "static int4 nb_noyau;\n" \
  "static int4 nb_module;\n" \
  "static int4 nb_micro;\n" \
  "static int4 nb_an9;\n" \
  "static int4 nb_marque;\n" \
  "/* static int4 nb_designation_ligne = 0; */\n" \
  "static int4 nb_inscription = 0;\n" \
  "\n" \
  "static int4 num_id = 0; /* Numero identifiant parution */\n" \
  "\n" \
  "static int4 obtention_iden = 0; /* Flag pour traitement unique */\n" \
  "char givcCheminBloc[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "char givcRepertoire[128] = \"\"; /* Répertoire des fichiers utilises */\n" \
  "\n" \
  "static char remplace_espace[5 + 1]; /* Le premier car. va remplacer l'espace selon Reg_Sel_19 */\n" \
  "\n" \
  "static char memo_chaine_pjparutionid[100 + 1]; /* Memorisation de la chaine identifiant parution */\n" \
  "\n" \
  "static int4 pos_paru_id; /* Position pour écriture parution id */\n" \
  "char givtcRepSgiPro[128] = \"\"; /* Pathname des fichiers SGIPRO */\n" \
  "char givtcRepMpg[128] = \"\"; /* Pathname des fichiers du flux MPG */\n" \
  "char givtcRegCECI[4] = \"\"; /* anciennes/nouvelles régions du CECI */\n" \
  "char givtcLocArrInst[60] = \"\"; /* Localités à parution sur arrondiseement d'installation */\n" \
  "char givtcPrioCont[GWT_LG_MAX_LIGNE + 1] = \"\"; /* liste des contenus prioritaires */\n" \
  "char givtcExceptCont[GWT_LG_MAX_LIGNE + 1] = \"\"; /* liste des exceptions sur les contenus */\n" \
  "char givtcObjCont[GWT_LG_MAX_LIGNE + 1] = \"\"; /* liste des objets contenu */\n" \
  "char givtcFourPart[GWT_LG_MAX_LIGNE + 1] = \"\"; /* liste des partenaires à éliminer */\n" \
  "char givtcContenu[4] = \"\"; /* validation des objets contenu */\n" \
  "char givtcRapED[5] = \"\"; /* rapprochement ED */\n" \
  "char givcTriPub[2];\n" \
  "char givtcAnMes[512] = \"\"; /* liste des objets contenu */\n" \
  "char givtcSupCplDen[4] = \"\"; /* qualite dans complement de denom */\n" \
  "char givtcInvDenPn[4] = \"\"; /* inversion ordre denom prenom */\n" \
  "char givtcGeneIeBlocCRC[4] = \"\"; /* accès à la table GYTtabIeBLocCRC */\n" \
  "char givtcGeneAffCRC[4] = \"\"; /* affichage de la table GYTtabIeBLocCRC */\n" \
  "char givtcPartInsc[4] = \"\"; /* affichage partenaire au niveau inscription */\n" \
  "char givtcClause[GWT_LG_MAX_LIGNE];\n" \
  "char givtcVersDoc[GWT_LG_MAX_LIGNE]; /* version commune configurée des documents */\n" \
  "char givtcParuInscEpj[4] = \"\"; /* affichage des parutions par inscription et par epj */\n" \
  "char givtcContText[4] = \"\"; /* affichage balises contenu et text */\n" \
  "/* origine de partenaire */\n" \
  "int4 giviPart;\n" \
  "static char givtcOriPart[4 + 1] = \"\";\n" \
  "static char givtcAn9Part[GYBPaprofLgCodan9 + 1] = givcR00000000;\n" \
  "static char givtcAn8Part[GYBPaprofLgCodan8 + 1] = \"\";\n" \
  "\n" \
  "/* Declaration et reservation du document necessaire a la creation d'un bloc XML */\n" \
  "static GYBrDOCUMENTEpj doc;\n" \
  "\n" \
  "/* Correspondance entre les chiffres et les caractères de codage */\n" \
  "/* du numéro de client dans le champ LO */\n" \
  "static const nat1 givtcCLIENTLO[] =\n" \
  "{\n" \
  "    /*        0     1     2     3     4     5     6     7     8     9  A B C D E F*/\n" \
  "    /* 0 */0x41, 0x3B, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 1 */0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 2 */0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 3 */0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 4 */0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 5 */0x79, 0x7A, 0xC4, 0xCB, 0xCF, 0xD6, 0xDC, 0xE4, 0xEB, 0xEF, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 6 */0xF6, 0xFC, 0xFF, 0xC2, 0xCA, 0xCE, 0xD4, 0xDB, 0xE2, 0xEA, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 7 */0xEE, 0xF4, 0xFB, 0xE0, 0xE9, 0xE8, 0xF9, 0xE7, 0xB5, 0x7E, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 8 */0x5E, 0xA8, 0xB0, 0xB2, 0x2B, 0x2D, 0x23, 0x3D, 0x2C, 0x2F, 0, 0, 0, 0, 0, 0,\n" \
  "    /* 9 */0x40, 0x7B, 0x7D, 0x28, 0x29, 0xA7, 0xA3, 0x3F, 0x21, 0x3A, 0, 0, 0, 0, 0, 0,\n" \
  "    /* A */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n" \
  "    /* B */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n" \
  "    /* C */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n" \
  "    /* D */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n" \
  "    /* E */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n" \
  "    /* F */0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n" \
  "};\n" \
  "/* ASCII numérique */\n" \
  "#define giv_Min 0x30\n" \
  "#define giv_Max 0x39\n" \
  "\n" \
  "int1 cTabRefClone[] =\n" \
  "{ 1, 3, 2, 5, 4 };\n" \
  "\n" \
  "#define giv_open \"open\"\n" \
  "#define giv_write \"write\"\n" \
  "#define giv_close \"close\"\n" \
  "\n" \
  "#define givNbCVI 9\n" \
  "#define givNbFixeCVI 4\n" \
  "static char* givTabCVI[givNbCVI] =\n" \
  "{ \" T\", \"NT\", \"NV\", \"NS\", \" P\", \"KT\", \"KV\", \"KS\", \"NM\" };\n" \
  "#define givNbPart 8\n" \
  "static givPartT givTabPart[givNbPart] =\n" \
  "{\n" \
  "    { \"RESA\", \"0C\" },\n" \
  "    { \"EXPD\", \"0E\" },\n" \
  "    { \"LAFO\", \"0L\" },\n" \
  "    { \"ACCO\", \"0A\" },\n" \
  "    { \"CRDV\", \"0R\" },\n" \
  "    { \"LEAD\", \"0F\" },\n" \
  "    { \"CHRO\", \"0O\" },\n" \
  "    { \"PJDC\", \"0D\" }\n" \
  "};\n" \
  "\n" \
  "/* commentaire XML */\n" \
  "char cComm_xml0[] = \"<!-- \";\n" \
  "char cComm_xml1[] = \" -->\";\n" \
  "\n" \
  "/*-----------------------------Fonctions internes-----------------------------*/\n" \
  "\n" \
  "/* HAL, 13/11/2008 pour Linux : ajout des déclarations des fonctions qui sont utilisées avant leur déclaration */\n" \
  "static int4 giv_sortie(char**, FILE*);\n" \
  "static int4 giv_sortie_ISO(char**, FILE*);\n" \
  "static int4 giv_fichier_sortie(char**, FILE**);\n" \
  "static int4 giv_fermeture_fichier_sortie(char**, char*);\n" \
  "static int4 giv_ecrit_noeud_simple(char*, char*);\n" \
  "static int4 giv_ecrit_noeud_attr(char*, char*, char*);\n" \
  "static int4 giv_ecrit_fin_noeud(char**, char*);\n" \
  "static int4 givAnalyseContenu(char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 givEcritContenu(char*, char**, GYBrDOCUMENTEpj*, int4, int4*);\n" \
  "static int4 givEcritContenuED(char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 givEcritContenuEDEtab(char*, char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 givEcritDonAdd(char*, char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 givEcritDonRelais(char**, GYBrDOCUMENTEpj*, int4, int4);\n" \
  "static int4 givEcritDonEnr(char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 givEcritSgiPro(char**, GYBrDOCUMENTEpj*, int4, int4, int4, char*, int4);\n" \
  "static int4 givEcritSgiProED(char*, char*, char**, char*, GYBrDOCUMENTEpj*, char*, char*, char*, int4*);\n" \
  "static int4 givEcritSgiProPart(char**, GYBrDOCUMENTEpj*, char*, char*, char*, char*, int4*);\n" \
  "static int4 givEcritSgiProPartEtab(char**, GYBrDOCUMENTEpj*, int4, char*, char*, char*, char*, int4*);\n" \
  "static int4 givEcritSgiProBOC(char**, GYBrDOCUMENTEpj*, int4, char*, char*, char*);\n" \
  "static int4 givEcritImages(char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 givEcritDonAnnonceur(char**, GYBrDOCUMENTEpj*, int4, int4, int4, char*, int4);\n" \
  "static int4 givEcritDonEtab(char*, char*, char**, char*, GYBrDOCUMENTEpj*, char*, char*, char*, int4*);\n" \
  "static int4 givAffCRCEtab(char**);\n" \
  "static int4 givDelIeBlocCRC(char*);\n" \
  "static int4 givInsIeBlocCRC(void);\n" \
  "static int4 givMutualiserDonPartenaires(char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 givEcritPart(char**, GYBrDOCUMENTEpj*, int4);\n" \
  "static int4 giv_ecrit_balise(char*, char*, char*);\n" \
  "static int4 giv_ecrit_balise_epj(char**, char*, char*);\n" \
  "static int4 giv_ecrit_balise_iso(char*, char*, char*);\n" \
  "static int4 giv_ecrit_objet_pub(char**, GYBrDOCUMENTEpj*, int4, int4, char*);\n" \
  "static int4 giv_ecrit_element(char*, char*, char*);\n" \
  "static int4 givAnalyseCRC(char*, int4, GYBrDOCUMENTEpj*, char*, char*, char*);\n" \
  "static int4 givAnalyseObjetXML(char*, GYBrDOCUMENTEpj*, char*, char**);\n" \
  "static int4 givEcritDonHoraires(char**, GYBrDOCUMENTEpj*, int4);\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givTradChar                                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : remplacer un caractère dans le buffer de sortie                */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : le buffer                                                      */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : le même buffer                                                 */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "void givTradChar(int4* lg)\n" \
  "{\n" \
  "    char* pt_fin_liste;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_ecriture;\n" \
  "    int4 lg_element;\n" \
  "    size_t lgInter, lg_in;\n" \
  "    iconv_t iConv;\n" \
  "    char* buf_in;\n" \
  "    char* buf_out;\n" \
  "    /* Effacement du buffer */\n" \
  "    /* Buffer intermédiaire */\n" \
  "    memcpy(GIVBuffInter, GIVBuffXML, strlen(GIVBuffXML));\n" \
  "    GIVBuffInter[strlen(GIVBuffXML)] = '\\0';\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Lgs: %d,%d,%d\\n\", *lg, strlen(GIVBuffXML), strlen(GIVBuffInter)));\n" \
  "    /* Effacement du buffer */\n" \
  "    GIVBuffXML[0] = '\\0';\n" \
  "    pt_fin_liste = GIVBuffInter + *lg;\n" \
  "    pt_ecriture = GIVBuffXML;\n" \
  "\n" \
  "    for (pt_debut_element = GIVBuffInter; pt_debut_element < pt_fin_liste;)\n" \
  "    {\n" \
  "        pt_fin_element = strchr(pt_debut_element, '&');\n" \
  "\n" \
  "        if (pt_fin_element == 0)\n" \
  "            pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "        lg_element = pt_fin_element - pt_debut_element;\n" \
  "\n" \
  "        /* traduction */\n" \
  "        if ((GIVBuffInter != pt_debut_element) || (GIVBuffInter == pt_fin_element))\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Traduction & \\n\"));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Lg Traduction totale &: %d\\n\", *lg));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Lg Traduction &: %d\\n\", lg_element));\n" \
  "            strcpy(pt_ecriture, givTrad);\n" \
  "            pt_ecriture += strlen(givTrad);\n" \
  "        }\n" \
  "\n" \
  "        /* copie chaîne non modifiée */\n" \
  "        memcpy(pt_ecriture, pt_debut_element, lg_element);\n" \
  "        pt_ecriture = pt_ecriture + lg_element;\n" \
  "        *pt_ecriture = '\\0';\n" \
  "        pt_debut_element = pt_fin_element + 1;\n" \
  "    }\n" \
  "\n" \
  "    *lg = strlen(GIVBuffXML);\n" \
  "    /* Traduction UTF8 */\n" \
  "    iConv = iconv_open(\"UTF-8\", \"ISO8859-1\");\n" \
  "    buf_in = GIVBuffXML;\n" \
  "    lg_in = strlen(GIVBuffXML) + 1;\n" \
  "    buf_out = GIVBuffInter;\n" \
  "    lgInter = sizeof(GIVBuffInter);\n" \
  "\n" \
  "    if ((iconv_t)(-1) != iConv)\n" \
  "    {\n" \
  "        iconv(iConv, &buf_in, (size_t*)&lg_in, &buf_out, (size_t*)&lgInter);\n" \
  "        iconv_close(iConv);\n" \
  "        strcpy(GIVBuffXML, GIVBuffInter);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fin de Conversion UTF8: %d, %d\\n\", lgInter, strlen(GIVBuffXML)));\n" \
  "    }\n" \
  "\n" \
  "    *lg = strlen(GIVBuffXML);\n" \
  "    return;\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givConvClob                                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : traitement UTF8, carcatères spéciaux d'un XMLType              */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : le buffer                                                      */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : le même buffer                                                 */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "void givConvClob()\n" \
  "{\n" \
  "    size_t lgInter, lg_in;\n" \
  "    iconv_t iConv;\n" \
  "    char* buf_in;\n" \
  "    char* buf_out;\n" \
  "    (void)strcpy(GIVBuffXML, GIVBuffInter);\n" \
  "    /* Traduction UTF8 */\n" \
  "    iConv = iconv_open(\"UTF-8\", \"ISO8859-1\");\n" \
  "    buf_in = GIVBuffXML;\n" \
  "    lg_in = strlen(GIVBuffXML) + 1;\n" \
  "    buf_out = GIVBuffInter;\n" \
  "    lgInter = sizeof(GIVBuffInter);\n" \
  "\n" \
  "    if ((iconv_t)(-1) != iConv)\n" \
  "    {\n" \
  "        iconv(iConv, &buf_in, (size_t*)&lg_in, &buf_out, (size_t*)&lgInter);\n" \
  "        iconv_close(iConv);\n" \
  "        /* Mantis 70297 : remplacement des caractères spéciaux par leur chaîne UTF8  */\n" \
  "        /* (les caractères Laquo et Raquo sont éliminés en amont par PJ)     */\n" \
  "        gwtRemplaceChaine(GIVBuffInter, GXW_cg_Euro, GXW_utf8_Euro, GIVBuffXML);\n" \
  "        gwtRemplaceChaine(GIVBuffXML, GXW_cg_OE, GXW_utf8_OE, GIVBuffInter);\n" \
  "        gwtRemplaceChaine(GIVBuffInter, GXW_cg_oe, GXW_utf8_oe, GIVBuffXML);\n" \
  "        gwtRemplaceChaine(GIVBuffXML, GXW_cg_Copyright, GXW_utf8_Copyright, GIVBuffInter);\n" \
  "        gwtRemplaceChaine(GIVBuffInter, GXW_cg_Nbsp, GXW_utf8_Nbsp, GIVBuffXML);\n" \
  "        gwtRemplaceChaine(GIVBuffXML, GXW_cg_Laquo, GXW_utf8_Laquo, GIVBuffInter);\n" \
  "        gwtRemplaceChaine(GIVBuffInter, GXW_cg_Raquo, GXW_utf8_Raquo, GIVBuffXML);\n" \
  "        (void)strcpy(GIVBuffInter, GIVBuffXML);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fin de Conversion UTF8: %d, %d\\n\", lgInter, strlen(GIVBuffInter)));\n" \
  "    }\n" \
  "\n" \
  "    GIVBuffXML[0] = '\\0';\n" \
  "    return;\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givConvURL                                                   */\n" \
  "/*                                                                            */\n" \
  "/* But       : traitement UTF8, carcatères spéciaux d'une URL                 */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : le buffer                                                      */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : le même buffer                                                 */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "void givConvURL(char* acLibUrl)\n" \
  "{\n" \
  "    size_t lgInter, lg_in;\n" \
  "    iconv_t iConv;\n" \
  "    char* buf_in;\n" \
  "    char* buf_out;\n" \
  "    int4 i, j;\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    /* traduction de <,> et \" */\n" \
  "    j = 0;\n" \
  "\n" \
  "    for (i = 0; i < strlen(acLibUrl); i++)\n" \
  "    {\n" \
  "        if ('<' == acLibUrl[i])\n" \
  "        {\n" \
  "            buf_concat[j] = '\\0';\n" \
  "            strcat(buf_concat, \"&lt;\");\n" \
  "            j = strlen(buf_concat);\n" \
  "        }\n" \
  "        else if ('>' == acLibUrl[i])\n" \
  "        {\n" \
  "            buf_concat[j] = '\\0';\n" \
  "            strcat(buf_concat, \"&gt;\");\n" \
  "            j = strlen(buf_concat);\n" \
  "        }\n" \
  "        else if ('\"' == acLibUrl[i])\n" \
  "        {\n" \
  "            buf_concat[j] = '\\0';\n" \
  "            strcat(buf_concat, \"&quot;\");\n" \
  "            j = strlen(buf_concat);\n" \
  "        }\n" \
  "        else if ('&' == acLibUrl[i])\n" \
  "        {\n" \
  "            buf_concat[j] = '\\0';\n" \
  "            strcat(buf_concat, givTrad);\n" \
  "            j = strlen(buf_concat);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            buf_concat[j] = acLibUrl[i];\n" \
  "            j++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    buf_concat[j] = '\\0';\n" \
  "    /* Traduction UTF8 */\n" \
  "    iConv = iconv_open(\"UTF-8\", \"ISO8859-1\");\n" \
  "    buf_in = buf_concat;\n" \
  "    lg_in = strlen(buf_concat) + 1;\n" \
  "    buf_out = GIVBuffInter;\n" \
  "    lgInter = sizeof(GIVBuffInter);\n" \
  "\n" \
  "    if ((iconv_t)(-1) != iConv)\n" \
  "    {\n" \
  "        iconv(iConv, &buf_in, (size_t*)&lg_in, &buf_out, (size_t*)&lgInter);\n" \
  "        iconv_close(iConv);\n" \
  "        strcpy(buf_concat, GIVBuffInter);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fin de Conversion UTF8: %d, %d\\n\", lgInter, strlen(buf_concat)));\n" \
  "    }\n" \
  "\n" \
  "    return;\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givLectClob                                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : lecture d'un clob en varchar                                   */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : clob                                                           */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : buffer                                                         */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "void givLectClob(OCIClobLocator* apClob, char* apcEtab, char* apcObj, char* apcTyp, char* apcSource)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour des appels internes */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    OCIClobLocator* pOraClob;\n" \
  "    int4 iLgEcrit = 0;\n" \
  "    nat8 length;\n" \
  "    nat8 lgthmax;\n" \
  "    VARCHAR tcXMLTexte[giv_LG_CLOB + 1];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    /* lecture du début de bloc */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"Lecture dans CLOB\");\n" \
  "    iIntRet = (int4)GIV::GYBok;\n" \
  "    length = 0;\n" \
  "    lgthmax = giv_LG_CLOB;\n" \
  "    iLgEcrit = 0;\n" \
  "    pOraClob = apClob;\n" \
  "    GIVBuffInter[0] = '\\0';\n" \
  "\n" \
  "    while (((int4)GIV::GYBok == iIntRet) && (NULL != pOraClob))\n" \
  "    {\n" \
  "        tcXMLTexte.arr[0] = '\\0';\n" \
  "        tcXMLTexte.len = giv_LG_CLOB;\n" \
  "        EXEC SQL\n" \
  "        LOB\n" \
  "        READ :length\n" \
  "        FROM :pOraClob\n" \
  "        INTO :tcXMLTexte WITH\n" \
  "        LENGTH: lgthmax;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Taille lob lue: %d,%d,%d\\n\", iIntRet, length, tcXMLTexte.len));\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if (((int4)GIV::GYBok != iIntRet) && ((int4)GIV::GYBnodata != iIntRet))\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur lecture Clob: Epj='%s' Obj='%s' Typ='%s' Src='%s'\\n\", apcEtab, apcObj, apcTyp, apcSource));\n" \
  "            iIntRet = (int4)GIV::GYBnok;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            tcXMLTexte.arr[tcXMLTexte.len] = '\\0';\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Debut lob lu: !%c,%c,%c!\\n\", tcXMLTexte.arr[0], tcXMLTexte.arr[1], tcXMLTexte.arr[2]));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Fin lob lu: !%s!\\n\", &tcXMLTexte.arr[tcXMLTexte.len - 5]));\n" \
  "\n" \
  "            /* suppression de l'indentation */\n" \
  "            if ((int4)sizeof(GIVBuffInter) <= (iLgEcrit + (int4)tcXMLTexte.len))\n" \
  "            {\n" \
  "                /* fin car buffer insuffisant */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Buffer lecture Clob insuffisant : Epj='%s' Obj='%s' Typ='%s' Src='%s'\\n\", apcEtab, apcObj, apcTyp, apcSource));\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille Clob lue: %d,%d,%d,%d\\n\", iIntRet, length, tcXMLTexte.len, iLgEcrit));\n" \
  "                iIntRet = (int4)GIV::GYBnok;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                (void)GIWSuppIndent((char*)tcXMLTexte.arr, &GIVBuffInter[iLgEcrit]);\n" \
  "                iLgEcrit = strlen(GIVBuffInter);\n" \
  "            }\n" \
  "\n" \
  "            if ((int4)GIV::GYBnodata == iIntRet)\n" \
  "            {\n" \
  "                /* fin de lecture */\n" \
  "                iIntRet = (int4)GIV::GYBnok;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    return;\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : GIVCodeClient                                                  */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "int4 GIVCodeClient(char* cClient, int4 lg_chp)\n" \
  "{\n" \
  "    int4 iLong = 0;\n" \
  "    int4 iVal, i = 0;\n" \
  "    int4 iCodRet = (int4)GIV::GWCCodeOK;\n" \
  "    char client_decode[14 + 1] = \"\"; /* numlo ou IG decode pr bloc de parution */\n" \
  "\n" \
  "    for (i = 0; i < lg_chp; i++)\n" \
  "    {\n" \
  "        if ((cClient[i] >= giv_Min) && (cClient[i] <= giv_Max))\n" \
  "        {\n" \
  "            strcpy(client_decode, cClient);\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (lg_chp == i)\n" \
  "    {\n" \
  "        while (iLong < lg_chp)\n" \
  "        {\n" \
  "            iVal = 0;\n" \
  "\n" \
  "            while (((nat1)(cClient[iLong]) != givtcCLIENTLO[iVal]) && (256 != iVal))\n" \
  "                iVal++;\n" \
  "\n" \
  "            if (iVal == 256)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur ne retrouve pas la valeur ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "            }\n" \
  "\n" \
  "            client_decode[(iLong * 2) + 1] = (char)((iVal % giv_DIV_PAR_DIX) + '0');\n" \
  "            iVal = iVal / giv_DIV_PAR_DIX;\n" \
  "            client_decode[(iLong * 2)] = (char)((iVal % giv_DIV_PAR_DIX) + '0');\n" \
  "            iLong++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"client_decode = %s\\n\", client_decode));\n" \
  "    strcpy(GIVtcClientDecode, client_decode);\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "/*---------------------fin fonction-------------------------------------------*/\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureEtab ()                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche des  données        */\n" \
  "/*             à partir de l'établissement dans les tables GYTtabPeetab,      */\n" \
  "/*             GYTtabEpjMic et GYTTabLiensEtab                                */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "extern int4 givPreparerLectureEtab(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE * 4];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureEtabMC\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_ETAB_MC);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_ETAB_MC);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureEtabMC\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureEtabMC\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureEtabMC : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureEtabMC\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureEtabMC\n" \
  "            cursor\n" \
  "            for rqtLectureEtabMC;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureEtabMC ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_SIREN);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_SIREN);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureSiren\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureSiren\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureSirenC : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureSiren\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureSiren\n" \
  "            cursor\n" \
  "            for rqtLectureSiren;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureSiren ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureEtab\n" \
  "            cursor\n" \
  "            for rqtLectureEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_DENOM_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_DENOM_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureDenomEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureDenomEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureDenomEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureDenomEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureDenomEtab\n" \
  "            cursor\n" \
  "            for rqtLectureDenomEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureDenomEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_PHOTOS_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_PHOTOS_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLecturePhotosEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLecturePhotosEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLecturePhotosEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLecturePhotosEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLecturePhotosEtab\n" \
  "            cursor\n" \
  "            for rqtLecturePhotosEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLecturePhotosEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_PUB_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_PUB_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLecturePubEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLecturePubEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLecturePubEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLecturePubEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLecturePubEtab\n" \
  "            cursor\n" \
  "            for rqtLecturePubEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLecturePubEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_PUB_GCPT);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_PUB_GCPT);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLecturePubGCpt\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLecturePubGCpt\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLecturePubGCpt : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLecturePubGCpt\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLecturePubGCpt\n" \
  "            cursor\n" \
  "            for rqtLecturePubGCpt;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLecturePubGCpt ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_PEETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_PEETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLecturePeEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLecturePeEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLecturePeEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLecturePeEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLecturePeEtab\n" \
  "            cursor\n" \
  "            for rqtLecturePeEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLecturePeEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_OLD_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_OLD_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureOldEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureOldEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureOldEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureOldEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureOldEtab\n" \
  "            cursor\n" \
  "            for rqtLectureOldEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureOldEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_SLC_CONT_PROF_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_SLC_CONT_PROF_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureContProfEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureContProfEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureContProfEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureContProfEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureContProfEtab\n" \
  "            cursor\n" \
  "            for rqtLectureContProfEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureContProfEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_SLC_TYP_CONT_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_SLC_TYP_CONT_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureTypContEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureTypCont\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureTypContEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureTypContEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureTypContEtab\n" \
  "            cursor\n" \
  "            for rqtLectureTypContEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureTypContEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_SLC_LVS_SEO_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_SLC_LVS_SEO_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureLvsSeoEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureLvsSeo\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureLvsSeoEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureLvsSeoEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureLvsSeoEtab\n" \
  "            cursor\n" \
  "            for rqtLectureLvsSeoEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureLvsSeoEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_SLC_LIENS_PROD_ETAB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_SLC_LIENS_PROD_ETAB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureLiensEtab\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureLiensEtab\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureLiensEtab : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureLiensEtab\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureLiensEtab\n" \
  "            cursor\n" \
  "            for rqtLectureLiensEtab;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureLiensEtab ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_SLC_LIENS_PROF_PUB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete, GIV_SLC_LIENS_PROF_PUB, GIXcDepartement);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureLiensProfPub\n" \
  "        from :cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureLiensProfPub\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureLiensProfPub : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureLiensProfPub\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureLiensProfPub\n" \
  "            cursor\n" \
  "            for rqtLectureLiensProfPub;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureLiensProfPub ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureEtab/ContenusEtab/EtabMC/SIRET/Pub/Old/LvsSeo/LiensEtab/LiensProfPub\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givReprise ()                                                  */\n" \
  "/*                                                                            */\n" \
  "/* But       : offset de reprise                                              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givReprise(void)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    fpos_t rOffset;\n" \
  "    /* HAL : fonction modifiée pour Linux : fpos_t est un entier sous AIX, une structure sous Linux    */\n" \
  "    /* fpos64_t a été remplacé par fpos_t, et fgetpos64 a été remplacé par fgetpos            */\n" \
  "\n" \
  "    if (NULL != GIVfDescFicMCD)\n" \
  "    {\n" \
  "        iCodRet = (int4)fgetpos(GIVfDescFicMCD, &rOffset);\n" \
  "\n" \
  "        if ((int4)GIV::GWCCodeOK != iCodRet)\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur offset reprise  %d\\n\", iCodRet));\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        rOffset.__pos = 0;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur offset reprise \\n\"));\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Offset reprise  %10.0f\\n\", (double)rOffset.__pos));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givCompListObj\n" \
  " *\n" \
  " * But : Comparaison des objets publicitaires\n" \
  " *\n" \
  " * Description : comparaison Iamic\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "static int4 givCompListObj(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "	return givrListObj.givCompListObj(apList1, apList2, doc2);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givAjoutListCRC\n" \
  " *\n" \
  " * But : Ajout de crc\n" \
  " *\n" \
  " * Description : ajout crc dans liste si absent\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Nov/18/2013  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "static int4 givAjoutListCRC(GYBrPrioCRCT rPrioCRC)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iCodRet;\n" \
  "    int4 i;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    for (i = 0; i < givrListCRC.iNbr; i++)\n" \
  "    {\n" \
  "        if ((0 == strcmp(rPrioCRC.acEtab, givrListCRC.trEltList[i].acEtab)) && (0 == strcmp(rPrioCRC.acTpdsob, givrListCRC.trEltList[i].acTpdsob))\n" \
  "                && (0 == strcmp(rPrioCRC.acCRC, givrListCRC.trEltList[i].acCRC)) && (0 == strcmp(rPrioCRC.acCodan8, givrListCRC.trEltList[i].acCodan8))\n" \
  "                && (0 == strcmp(rPrioCRC.acType, givrListCRC.trEltList[i].acType)) && (rPrioCRC.iPrioCRC == givrListCRC.trEltList[i].iPrioCRC))\n" \
  "        {\n" \
  "            /* crc en double */\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    giviNbCRC = givrListCRC.iNbr;\n" \
  "\n" \
  "    if ((MAX_LIST_CRC == giviNbCRC) && (givrListCRC.iNbr == i))\n" \
  "    {\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\" Nombre de ref CRC atteint %d\\n\", giviNbCRC));\n" \
  "    }\n" \
  "    else if (givrListCRC.iNbr == i)\n" \
  "    {\n" \
  "        (void)strcpy(givrListCRC.trEltList[giviNbCRC].acTpdsob, rPrioCRC.acTpdsob);\n" \
  "        (void)strcpy(givrListCRC.trEltList[giviNbCRC].acCodan8, rPrioCRC.acCodan8);\n" \
  "        (void)strcpy(givrListCRC.trEltList[giviNbCRC].acType, rPrioCRC.acType);\n" \
  "        (void)strcpy(givrListCRC.trEltList[giviNbCRC].acEtab, rPrioCRC.acEtab);\n" \
  "        (void)strcpy(givrListCRC.trEltList[giviNbCRC].acCRC, rPrioCRC.acCRC);\n" \
  "        givrListCRC.trEltList[giviNbCRC].iPrioCRC = rPrioCRC.iPrioCRC;\n" \
  "        givrListCRC.trEltRangList[giviNbCRC] = giviNbCRC;\n" \
  "        giviNbCRC++;\n" \
  "        givrListCRC.iNbr = giviNbCRC;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givCompListCRC\n" \
  " *\n" \
  " * But : Comparaison des crc\n" \
  " *\n" \
  " * Description : comparaison etab,crc,an8,type\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Oct/04/2012  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "static int4 givCompListCRC(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iRetour;\n" \
  "    /** pointeur sur le rang du premier code à comparer */\n" \
  "    int4 iList1;\n" \
  "    /** pointeur sur le rang du second code à comparer */\n" \
  "    int4 iList2;\n" \
  "    /** Initialisation des pointeurs */\n" \
  "    iList1 = *(int4*)apList1;\n" \
  "    iList2 = *(int4*)apList2;\n" \
  "\n" \
  "    if ((0 == strlen(givrListCRC.trEltList[iList1].acEtab)) && (0 != strlen(givrListCRC.trEltList[iList2].acEtab)))\n" \
  "        return (1);\n" \
  "\n" \
  "    if ((0 != strlen(givrListCRC.trEltList[iList1].acEtab)) && (0 == strlen(givrListCRC.trEltList[iList2].acEtab)))\n" \
  "        return (-1);\n" \
  "\n" \
  "    iRetour = strcmp(givrListCRC.trEltList[iList1].acEtab, givrListCRC.trEltList[iList2].acEtab);\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "    else\n" \
  "    {\n" \
  "        iRetour = strcmp(givrListCRC.trEltList[iList1].acCodan8, givrListCRC.trEltList[iList2].acCodan8);\n" \
  "\n" \
  "        if (0 != iRetour)\n" \
  "            return (iRetour);\n" \
  "        else\n" \
  "        {\n" \
  "            iRetour = strcmp(givrListCRC.trEltList[iList1].acCRC, givrListCRC.trEltList[iList2].acCRC);\n" \
  "\n" \
  "            if (0 != iRetour)\n" \
  "                return (iRetour);\n" \
  "            else\n" \
  "            {\n" \
  "                iRetour = strcmp(givrListCRC.trEltList[iList1].acType, givrListCRC.trEltList[iList2].acType);\n" \
  "\n" \
  "                if (0 != iRetour)\n" \
  "                    return (iRetour);\n" \
  "                else\n" \
  "                {\n" \
  "                    iRetour = strcmp(givrListCRC.trEltList[iList1].acTpdsob, givrListCRC.trEltList[iList2].acTpdsob);\n" \
  "\n" \
  "                    if (0 != iRetour)\n" \
  "                        return (iRetour);\n" \
  "                    else\n" \
  "                    {\n" \
  "                        if (GIV::GIXCodeOK == givrListCRC.trEltList[iList1].iPrioCRC && GIV::GIXCodeOK != givrListCRC.trEltList[iList2].iPrioCRC)\n" \
  "                            return (-1);\n" \
  "                        else if (GIV::GIXCodeOK != givrListCRC.trEltList[iList1].iPrioCRC && GIV::GIXCodeOK == givrListCRC.trEltList[iList2].iPrioCRC)\n" \
  "                            return (1);\n" \
  "\n" \
  "                        return (0);\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givCompListInst\n" \
  " *\n" \
  " * But : Comparaison des codes géographiques d'installation\n" \
  " *\n" \
  " * Description : comparaison dept/loc/arr d'installation\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "static int4 givCompListInst(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "	return givrListInst.givCompareListe(apList1, apList2);\n" \
  "}\n" \
  "static int4 givCompListAn9Inst(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iRetour;\n" \
  "    /** pointeur sur le rang du premier code à comparer */\n" \
  "    int4 iList1;\n" \
  "    /** pointeur sur le rang du second code à comparer */\n" \
  "    int4 iList2;\n" \
  "    /** Initialisation des pointeurs */\n" \
  "    iList1 = *(int4*)apList1;\n" \
  "    iList2 = *(int4*)apList2;\n" \
  "    iRetour = strcmp(givrListInst.trEltList[iList1].rub, givrListInst.trEltList[iList2].rub);\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "    else\n" \
  "    {\n" \
  "        iRetour = (int4)givrListInst.trEltList[iList1].iRgLigne - givrListInst.trEltList[iList2].iRgLigne;\n" \
  "        return (iRetour);\n" \
  "    }\n" \
  "}\n" \
  "static int4 givCompListDenomInst(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iRetour;\n" \
  "    /** pointeur sur le rang du premier code à comparer */\n" \
  "    int4 iList1;\n" \
  "    /** pointeur sur le rang du second code à comparer */\n" \
  "    int4 iList2;\n" \
  "    /** Initialisation des pointeurs */\n" \
  "    iList1 = *(int4*)apList1;\n" \
  "    iList2 = *(int4*)apList2;\n" \
  "    iList1 = givrListInst.trEltList[iList1].iRgLigne;\n" \
  "    iList2 = givrListInst.trEltList[iList2].iRgLigne;\n" \
  "    iRetour = strcmp((doc2 + iList1)->value.intitule.denomination, (doc2 + iList2)->value.intitule.denomination);\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "    else\n" \
  "    {\n" \
  "        iRetour = (int4)iList1 - iList2;\n" \
  "        return (iRetour);\n" \
  "    }\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givCompListParu\n" \
  " *\n" \
  " * But : Comparaison des codes géographiques de parution\n" \
  " *\n" \
  " * Description : comparaison dept/loc/arr de parution\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "static int4 givCompListParu(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "	int4 iRetour = givrListParu.givCompareListe(apList1, apList2);\n" \
  "		if (0 != iRetour)\n" \
  "			return (iRetour);\n" \
  "		else\n" \
  "			return givrListParu.givCompiLFiZU(apList1, apList2);\n" \
  "}\n" \
  "\n" \
  "static int4 givCompListAn9Paru(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iRetour;\n" \
  "    /** pointeur sur le rang du premier code à comparer */\n" \
  "    int4 iList1;\n" \
  "    /** pointeur sur le rang du second code à comparer */\n" \
  "    int4 iList2;\n" \
  "    /** Initialisation des pointeurs */\n" \
  "    iList1 = *(int4*)apList1;\n" \
  "    iList2 = *(int4*)apList2;\n" \
  "    iRetour = strcmp(givrListParu.trEltList[iList1].rub, givrListParu.trEltList[iList2].rub);\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "    else\n" \
  "    {\n" \
  "        iRetour = (int4)givrListParu.trEltList[iList1].iRgLigne - givrListParu.trEltList[iList2].iRgLigne;\n" \
  "        return (iRetour);\n" \
  "    }\n" \
  "}\n" \
  "static int4 givCompListDenomParu(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iRetour;\n" \
  "    /** pointeur sur le rang du premier code à comparer */\n" \
  "    int4 iList1;\n" \
  "    /** pointeur sur le rang du second code à comparer */\n" \
  "    int4 iList2;\n" \
  "    /** Initialisation des pointeurs */\n" \
  "    iList1 = *(int4*)apList1;\n" \
  "    iList2 = *(int4*)apList2;\n" \
  "    iList1 = givrListParu.trEltList[iList1].iRgLigne;\n" \
  "    iList2 = givrListParu.trEltList[iList2].iRgLigne;\n" \
  "    iRetour = strcmp((doc2 + iList1)->value.intitule.denomination, (doc2 + iList2)->value.intitule.denomination);\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "    else\n" \
  "    {\n" \
  "        iRetour = (int4)iList1 - iList2;\n" \
  "        return (iRetour);\n" \
  "    }\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givCompListParuTaille\n" \
  " *\n" \
  " * But : Comparaison des codes géographiques de parution par taille de blocs\n" \
  " *       rub/geo\n" \
  " *\n" \
  " * Description : comparaison dept/loc/arr de parution\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Av/08/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "static int4 givCompListParuTaille(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iRetour;\n" \
  "    /** pointeur sur le rang du premier code à comparer */\n" \
  "    int4 iList1;\n" \
  "    /** pointeur sur le rang du second code à comparer */\n" \
  "    int4 iList2;\n" \
  "    /** Initialisation des pointeurs */\n" \
  "    iList1 = *(int4*)apList1;\n" \
  "    iList2 = *(int4*)apList2;\n" \
  "\n" \
  "    if (((int4) - 1 == (int4)givrListParu.trEltList[iList1].iRgGeoTri) && ((int4) - 1 != (int4)givrListParu.trEltList[iList2].iRgGeoTri))\n" \
  "        return (1);\n" \
  "\n" \
  "    if (((int4) - 1 != (int4)givrListParu.trEltList[iList1].iRgGeoTri) && ((int4) - 1 == (int4)givrListParu.trEltList[iList2].iRgGeoTri))\n" \
  "        return (-1);\n" \
  "\n" \
  "    iRetour = (int4)givrListParu.trEltList[iList1].iNbGeoTri - givrListParu.trEltList[iList2].iNbGeoTri;\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "\n" \
  "    iRetour = (int4)givrListParu.trEltList[iList1].iRgTriDblBis - givrListParu.trEltList[iList2].iRgTriDblBis;\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "\n" \
  "    iRetour = (int4)givrListParu.trEltList[iList1].iRangTri - givrListParu.trEltList[iList2].iRangTri;\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "\n" \
  "    iRetour = (int4)givrListParu.trEltList[iList1].iRgGeoTri - givrListParu.trEltList[iList2].iRgGeoTri;\n" \
  "    return (iRetour);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givCompListInstTaille\n" \
  " *\n" \
  " * But : Comparaison des codes géographiques d'installation par taille de blocs\n" \
  " *       rub/geo\n" \
  " *\n" \
  " * Description : comparaison dept/loc/arr de parution\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Av/08/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "static int4 givCompListInstTaille(const void* apList1, const void* apList2)\n" \
  "{\n" \
  "    /** code retour des fonctions appelées */\n" \
  "    int4 iRetour;\n" \
  "    /** pointeur sur le rang du premier code à comparer */\n" \
  "    int4 iList1;\n" \
  "    /** pointeur sur le rang du second code à comparer */\n" \
  "    int4 iList2;\n" \
  "    /** Initialisation des pointeurs */\n" \
  "    iList1 = *(int4*)apList1;\n" \
  "    iList2 = *(int4*)apList2;\n" \
  "\n" \
  "    if (((int4) - 1 == (int4)givrListInst.trEltList[iList1].iRgGeoTri) && ((int4) - 1 != (int4)givrListInst.trEltList[iList2].iRgGeoTri))\n" \
  "        return (1);\n" \
  "\n" \
  "    if (((int4) - 1 != (int4)givrListInst.trEltList[iList1].iRgGeoTri) && ((int4) - 1 == (int4)givrListInst.trEltList[iList2].iRgGeoTri))\n" \
  "        return (-1);\n" \
  "\n" \
  "    iRetour = (int4)givrListInst.trEltList[iList1].iNbGeoTri - givrListInst.trEltList[iList2].iNbGeoTri;\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "\n" \
  "    iRetour = (int4)givrListInst.trEltList[iList1].iRangTri - givrListInst.trEltList[iList2].iRangTri;\n" \
  "\n" \
  "    if (0 != iRetour)\n" \
  "        return (iRetour);\n" \
  "\n" \
  "    iRetour = (int4)givrListInst.trEltList[iList1].iRgGeoTri - givrListInst.trEltList[iList2].iRgGeoTri;\n" \
  "    return (iRetour);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givInitTriAn9Geo\n" \
  " *\n" \
  " * But : init Tri des codes géographiques\n" \
  " *\n" \
  " * Description : init du rang de rubrique\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givInitTriAn9Geo(void)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    int4 i, j, k, l, m, n;\n" \
  "    int4 iGeo;\n" \
  "    int4 iVal;\n" \
  "    char tcAn9Courant[GYBPaprofLgCodan9 + 1];\n" \
  "    int4 iRangRub, iRgRubDbl, iNbGeoRub, iRgGeoRub, iRangDeb, iNbrRub;\n" \
  "    int4 iNbrParuMax, iNbrInstMax;\n" \
  "    /* trier en fonction des an9 */\n" \
  "    qsort(givrListParu.trEltRangList, givrListParu.iNbr, sizeof(int4), givCompListAn9Paru);\n" \
  "    qsort(givrListInst.trEltRangList, givrListInst.iNbr, sizeof(int4), givCompListAn9Inst);\n" \
  "    iNbrInstMax = givrListInst.iNbr;\n" \
  "    iNbrParuMax = givrListParu.iNbr;\n" \
  "    strcpy(tcAn9Courant, givcR00000000);\n" \
  "    iRangRub = -1;\n" \
  "\n" \
  "    /* analyse paru par rubrique */\n" \
  "    for (i = 0; i < iNbrParuMax; i++)\n" \
  "    {\n" \
  "        k = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "        if ((0 != strcmp(tcAn9Courant, givrListParu.trEltList[k].rub)) || (0 == i))\n" \
  "        {\n" \
  "            strcpy(tcAn9Courant, givrListParu.trEltList[k].rub);\n" \
  "            iRangRub++;\n" \
  "\n" \
  "            /* init arr si LF */\n" \
  "            for (m = 0; m < 3; m++)\n" \
  "                givtrRefArr[m + 3].nbarr = givtrRefArr[m].nbarr;\n" \
  "\n" \
  "            /* Init d'une installation par défaut */\n" \
  "            for (j = 0; j < iNbrInstMax; j++)\n" \
  "            {\n" \
  "                l = givrListInst.trEltRangList[j];\n" \
  "\n" \
  "                if (0 == strcmp(givrListInst.trEltList[l].rub, givrListParu.trEltList[k].rub))\n" \
  "                    break;\n" \
  "            }\n" \
  "\n" \
  "            if ((iNbrInstMax == j) && (MAX_LIST != givrListInst.iNbr))\n" \
  "            {\n" \
  "                /* ajout défaut */\n" \
  "                iGeo = givrListInst.iNbr;\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].rubinit, givrListParu.trEltList[k].rubinit);\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].dep, \"999\");\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].loc, \"99999\");\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].arr, \"99\");\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].reg, \"99\");\n" \
  "                givrListInst.trEltList[iGeo].iRgLigne = (int4)GIV::GIXCodeKO;\n" \
  "                givrListInst.trEltList[iGeo].iGeo = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoReg = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoDept = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoArr = 99;\n" \
  "                givrListInst.trEltRangList[iGeo] = iGeo;\n" \
  "                givrListInst.iNbr++;\n" \
  "            }\n" \
  "            else if (iNbrInstMax == j)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        givrListParu.trEltList[k].iRangTri = iRangRub;\n" \
  "\n" \
  "        /* analyse localité fictive par rubrique */\n" \
  "        if (0 == strcmp(givrListParu.trEltList[k].loc, givcLocFictive))\n" \
  "        {\n" \
  "            for (m = 0; m < 6; m++)\n" \
  "            {\n" \
  "                /* parution LF avec arrondissement */\n" \
  "                if ((0 == strcmp(givtrRefArr[m].dep, givrListParu.trEltList[k].dep)) && (0 == strcmp(givtrRefArr[m].loc, givrListParu.trEltList[k].loc)))\n" \
  "                    break;\n" \
  "            }\n" \
  "\n" \
  "            if (6 != m)\n" \
  "            {\n" \
  "                for (j = 1; j < (givtrRefArr[m].nbarr + 1); j++)\n" \
  "                {\n" \
  "                    iGeo = givrListParu.iNbr;\n" \
  "\n" \
  "                    if (MAX_LIST == iGeo)\n" \
  "                    {\n" \
  "                        /* Trop d'entrées internes */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    /* givrListParu.trEltList[iGeo].iRgLigne = (int4)GIV::GIXCodeKO; */\n" \
  "                    givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne;\n" \
  "                    givrListParu.trEltList[iGeo].iRgDnom = givrListParu.trEltList[k].iRgDnom;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].tcRgDnom, givrListParu.trEltList[k].tcRgDnom);\n" \
  "                    givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;\n" \
  "                    givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "\n" \
  "                    if (0 != strcmp(\"075\", givrListParu.trEltList[k].dep))\n" \
  "                        givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                    else\n" \
  "                        givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rubinit, givrListParu.trEltList[k].rubinit);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].nature, givrListParu.trEltList[k].nature);\n" \
  "                    givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].dep, givrListParu.trEltList[k].dep);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].loc, givtrRefArr[m - 3].loc);\n" \
  "                    iVal = j;\n" \
  "\n" \
  "                    for (l = 1; l >= 0; l--)\n" \
  "                    {\n" \
  "                        givrListParu.trEltList[iGeo].arr[l] = (char)((iVal % 10) + '0');\n" \
  "                        iVal = iVal / 10;\n" \
  "                    }\n" \
  "\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].reg, givtrRefArr[m - 3].reg);\n" \
  "                    givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[iGeo].cParuloc = givrListParu.trEltList[k].cParuloc;\n" \
  "                    givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "                    givrListParu.iNbr++;\n" \
  "                }\n" \
  "\n" \
  "                /* LF a ne plus traiter */\n" \
  "                givtrRefArr[m].nbarr = 0;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* nombre de rubriques */\n" \
  "    givrListParu.iNbrTri = iRangRub + 1;\n" \
  "    strcpy(tcAn9Courant, givcR00000000);\n" \
  "    iRangRub = -1;\n" \
  "\n" \
  "    /* analyse inst par rubrique */\n" \
  "    for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "    {\n" \
  "        k = givrListInst.trEltRangList[i];\n" \
  "\n" \
  "        if ((0 != strcmp(tcAn9Courant, givrListInst.trEltList[k].rub)) || (0 == i))\n" \
  "        {\n" \
  "            iRangRub++;\n" \
  "            strcpy(tcAn9Courant, givrListInst.trEltList[k].rub);\n" \
  "        }\n" \
  "\n" \
  "        givrListInst.trEltList[k].iRangTri = iRangRub;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givInitTriDenomGeo\n" \
  " *\n" \
  " * But : init Tri des codes géographiques\n" \
  " *\n" \
  " * Description : init du rang de denomination\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givInitTriDenomGeo(int4 iTri)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    int4 i, ii, j, k, kk, ll, l, m, n;\n" \
  "    int4 iGeo;\n" \
  "    int4 iVal;\n" \
  "    GYBstrIeinscDenomT rDenom;\n" \
  "    int4 iRang;\n" \
  "    int4 iNbrParuMax, iNbrInstMax;\n" \
  "\n" \
  "    if (GIV::giv_DNOM != iTri)\n" \
  "    {\n" \
  "        /* analyse paru par dénomination */\n" \
  "        for (i = 0; i < givrListParu.iNbr; i++)\n" \
  "        {\n" \
  "            k = givrListParu.trEltRangList[i];\n" \
  "            kk = givrListParu.trEltList[k].iRgLigne;\n" \
  "            givrListParu.trEltList[k].iRgDnom = (doc2 + kk)->value.intitule.iRgDnom;\n" \
  "            (void)strcpy(givrListParu.trEltList[k].tcRgDnom, (doc2 + kk)->value.intitule.tcRgDnom);\n" \
  "        }\n" \
  "\n" \
  "        /* analyse inst par dénomination */\n" \
  "        for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "        {\n" \
  "            k = givrListInst.trEltRangList[i];\n" \
  "            kk = givrListInst.trEltList[k].iRgLigne;\n" \
  "            givrListInst.trEltList[k].iRgDnom = (doc2 + kk)->value.intitule.iRgDnom;\n" \
  "            (void)strcpy(givrListInst.trEltList[k].tcRgDnom, (doc2 + kk)->value.intitule.tcRgDnom);\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        iRang = -1;\n" \
  "\n" \
  "        /* analyse paru par dénomination */\n" \
  "        for (i = 0; i < givrListParu.iNbr; i++)\n" \
  "        {\n" \
  "            k = givrListParu.trEltRangList[i];\n" \
  "            givrListParu.trEltList[k].iRangTri = givrListParu.trEltList[k].iRgDnom;\n" \
  "\n" \
  "            if (givrListParu.trEltList[k].iRangTri > iRang)\n" \
  "                iRang = givrListParu.trEltList[k].iRangTri;\n" \
  "        }\n" \
  "\n" \
  "        /* nombre de denominations */\n" \
  "        givrListParu.iNbrTri = iRang + 1;\n" \
  "        iRang = -1;\n" \
  "\n" \
  "        /* analyse inst par dénomination */\n" \
  "        for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "        {\n" \
  "            k = givrListInst.trEltRangList[i];\n" \
  "            givrListInst.trEltList[k].iRangTri = givrListInst.trEltList[k].iRgDnom;\n" \
  "\n" \
  "            if (givrListInst.trEltList[k].iRangTri > iRang)\n" \
  "                iRang = givrListInst.trEltList[k].iRangTri;\n" \
  "        }\n" \
  "\n" \
  "        /* nombre de denominations */\n" \
  "        givrListInst.iNbrTri = iRang + 1;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "    /* trier en fonction des dénominations */\n" \
  "    qsort(givrListParu.trEltRangList, givrListParu.iNbr, sizeof(int4), givCompListDenomParu);\n" \
  "    qsort(givrListInst.trEltRangList, givrListInst.iNbr, sizeof(int4), givCompListDenomInst);\n" \
  "    iNbrInstMax = givrListInst.iNbr;\n" \
  "    iNbrParuMax = givrListParu.iNbr;\n" \
  "    strcpy(rDenom, \"      \");\n" \
  "    iRang = -1;\n" \
  "\n" \
  "    /* analyse paru par dénomination */\n" \
  "    for (i = 0; i < iNbrParuMax; i++)\n" \
  "    {\n" \
  "        k = givrListParu.trEltRangList[i];\n" \
  "        kk = givrListParu.trEltList[k].iRgLigne;\n" \
  "\n" \
  "        if ((0 != strcmp(rDenom, (doc2 + kk)->value.intitule.denomination)) || (0 == i))\n" \
  "        {\n" \
  "            strcpy(rDenom, (doc2 + kk)->value.intitule.denomination);\n" \
  "            iRang++;\n" \
  "\n" \
  "            /* init arr si LF */\n" \
  "            for (m = 0; m < 3; m++)\n" \
  "                givtrRefArr[m + 3].nbarr = givtrRefArr[m].nbarr;\n" \
  "\n" \
  "            /* Init d'une installation par défaut */\n" \
  "            for (j = 0; j < iNbrInstMax; j++)\n" \
  "            {\n" \
  "                l = givrListInst.trEltRangList[j];\n" \
  "                ll = givrListInst.trEltList[l].iRgLigne;\n" \
  "\n" \
  "                if (0 == strcmp((doc2 + ll)->value.intitule.denomination, (doc2 + kk)->value.intitule.denomination))\n" \
  "                    break;\n" \
  "            }\n" \
  "\n" \
  "            if ((iNbrInstMax == j) && (MAX_LIST == givrListInst.iNbr))\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "            }\n" \
  "            else if (iNbrInstMax == j)\n" \
  "            {\n" \
  "                /* ajout défaut */\n" \
  "                iGeo = givrListInst.iNbr;\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].rubinit, givrListParu.trEltList[k].rubinit);\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].dep, \"999\");\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].loc, \"99999\");\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].arr, \"99\");\n" \
  "                (void)strcpy(givrListInst.trEltList[iGeo].reg, \"99\");\n" \
  "                givrListInst.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne;\n" \
  "                givrListInst.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;\n" \
  "                givrListInst.trEltList[iGeo].iGeo = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoReg = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoDept = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                givrListInst.trEltList[iGeo].iGeoArr = 99;\n" \
  "                givrListInst.trEltRangList[iGeo] = iGeo;\n" \
  "                givrListInst.iNbr++;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        givrListParu.trEltList[k].iRangTri = iRang;\n" \
  "\n" \
  "        /* analyse localité fictive par dénomination */\n" \
  "        if (0 == strcmp(givrListParu.trEltList[k].loc, givcLocFictive))\n" \
  "        {\n" \
  "            for (m = 0; m < 6; m++)\n" \
  "            {\n" \
  "                /* parution LF avec arrondissement */\n" \
  "                if ((0 == strcmp(givtrRefArr[m].dep, givrListParu.trEltList[k].dep)) && (0 == strcmp(givtrRefArr[m].loc, givrListParu.trEltList[k].loc)))\n" \
  "                    break;\n" \
  "            }\n" \
  "\n" \
  "            if (6 != m)\n" \
  "            {\n" \
  "                for (j = 1; j < (givtrRefArr[m].nbarr + 1); j++)\n" \
  "                {\n" \
  "                    iGeo = givrListParu.iNbr;\n" \
  "\n" \
  "                    if (MAX_LIST == iGeo)\n" \
  "                    {\n" \
  "                        /* Trop d'entrées internes */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    givrListParu.trEltList[iGeo].iRgLigne = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne;\n" \
  "                    givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;\n" \
  "                    givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "\n" \
  "                    if (0 != strcmp(\"075\", givrListParu.trEltList[k].dep))\n" \
  "                        givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                    else\n" \
  "                        givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rubinit, givrListParu.trEltList[k].rubinit);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].nature, givrListParu.trEltList[k].nature);\n" \
  "                    givrListParu.trEltList[iGeo].iRangTri = givrListParu.trEltList[k].iRangTri;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].dep, givrListParu.trEltList[k].dep);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].loc, givtrRefArr[m - 3].loc);\n" \
  "                    iVal = j;\n" \
  "\n" \
  "                    for (l = 1; l >= 0; l--)\n" \
  "                    {\n" \
  "                        givrListParu.trEltList[iGeo].arr[l] = (char)((iVal % 10) + '0');\n" \
  "                        iVal = iVal / 10;\n" \
  "                    }\n" \
  "\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].reg, givtrRefArr[m - 3].reg);\n" \
  "                    givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[iGeo].cParuloc = givrListParu.trEltList[k].cParuloc;\n" \
  "                    givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "                    givrListParu.iNbr++;\n" \
  "                }\n" \
  "\n" \
  "                /* LF a ne plus traiter */\n" \
  "                givtrRefArr[m].nbarr = 0;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* nombre de denominations */\n" \
  "    givrListParu.iNbrTri = iRang + 1;\n" \
  "    strcpy(rDenom, \"      \");\n" \
  "    iRang = -1;\n" \
  "\n" \
  "    /* analyse inst par dénomination */\n" \
  "    for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "    {\n" \
  "        k = givrListInst.trEltRangList[i];\n" \
  "        kk = givrListInst.trEltList[k].iRgLigne;\n" \
  "\n" \
  "        if ((0 != strcmp(rDenom, (doc2 + kk)->value.intitule.denomination)) || (0 == i))\n" \
  "        {\n" \
  "            iRang++;\n" \
  "            strcpy(rDenom, (doc2 + kk)->value.intitule.denomination);\n" \
  "        }\n" \
  "\n" \
  "        givrListInst.trEltList[k].iRangTri = iRang;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givInitTriObjRec\n" \
  " *\n" \
  " * But : Tri des objets publicitaires réconciliés\n" \
  " *\n" \
  " * Description : init du rang d'objet\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Sep/26/2017  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givInitTriObjRec(GYBrDOCUMENTEpj* doc, int4 indice, int4 iTri)\n" \
  "{\n" \
  "    int4 iCodRet;     /* Code retour de la fonction */\n" \
  "    int4 iIntRet;     /* Code retour interne */\n" \
  "    int4 i, jj, j, k, kk, l, m;\n" \
  "    char          indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL begin declare section;\n" \
  "        GYBrIaprofT rIaprof;\n" \
  "    EXEC SQL end declare section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == givrListObj.iNbr)\n" \
  "    {\n" \
  "        /* pas d'objet publicitaire */\n" \
  "        if (GIV::giv_OBJ == iTri)\n" \
  "            givrListParu.iNbrTri = 0;\n" \
  "\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        if ('1' != (doc + i)->cIndRecGpp || '2' != (doc + i)->cTypRecGpp)\n" \
  "        {\n" \
  "            /* pas de réconciliation GPP */\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureLiensProfPub\");\n" \
  "        rIaprof.copyNumNatLoLs((doc + i)->value.inscription[0].val_num, (doc + i)->value.inscription[0].val_lo, (doc + i)->value.inscription[0].val_ls);\n" \
  "        EXEC SQL\n" \
  "        OPEN crsLectureLiensProfPub\n" \
  "        using :rIaprof.acNumnat,\n" \
  "              :rIaprof.acNumlo,\n" \
  "              :rIaprof.acNumls;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsLectureLiensProfPub: [COD=%d TXT=%s] -%s-\\n\", iIntRet, vErreurSQL.acDonnees_retour, rIaprof.acNumnat));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "            indFinFetch = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "            while ((int4)GIV::GIXCodeOK == indFinFetch)\n" \
  "            {\n" \
  "                EXEC SQL\n" \
  "                FETCH crsLectureLiensProfPub\n" \
  "                INTO\n" \
  "                :rIaprof.acNumnat,\n" \
  "                :rIaprof.acNumlo,\n" \
  "                :rIaprof.acNumls,\n" \
  "                :rIaprof.acCodan8;\n" \
  "                iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "                if ((int4)GIV::GYBok == iIntRet)\n" \
  "                {\n" \
  "                    /* analyse paru par objet */\n" \
  "                    for (k = 0; k < indice; k++)\n" \
  "                    {\n" \
  "                        if (0 == strcmp(rIaprof.acNumnat, (doc + k)->value.inscription[0].val_num) &&\n" \
  "                                0 == strcmp(rIaprof.acNumlo, (doc + k)->value.inscription[0].val_lo) &&\n" \
  "                                0 == strcmp(rIaprof.acNumls, (doc + k)->value.inscription[0].val_ls))\n" \
  "                            break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (indice == k)\n" \
  "                        continue;\n" \
  "\n" \
  "                    if (MAX_LIST == givrListObj.iNbr)\n" \
  "                    {\n" \
  "                        /* Trop d'entrées internes */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                        indFinFetch = (int4)GIV::GIXCodeKO;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Lien de réconcilication : %d,%s,%s,%s,%d,%s,%s,%s\\n\", i, (doc + i)->value.inscription[0].val_num, (doc + i)->value.inscription[0].val_lo,\n" \
  "                                             (doc + i)->value.inscription[0].val_ls, k, rIaprof.acNumnat, rIaprof.acNumlo, rIaprof.acNumls));\n" \
  "\n" \
  "                    for (j = 0; j < givrListObj.iNbr; j++)\n" \
  "                    {\n" \
  "                        jj = givrListObj.trEltRangListObj[j];\n" \
  "\n" \
  "                        /* Lien Objet-Document par Ligne et par rubrique */\n" \
  "                        if (k == givrListObj.trEltListObj[jj].iRgLigne)\n" \
  "                        {\n" \
  "                            /* ajout objet suivant pour une ligne */\n" \
  "                            givrListObj.trEltListObj[givrListObj.iNbr].iRgLigne = i;\n" \
  "                            givrListObj.trEltListObj[givrListObj.iNbr].iRgObj = (doc + i)->value.objets_pub.nb_micro;\n" \
  "                            givrListObj.trEltListObj[givrListObj.iNbr].iRgLgnRec = k;\n" \
  "                            givrListObj.trEltRangListObj[givrListObj.iNbr] = givrListObj.iNbr;\n" \
  "                            givrListObj.iNbr++;\n" \
  "                            (doc + i)->value.objets_pub.micro[(doc + i)->value.objets_pub.nb_micro] =\n" \
  "                                (doc + k)->value.objets_pub.micro[givrListObj.trEltListObj[jj].iRgObj];\n" \
  "                            (doc + i)->value.objets_pub.nb_micro++;\n" \
  "                        }\n" \
  "                    }\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    /* fin de boucle */\n" \
  "                    indFinFetch = (int4)GIV::GIXCodeKO;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            EXEC SQL\n" \
  "            close crsLectureLiensProfPub;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureLiensProfPub: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givInitTriObjGeo\n" \
  " *\n" \
  " * But : Tri des objets publiciatires\n" \
  " *\n" \
  " * Description : init du rang d'objet\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givInitTriObj(GYBrDOCUMENTEpj* doc, int4 indice, int4 iTri)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    int4 i, ii, j, k, kk, l, m;\n" \
  "    int4 iObj, iCVI;\n" \
  "    int4 iRang, iOrd, iRgLigne, iRgObj;\n" \
  "    GYBrIamicT rIamic;\n" \
  "    char tcType[3]; /* type */\n" \
  "    /* analyse objet par ligne */\n" \
  "    iCVI = -1;\n" \
  "    givrListObj.iNbr = 0;\n" \
  "\n" \
  "    /* analyse des CVIV */\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        for (j = 0; j < (doc + i)->value.objets_pub.nb_micro; j++)\n" \
  "        {\n" \
  "            strcpy(tcType, (doc + i)->value.objets_pub.micro[j].stype);\n" \
  "\n" \
  "            for (k = 0; (k < givNbFixeCVI && 0 != strcmp(givTabCVI[k], tcType)); k++)\n" \
  "                ;\n" \
  "\n" \
  "            if (givNbFixeCVI != k)\n" \
  "            {\n" \
  "                iCVI = k;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((doc + i)->value.objets_pub.nb_micro != j)\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        for (j = 0; j < (doc + i)->value.objets_pub.nb_micro; j++)\n" \
  "        {\n" \
  "            iObj = givrListObj.iNbr;\n" \
  "\n" \
  "            if (MAX_LIST == iObj)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            if ((0 == strcmp(\"RM\", (doc + i)->value.objets_pub.micro[j].stype)) && ((-1 == iCVI) || ((0 != strcmp(\"001\", (doc + i)->value.inscription[0].val_seqLS))\n" \
  "                    && (0 != strlen((doc + i)->value.inscription[0].val_seqLS)))))\n" \
  "            {\n" \
  "                /* pas de RM (Ranking Mappy) si CVIV inactif */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Objet RM avec CVIV absent : %s\\n\", (doc + i)->value.objets_pub.micro[j].id));\n" \
  "                continue;\n" \
  "            }\n" \
  "\n" \
  "            givrListObj.trEltRangListObj[iObj] = iObj;\n" \
  "            givrListObj.trEltListObj[iObj].iRgLigne = i;\n" \
  "            givrListObj.trEltListObj[iObj].iRgObj = j;\n" \
  "            givrListObj.trEltListObj[iObj].iRgLgnRec = -1;\n" \
  "            givrListObj.iNbr++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* description des objets réconciliés au niveau global du bloc epj */\n" \
  "    iIntRet = givInitTriObjRec(doc, indice, GIV::giv_RUB);\n" \
  "\n" \
  "    if (0 != givrListObj.iNbr)\n" \
  "    {\n" \
  "        /* existence d'objet publicitaire */\n" \
  "        /* trier en fonction des objets */\n" \
  "        qsort(givrListObj.trEltRangListObj, givrListObj.iNbr, sizeof(int4), givCompListObj);\n" \
  "        /* analyse liste par objet */\n" \
  "        iRang = -1;\n" \
  "        iOrd = 0;\n" \
  "\n" \
  "        for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "        {\n" \
  "            k = givrListObj.trEltRangListObj[i];\n" \
  "            kk = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "            iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "            if ((0 != strcmp(rIamic.acTypobj, (doc + kk)->value.objets_pub.micro[iObj].type)) || (0 == i) || (0 != strcmp(rIamic.acTpdsob, (doc + kk)->value.objets_pub.micro[iObj].stype))\n" \
  "                    || (0 != strcmp(rIamic.acNumobj, (doc + kk)->value.objets_pub.micro[iObj].id)))\n" \
  "            {\n" \
  "                iRang++;\n" \
  "                iOrd = 0;\n" \
  "                rIamic.initObjet(doc, kk, iObj);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" Tri objet 1 : ... %d,%d\\n\", iRang, iOrd));\n" \
  "            }\n" \
  "            else if ((0 == strcmp(rIamic.acTypobj, (doc + kk)->value.objets_pub.micro[iObj].type)) && (0 == strcmp(rIamic.acTpdsob, (doc + kk)->value.objets_pub.micro[iObj].stype))\n" \
  "                     && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"VI\")) && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"FI\"))\n" \
  "                     && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"IN\")) && (0 != strcmp(rIamic.acStobj, (doc + kk)->value.objets_pub.micro[iObj].sstype))\n" \
  "                     && (0 == strcmp(rIamic.acNumobj, (doc + kk)->value.objets_pub.micro[iObj].id)))\n" \
  "            {\n" \
  "                iRang++;\n" \
  "                iOrd = 0;\n" \
  "                rIamic.initObjet(doc, kk, iObj);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" Tri objet 2 : ... %d,%d\\n\", iRang, iOrd));\n" \
  "            }\n" \
  "            else if ((0 == strcmp(rIamic.acTypobj, (doc + kk)->value.objets_pub.micro[iObj].type)) && (0 == strcmp(rIamic.acTpdsob, (doc + kk)->value.objets_pub.micro[iObj].stype))\n" \
  "                     && ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"VI\")) || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"FI\"))\n" \
  "                         || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"IN\"))) && (0 != strcmp(rIamic.acStobj, (doc + kk)->value.objets_pub.micro[iObj].sstype))\n" \
  "                     && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"VS\")) && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"VF\"))\n" \
  "                     && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"VE\")) && (0 == strcmp(rIamic.acNumobj, (doc + kk)->value.objets_pub.micro[iObj].id)))\n" \
  "            {\n" \
  "                iRang++;\n" \
  "                iOrd = 0;\n" \
  "                rIamic.initObjet(doc, kk, iObj);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" Tri objet 3 : ... %d,%d\\n\", iRang, iOrd));\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                iOrd++;\n" \
  "                rIamic.initObjet(doc, kk, iObj);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" Tri objet 4 : ... %d,%d\\n\", iRang, iOrd));\n" \
  "            }\n" \
  "\n" \
  "            givrListObj.trEltListObj[k].iRangTri = iRang;\n" \
  "            givrListObj.trEltListObj[k].iOrdTri = iOrd;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" Tri objet : ... %d,%d,%d,%d,%d,%d,%s,%s,%s,%s\\n\", i, k, iRang, iOrd, kk, iObj, (doc + kk)->value.objets_pub.micro[iObj].type, (doc + kk)->value.objets_pub.micro[iObj].stype,\n" \
  "                                     (doc + kk)->value.objets_pub.micro[iObj].sstype, (doc + kk)->value.objets_pub.micro[iObj].id));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" Tri objet ref : ... %d,%d,%d,%d,%d,%d,%s,%s,%s,%s\\n\", i, k, iRang, iOrd, kk, iObj, rIamic.acTypobj, rIamic.acTpdsob, rIamic.acStobj, rIamic.acNumobj));\n" \
  "        }\n" \
  "\n" \
  "        iRang++;\n" \
  "        givrListObj.iNbrTri = iRang;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" No_objets : ... %d,%d\\n\", givrListObj.iNbrTri, givrListObj.iNbr));\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "int4 givInitTriObjGeo(GYBrDOCUMENTEpj* doc, int4 indice, int4 iTri)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    int4 i, ii, j, k, kk, l, m;\n" \
  "    int4 iObj, iCVI;\n" \
  "    int4 iRang, iOrd, iRgLigne, iRgObj;\n" \
  "    GYBrIamicT rIamic;\n" \
  "    char tcType[3]; /* type */\n" \
  "    char* buf_pos;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == givrListObj.iNbr)\n" \
  "    {\n" \
  "        /* pas d'objet publicitaire */\n" \
  "        if (GIV::giv_OBJ == iTri)\n" \
  "            givrListParu.iNbrTri = 0;\n" \
  "\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* init rangs Paru et Inst à -1 */\n" \
  "    for (i = 0; i < givrListParu.iNbr; i++)\n" \
  "    {\n" \
  "        givrListParu.trEltList[i].iRangTri = -1;\n" \
  "        givrListParu.trEltList[i].iRgObj = -1;\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "    {\n" \
  "        givrListInst.trEltList[i].iRangTri = -1;\n" \
  "        givrListInst.trEltList[i].iRgObj = -1;\n" \
  "    }\n" \
  "\n" \
  "    givrListParu.iNbrTri = 0;\n" \
  "    l = 0;\n" \
  "\n" \
  "    while (l < givrListObj.iNbr)\n" \
  "    {\n" \
  "        k = givrListObj.trEltRangListObj[l];\n" \
  "        iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "\n" \
  "        for (m = l; m < givrListObj.iNbr; m++)\n" \
  "        {\n" \
  "            kk = givrListObj.trEltRangListObj[m];\n" \
  "\n" \
  "            if (iRang != givrListObj.trEltListObj[kk].iRangTri)\n" \
  "                break;\n" \
  "\n" \
  "            /* analyse paru par objet */\n" \
  "            for (i = 0; i < givrListParu.iNbr; i++)\n" \
  "            {\n" \
  "                ii = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                /* Lien Objet-Document par Ligne */\n" \
  "                if (givrListObj.trEltListObj[kk].iRgLigne == givrListParu.trEltList[ii].iRgLigne)\n" \
  "                {\n" \
  "                    if ((-1 == givrListParu.trEltList[ii].iRangTri) && (GIV::giv_OBJ == iTri))\n" \
  "                    {\n" \
  "                        /* premier objet pour une ligne */\n" \
  "                        givrListParu.trEltList[ii].iRangTri = iRang;\n" \
  "                        givrListParu.trEltList[ii].iRgObj = givrListObj.trEltListObj[kk].iRgObj;\n" \
  "                    }\n" \
  "                    else if (GIV::giv_OBJ == iTri)\n" \
  "                    {\n" \
  "                        if (MAX_LIST == givrListParu.iNbrTot)\n" \
  "                        {\n" \
  "                            /* Trop d'entrées internes */\n" \
  "                            GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne Paru dépassée: %s,%d,%d\\n\", doc->value.a_classer.etab, givrListObj.iNbr, givrListObj.iNbrTri));\n" \
  "                            break;\n" \
  "                        }\n" \
  "\n" \
  "                        /* ajout objet suivant pour une ligne */\n" \
  "                        givrListParu.trEltList[givrListParu.iNbrTot] = givrListParu.trEltList[ii];\n" \
  "                        givrListParu.trEltList[givrListParu.iNbrTot].iRangTri = iRang;\n" \
  "                        givrListParu.trEltList[givrListParu.iNbrTot].iRgObj = givrListObj.trEltListObj[kk].iRgObj;\n" \
  "                        givrListParu.trEltList[givrListParu.iNbrTot].iRgDnom = -1;\n" \
  "                        givrListParu.trEltRangList[givrListParu.iNbrTot] = givrListParu.iNbrTot;\n" \
  "                        givrListParu.iNbrTot++;\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        /* Rang de tri d'objet dans document d'une ligne */\n" \
  "                        iRgLigne = givrListObj.trEltListObj[kk].iRgLigne;\n" \
  "                        iRgObj = givrListObj.trEltListObj[kk].iRgObj;\n" \
  "                        (doc + iRgLigne)->value.objets_pub.micro[iRgObj].iRgObj = iRang;\n" \
  "                        sprintf((doc + iRgLigne)->value.objets_pub.micro[iRgObj].tcRgObj, \"%04d\", iRang);\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* analyse inst par objet */\n" \
  "            for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "            {\n" \
  "                ii = givrListInst.trEltRangList[i];\n" \
  "\n" \
  "                if (givrListObj.trEltListObj[kk].iRgLigne == givrListInst.trEltList[ii].iRgLigne)\n" \
  "                {\n" \
  "                    if ((-1 == givrListInst.trEltList[ii].iRangTri) && (GIV::giv_OBJ == iTri))\n" \
  "                    {\n" \
  "                        /* premier objet pour une ligne */\n" \
  "                        givrListInst.trEltList[ii].iRangTri = iRang;\n" \
  "                        givrListInst.trEltList[ii].iRgObj = givrListObj.trEltListObj[kk].iRgObj;\n" \
  "                    }\n" \
  "                    else if (GIV::giv_OBJ == iTri)\n" \
  "                    {\n" \
  "                        if (MAX_LIST == givrListInst.iNbrTot)\n" \
  "                        {\n" \
  "                            /* Trop d'entrées internes */\n" \
  "                            GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne Inst dépassée: %s,%d,%d\\n\", doc->value.a_classer.etab, givrListObj.iNbr, givrListObj.iNbrTri));\n" \
  "                            break;\n" \
  "                        }\n" \
  "\n" \
  "                        /* ajout objet suivant pour une ligne */\n" \
  "                        givrListInst.trEltList[givrListInst.iNbrTot] = givrListInst.trEltList[ii];\n" \
  "                        givrListInst.trEltList[givrListInst.iNbrTot].iRangTri = iRang;\n" \
  "                        givrListInst.trEltList[givrListInst.iNbrTot].iRgObj = givrListObj.trEltListObj[kk].iRgObj;\n" \
  "                        givrListInst.trEltRangList[givrListInst.iNbrTot] = givrListInst.iNbrTot;\n" \
  "                        givrListInst.iNbrTot++;\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        /* nombre d'objets */\n" \
  "        if (GIV::giv_OBJ == iTri)\n" \
  "        {\n" \
  "            if (MAX_LIST == givrListParu.iNbrTot)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "            }\n" \
  "            else\n" \
  "                givrListParu.iNbrTri++;\n" \
  "        }\n" \
  "\n" \
  "        l = m;\n" \
  "    }\n" \
  "\n" \
  "    givrListParu.iNbr = givrListParu.iNbrTot;\n" \
  "    givrListInst.iNbr = givrListInst.iNbrTot;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givTriZU\n" \
  " *\n" \
  " * But : Tri des codes géographiques sur ZU\n" \
  " *\n" \
  " * Description :\n" \
  " * Fonction de tri des réponses en fonction d'un critère qui précise l'ordre\n" \
  " * de priorité des tris\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jun/14/2013  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givTriZU(void)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    char tcDeplocarr[GYBIeinscLgDeppar + GYBIeinscLgLocpar + GYBIeinscLgArrond + 1];\n" \
  "    int4 iRgLigne, iRefLigne, iLF, iGeo;\n" \
  "    int4 i, j, k, l;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iGeo = givrListParu.iNbr;\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (0 == strcmp(givrListParu.trEltList[i].loc, givcLocFictive))\n" \
  "        {\n" \
  "            for (l = 0; l < j; l++)\n" \
  "            {\n" \
  "                k = givrListParu.trEltRangList[l];\n" \
  "\n" \
  "                if ((0 == strcmp(givrListParu.trEltList[k].loc, givcLocFictive)) && (0 == strcmp(givrListParu.trEltList[i].dep, givrListParu.trEltList[k].dep)))\n" \
  "                {\n" \
  "                    /* dep LF déjà traité */\n" \
  "                    break;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((0 == strcmp(givrListParu.trEltList[i].loc, givcLocFictive)) && (l == j))\n" \
  "        {\n" \
  "            iRgLigne = -1;\n" \
  "            iRefLigne = givrListParu.trEltList[i].iRgLigne;\n" \
  "            strcpy(tcDeplocarr, givrListParu.trEltList[i].dep);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ZU LF [%d],[%d],[%s],[%s]\\n\", givrListParu.trEltList[i].iRgLigne, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc));\n" \
  "\n" \
  "            for (l = 0; l < (givrListParu.iNbr); l++)\n" \
  "            {\n" \
  "                k = givrListParu.trEltRangList[l];\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"ZU LF Ins [%d],[%d],[%d],[%d],[%d],[%s],[%s]\\n\", iRefLigne, iRgLigne, iLF, givrListParu.trEltList[k].iRgLigne, givrListParu.trEltList[k].iZU, givrListParu.trEltList[k].dep,\n" \
  "                                         givrListParu.trEltList[k].loc));\n" \
  "\n" \
  "                if (iRefLigne == givrListParu.trEltList[k].iRgLigne)\n" \
  "                    continue;\n" \
  "                else if (iRgLigne != givrListParu.trEltList[k].iRgLigne)\n" \
  "                {\n" \
  "                    /* changement de ligne */\n" \
  "                    iRgLigne = givrListParu.trEltList[k].iRgLigne;\n" \
  "                    iLF = GIV::GIXCodeKO;\n" \
  "\n" \
  "                    if (0 == strcmp(givrListParu.trEltList[k].loc, givcLocFictive))\n" \
  "                    {\n" \
  "                        /* localité fictive à ne pas traiter */\n" \
  "                        iLF = GIV::GIXCodeOK;\n" \
  "                    }\n" \
  "                }\n" \
  "                else if (GIV::GIXCodeOK == iLF)\n" \
  "                {\n" \
  "                    /* même ligne avec LF ne pas traiter */\n" \
  "                }\n" \
  "                else if (((int4)GIV::GIXCodeOK == givrListParu.trEltList[k].iZU) && (0 == strcmp(tcDeplocarr, givrListParu.trEltList[k].dep)))\n" \
  "                {\n" \
  "                    /* même ligne avec ZU et dep de LF */\n" \
  "                    /* implicitement parution sur le pôle */\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Ajout ZU LF Ins [%d],[%d]\\n\", iGeo, MAX_LIST));\n" \
  "\n" \
  "                    if (MAX_LIST == iGeo)\n" \
  "                    {\n" \
  "                        /* Trop d'entrées internes */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rub, givrListParu.trEltList[k].rub);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rubinit, givrListParu.trEltList[k].rubinit);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].nature, givrListParu.trEltList[k].nature);\n" \
  "                    givrListParu.trEltList[iGeo].orig = givrListParu.trEltList[k].orig;\n" \
  "                    givrListParu.trEltList[iGeo].cParuloc = givrListParu.trEltList[k].cParuloc;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].dep, givrListParu.trEltList[k].dep);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].loc, givrListParu.trEltList[k].loc);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].arr, \"00\");\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].reg, givrListParu.trEltList[k].reg);\n" \
  "                    givrListParu.trEltList[iGeo].iDbl = -1;\n" \
  "                    givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[k].iRgLigne;\n" \
  "                    givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "                    iGeo++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    givrListParu.iNbr = iGeo;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givTriGeo\n" \
  " *\n" \
  " * But : Tri des codes géographiques\n" \
  " *\n" \
  " * Description :\n" \
  " * Fonction de tri des réponses en fonction d'un critère qui précise l'ordre\n" \
  " * de priorité des tris\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givTriGeo(GYBrDOCUMENTEpj* doc, int4 indice, int4 iTri)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    int4 iFinInst;\n" \
  "    int4 iFinParu;\n" \
  "    int4 iDblRegInst;\n" \
  "    int4 iDblDeptInst;\n" \
  "    int4 iDblLocInst;\n" \
  "    int4 iDblArrInst;\n" \
  "    int4 iDblRegParu;\n" \
  "    int4 iDblDeptParu;\n" \
  "    int4 iDblLocParu;\n" \
  "    int4 iDblArrParu;\n" \
  "    int4 iDblZU;\n" \
  "    int4 iGeoParu, iGeoInst;\n" \
  "    int4 iGeoArr, iGeoArrInst, iGeoLoc, iGeoDept, iGeoReg;\n" \
  "    int4 i, j, k, l, m, n;\n" \
  "    int4 ii, jj, kk, ll;\n" \
  "    int4 iIndCar;\n" \
  "    int4 iVal;\n" \
  "    int4 iRangRub, iRgRubDbl, iNbGeoRub, iRgGeoRub, iRangDeb, iNbrRub;\n" \
  "    iFinInst = (int4)GIV::GIXCodeKO;\n" \
  "    iFinParu = (int4)GIV::GIXCodeKO;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    /* doubles */\n" \
  "    iDblRegInst = (int4)GIV::GIXCodeKO;\n" \
  "    iDblDeptInst = (int4)GIV::GIXCodeKO;\n" \
  "    iDblLocInst = (int4)GIV::GIXCodeKO;\n" \
  "    iDblArrInst = (int4)GIV::GIXCodeKO;\n" \
  "    iDblRegParu = (int4)GIV::GIXCodeKO;\n" \
  "    iDblDeptParu = (int4)GIV::GIXCodeKO;\n" \
  "    iDblLocParu = (int4)GIV::GIXCodeKO;\n" \
  "    iDblArrParu = (int4)GIV::GIXCodeKO;\n" \
  "    iDblZU = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "    if (0 == givrListParu.iNbr)\n" \
  "    {\n" \
  "        /* pas de possibilité d'arrondissement d'installation local */\n" \
  "        /* Retourner sans erreur */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* trier en fonction des codes de parution */\n" \
  "    qsort(givrListParu.trEltRangList, givrListParu.iNbr, sizeof(int4), givCompListParu);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givTriGeo 1 \\n\"));\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution [%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgLigne,\n" \
  "                                 givrListParu.trEltList[i].iRgObj, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg,\n" \
  "                                 givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));\n" \
  "    }\n" \
  "\n" \
  "    /* suppression des objets hors tri */\n" \
  "    for (i = 0; i < givrListParu.iNbr; i++)\n" \
  "    {\n" \
  "        j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "        if (-1 == givrListParu.trEltList[j].iRangTri)\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    givrListParu.iNbr = i;\n" \
  "\n" \
  "    if (0 == givrListParu.iNbr)\n" \
  "    {\n" \
  "        /* Retourner sans erreur */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* trier en fonction des codes d'installation */\n" \
  "    qsort(givrListInst.trEltRangList, givrListInst.iNbr, sizeof(int4), givCompListInst);\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Installation [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep,\n" \
  "                                 givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc,\n" \
  "                                 givrListInst.trEltList[i].iGeoArr));\n" \
  "    }\n" \
  "\n" \
  "    /* supression objets hors tri */\n" \
  "    for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "    {\n" \
  "        j = givrListInst.trEltRangList[i];\n" \
  "\n" \
  "        if (-1 == givrListInst.trEltList[j].iRangTri)\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    givrListInst.iNbr = i;\n" \
  "    /* analyse de codes Locaux ou Extra-Locaux */\n" \
  "    i = 0;\n" \
  "    j = 0;\n" \
  "    k = givrListParu.trEltRangList[i];\n" \
  "    l = givrListInst.trEltRangList[j];\n" \
  "    kk = -1;\n" \
  "    ll = -1;\n" \
  "\n" \
  "    while (((int4)GIV::GIXCodeKO == iFinInst) || ((int4)GIV::GIXCodeKO == iFinParu))\n" \
  "    {\n" \
  "        /* analyse changement de parution */\n" \
  "        iDblRegParu = (int4)GIV::GIXCodeKO;\n" \
  "        iDblDeptParu = (int4)GIV::GIXCodeKO;\n" \
  "        iDblLocParu = (int4)GIV::GIXCodeKO;\n" \
  "        iDblArrParu = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "        if (kk != k)\n" \
  "        {\n" \
  "            if ((0 != strcmp(givrListParu.trEltList[kk].reg, givrListParu.trEltList[k].reg)) || (0 == i) || (givrListParu.trEltList[kk].iRangTri != givrListParu.trEltList[k].iRangTri))\n" \
  "            {\n" \
  "                /* changement de reg */\n" \
  "                iDblRegParu = (int4)GIV::GIXCodeOK;\n" \
  "                iDblDeptParu = (int4)GIV::GIXCodeOK;\n" \
  "                iDblLocParu = (int4)GIV::GIXCodeOK;\n" \
  "                iDblArrParu = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "            else if (0 != strcmp(givrListParu.trEltList[kk].dep, givrListParu.trEltList[k].dep))\n" \
  "            {\n" \
  "                /* changement de dept */\n" \
  "                iDblDeptParu = (int4)GIV::GIXCodeOK;\n" \
  "                iDblLocParu = (int4)GIV::GIXCodeOK;\n" \
  "                iDblArrParu = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "            else if (0 != strcmp(givrListParu.trEltList[kk].loc, givrListParu.trEltList[k].loc))\n" \
  "            {\n" \
  "                /* changement de loc */\n" \
  "                iDblLocParu = (int4)GIV::GIXCodeOK;\n" \
  "                iDblArrParu = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "            else if (0 != strcmp(givrListParu.trEltList[kk].arr, givrListParu.trEltList[k].arr))\n" \
  "            {\n" \
  "                /* changement d'arr */\n" \
  "                iDblArrParu = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        /* analyse changement d'installation */\n" \
  "        iDblRegInst = (int4)GIV::GIXCodeKO;\n" \
  "        iDblDeptInst = (int4)GIV::GIXCodeKO;\n" \
  "        iDblLocInst = (int4)GIV::GIXCodeKO;\n" \
  "        iDblArrInst = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "        if (ll != l)\n" \
  "        {\n" \
  "            if ((0 != strcmp(givrListInst.trEltList[ll].reg, givrListInst.trEltList[l].reg)) || (0 == j) || (givrListInst.trEltList[ll].iRangTri != givrListInst.trEltList[l].iRangTri))\n" \
  "                iDblArrInst = (int4)GIV::GIXCodeOK;\n" \
  "            else if (0 != strcmp(givrListInst.trEltList[ll].dep, givrListInst.trEltList[l].dep))\n" \
  "                iDblArrInst = (int4)GIV::GIXCodeOK;\n" \
  "            else if (0 != strcmp(givrListInst.trEltList[ll].loc, givrListInst.trEltList[l].loc))\n" \
  "                iDblArrInst = (int4)GIV::GIXCodeOK;\n" \
  "            else if (0 != strcmp(givrListInst.trEltList[ll].arr, givrListInst.trEltList[l].arr))\n" \
  "                iDblArrInst = (int4)GIV::GIXCodeOK;\n" \
  "        }\n" \
  "\n" \
  "        /* comparaison Parution/Installation */\n" \
  "        kk = k;\n" \
  "        ll = l;\n" \
  "        iGeoReg = 99;\n" \
  "        iGeoDept = 99;\n" \
  "        iGeoLoc = 99;\n" \
  "        iGeoArr = 99;\n" \
  "        iGeoArrInst = GIV::giv_INIT_ARR;\n" \
  "\n" \
  "        if ((0 == strcmp(givrListParu.trEltList[k].reg, givrListInst.trEltList[l].reg)) && (givrListParu.trEltList[k].iRangTri == givrListInst.trEltList[l].iRangTri))\n" \
  "        {\n" \
  "            /* même région */\n" \
  "            if (0 == strcmp(givrListParu.trEltList[k].dep, givrListInst.trEltList[l].dep))\n" \
  "            {\n" \
  "                iGeoDept = GIV::giv_LOC;\n" \
  "                iGeoReg = GIV::giv_LOC;\n" \
  "\n" \
  "                if (0 == strcmp(givrListParu.trEltList[k].loc, givrListInst.trEltList[l].loc))\n" \
  "                {\n" \
  "                    /* inscription locale */\n" \
  "                    iGeoLoc = GIV::giv_LOC;\n" \
  "\n" \
  "                    /* inscription locale : arr */\n" \
  "                    if ((0 != strcmp(\"99\", givrListInst.trEltList[l].arr)) && ((int4)GIV::GIXCodeOK != givrListParu.trEltList[k].iZU))\n" \
  "                        iGeoArrInst = GIV::giv_ARR;\n" \
  "\n" \
  "                    if ((0 == strcmp(givrListInst.trEltList[l].arr, givrListParu.trEltList[k].arr)) && ((int4)GIV::GIXCodeKO == iFinParu))\n" \
  "                    {\n" \
  "                        /* même arrondissement */\n" \
  "                        /* inscription locale : arr */\n" \
  "                        if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                            iGeoArr = GIV::giv_ARR;\n" \
  "\n" \
  "                        /* arr paru suivant */\n" \
  "                        i++;\n" \
  "                    }\n" \
  "                    else if (((0 < strcmp(givrListInst.trEltList[l].arr, givrListParu.trEltList[k].arr)) && ((int4)GIV::GIXCodeKO == iFinParu)) || ((int4)GIV::GIXCodeOK == iFinInst))\n" \
  "                    {\n" \
  "                        /* arr inst > arr paru */\n" \
  "                        /* différents arrondissements */\n" \
  "                        if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                            iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "                        /* inscription locale : arr extra */\n" \
  "                        /* arr paru suivant */\n" \
  "                        i++;\n" \
  "                    }\n" \
  "                    else if ((0 > strcmp(givrListInst.trEltList[l].arr, givrListParu.trEltList[k].arr)) || ((int4)GIV::GIXCodeOK == iFinParu))\n" \
  "                    {\n" \
  "                        /* arr inst < arr paru */\n" \
  "                        /* différents arrondissements */\n" \
  "                        /* inscription locale : arr  */\n" \
  "                        if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                            iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "                        /* arr inst suivant */\n" \
  "                        j++;\n" \
  "                    }\n" \
  "                }\n" \
  "                else if (((0 > strcmp(givrListParu.trEltList[k].loc, givrListInst.trEltList[l].loc)) && ((int4)GIV::GIXCodeKO == iFinParu)) || ((int4)GIV::GIXCodeOK == iFinInst))\n" \
  "                {\n" \
  "                    /* inscription départementale */\n" \
  "                    /* loc inst > loc paru */\n" \
  "                    /* différentes localités */\n" \
  "                    iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "                    if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                        iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "                    /* inscription dept : loc extra */\n" \
  "                    /* loc paru suivante */\n" \
  "                    i++;\n" \
  "                }\n" \
  "                else if ((0 < strcmp(givrListParu.trEltList[k].loc, givrListInst.trEltList[l].loc)) || ((int4)GIV::GIXCodeOK == iFinParu))\n" \
  "                {\n" \
  "                    /* inscription départementale */\n" \
  "                    /* loc inst < loc paru */\n" \
  "                    iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "                    if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                        iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "                    /* loc inst suivante */\n" \
  "                    j++;\n" \
  "                }\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* inscription extra départementale */\n" \
  "                iGeoDept = GIV::giv_EXTL;\n" \
  "                iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "                if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                    iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "                /* inscription régionale */\n" \
  "                iGeoReg = GIV::giv_LOC;\n" \
  "\n" \
  "                if (((0 > strcmp(givrListParu.trEltList[k].dep, givrListInst.trEltList[l].dep)) && ((int4)GIV::GIXCodeKO == iFinParu)) || ((int4)GIV::GIXCodeOK == iFinInst))\n" \
  "                {\n" \
  "                    /* dept inst > dept paru */\n" \
  "                    /* différents départements */\n" \
  "                    /* inscription extra dept : dep extra */\n" \
  "                    /* dept paru suivant */\n" \
  "                    i++;\n" \
  "                }\n" \
  "                else if ((0 < strcmp(givrListParu.trEltList[k].dep, givrListInst.trEltList[l].dep)) || ((int4)GIV::GIXCodeOK == iFinParu))\n" \
  "                {\n" \
  "                    /* dept inst < dept paru */\n" \
  "                    /* dept inst suivant */\n" \
  "                    j++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "        else if (givrListParu.trEltList[k].iRangTri == givrListInst.trEltList[l].iRangTri)\n" \
  "        {\n" \
  "            /* différentes régions */\n" \
  "            /* inscription extra départementale */\n" \
  "            iGeoDept = GIV::giv_EXTL;\n" \
  "            iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "            /* inscription extra-régionale */\n" \
  "            iGeoReg = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (((0 > strcmp(givrListParu.trEltList[k].reg, givrListInst.trEltList[l].reg)) && ((int4)GIV::GIXCodeKO == iFinParu)) || ((int4)GIV::GIXCodeOK == iFinInst))\n" \
  "            {\n" \
  "                /* reg inst > reg paru */\n" \
  "                /* différents départements */\n" \
  "                /* inscription extra dept : dep extra */\n" \
  "                /* dept paru suivant */\n" \
  "                i++;\n" \
  "            }\n" \
  "            else if ((0 < strcmp(givrListParu.trEltList[k].reg, givrListInst.trEltList[l].reg)) || ((int4)GIV::GIXCodeOK == iFinParu))\n" \
  "            {\n" \
  "                /* reg inst < reg paru */\n" \
  "                /* dept inst suivant */\n" \
  "                j++;\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* différentes rubriques */\n" \
  "            /* inscription extra départementale */\n" \
  "            iGeoDept = GIV::giv_EXTL;\n" \
  "            iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "            /* inscription extra-régionale */\n" \
  "            iGeoReg = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (((givrListParu.trEltList[k].iRangTri < givrListInst.trEltList[l].iRangTri) && ((int4)GIV::GIXCodeKO == iFinParu)) || ((int4)GIV::GIXCodeOK == iFinInst))\n" \
  "            {\n" \
  "                /* rub inst > rub paru */\n" \
  "                /* rub paru suivante */\n" \
  "                i++;\n" \
  "            }\n" \
  "            else if ((givrListParu.trEltList[k].iRangTri > givrListInst.trEltList[l].iRangTri) || ((int4)GIV::GIXCodeOK == iFinParu))\n" \
  "            {\n" \
  "                /* rub inst < rub paru */\n" \
  "                /* rub inst suivante */\n" \
  "                j++;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        /* pas d'arrondissement pour le pôle de zone urbaine */\n" \
  "        if (0 == strcmp(\"00\", givrListParu.trEltList[k].arr))\n" \
  "            iGeoArr = 99;\n" \
  "\n" \
  "        if (0 == strcmp(\"999\", givrListParu.trEltList[k].dep))\n" \
  "        {\n" \
  "            /* ancienne région : seule la parution sur région est validée */\n" \
  "            iGeoDept = 99;\n" \
  "            iGeoLoc = 99;\n" \
  "            iGeoArr = 99;\n" \
  "            iGeoArrInst = GIV::giv_INIT_ARR;\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution [%d],[%d],[%d],[%d]\\n\", givrListParu.iNbr, i, givrListInst.iNbr, j));\n" \
  "\n" \
  "        /* Analyse meilleur iGeo */\n" \
  "        if ((99 != givrListParu.trEltList[k].iGeoReg) && (iGeoReg < givrListParu.trEltList[k].iGeoReg))\n" \
  "            iDblRegParu = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "        if ((99 != givrListParu.trEltList[k].iGeoDept) && (iGeoDept < givrListParu.trEltList[k].iGeoDept))\n" \
  "            iDblDeptParu = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "        if ((99 != givrListParu.trEltList[k].iGeoLoc) && (iGeoLoc < givrListParu.trEltList[k].iGeoLoc))\n" \
  "            iDblLocParu = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "        if ((99 != givrListParu.trEltList[k].iGeoArr) && (iGeoArr < givrListParu.trEltList[k].iGeoArr))\n" \
  "            iDblArrParu = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "        if ((99 != givrListInst.trEltList[l].iGeoArr) && (iGeoArrInst < givrListInst.trEltList[l].iGeoArr))\n" \
  "            iDblArrInst = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "        /* Validation iGeo */\n" \
  "        if ((int4)GIV::GIXCodeOK == iDblRegParu)\n" \
  "        {\n" \
  "            /* changement de reg */\n" \
  "            givrListParu.trEltList[k].iGeoReg = iGeoReg;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iDblDeptParu)\n" \
  "        {\n" \
  "            /* changement de dept */\n" \
  "            givrListParu.trEltList[k].iGeoDept = iGeoDept;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iDblLocParu)\n" \
  "        {\n" \
  "            /* changement de loc */\n" \
  "            givrListParu.trEltList[k].iGeoLoc = iGeoLoc;\n" \
  "        }\n" \
  "\n" \
  "        if (((int4)GIV::GIXCodeOK == iDblArrParu) && (0 != strcmp(\"99\", givrListParu.trEltList[k].arr)))\n" \
  "        {\n" \
  "            /* changement d'arr */\n" \
  "            givrListParu.trEltList[k].iGeoArr = iGeoArr;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iDblArrInst)\n" \
  "        {\n" \
  "            /* changement d'arr instal */\n" \
  "            givrListInst.trEltList[l].iGeoArr = iGeoArrInst;\n" \
  "        }\n" \
  "\n" \
  "        if ((i < givrListParu.iNbr) && (j == givrListInst.iNbr) && (j != 0))\n" \
  "        {\n" \
  "            /* fin de liste installation */\n" \
  "            j--;\n" \
  "            iFinInst = (int4)GIV::GIXCodeOK;\n" \
  "        }\n" \
  "        else if ((i == givrListParu.iNbr) && (j < givrListInst.iNbr) && (i != 0))\n" \
  "        {\n" \
  "            /* fin de liste parution */\n" \
  "            i--;\n" \
  "            iFinParu = (int4)GIV::GIXCodeOK;\n" \
  "        }\n" \
  "        else if ((i == givrListParu.iNbr) && (j == givrListInst.iNbr))\n" \
  "        {\n" \
  "            /* fin de liste parution */\n" \
  "            iFinParu = (int4)GIV::GIXCodeOK;\n" \
  "            /* fin de liste installation */\n" \
  "            iFinInst = (int4)GIV::GIXCodeOK;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Parution suivante */\n" \
  "            k = givrListParu.trEltRangList[i];\n" \
  "            /* Installation suivante */\n" \
  "            l = givrListInst.trEltRangList[j];\n" \
  "\n" \
  "            if (givrListParu.trEltList[kk].iRangTri != givrListParu.trEltList[k].iRangTri)\n" \
  "            {\n" \
  "                /* fin de rubrique dans liste parution */\n" \
  "                i--;\n" \
  "                iFinParu = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "\n" \
  "            if (givrListInst.trEltList[ll].iRangTri != givrListInst.trEltList[l].iRangTri)\n" \
  "            {\n" \
  "                /* fin de rubrique dans liste installation */\n" \
  "                j--;\n" \
  "                iFinInst = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "\n" \
  "            if (((int4)GIV::GIXCodeOK == iFinParu) && ((int4)GIV::GIXCodeOK == iFinInst))\n" \
  "            {\n" \
  "                iFinParu = (int4)GIV::GIXCodeKO;\n" \
  "                i++;\n" \
  "                iFinInst = (int4)GIV::GIXCodeKO;\n" \
  "                j++;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        /* Parution suivante */\n" \
  "        k = givrListParu.trEltRangList[i];\n" \
  "        /* Installation suivante */\n" \
  "        l = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution [%d],[%d]\\n\", i, j));\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Comp Parution [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc,\n" \
  "                                 givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc,\n" \
  "                                 givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Comp Installation [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc,\n" \
  "                                 givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc,\n" \
  "                                 givrListInst.trEltList[i].iGeoArr));\n" \
  "    }\n" \
  "\n" \
  "    /* tranformation de codes Arr/Loc/Dept/Extra */\n" \
  "    /* rang géograhique par rubrique */\n" \
  "    iRgGeoRub = 0;\n" \
  "    iRangRub = 0;\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (iRangRub != givrListParu.trEltList[i].iRangTri)\n" \
  "        {\n" \
  "            iRangRub = givrListParu.trEltList[i].iRangTri;\n" \
  "            iRgGeoRub = 0;\n" \
  "        }\n" \
  "\n" \
  "        if (99 != givrListParu.trEltList[i].iGeoReg)\n" \
  "            iGeoReg = givrListParu.trEltList[i].iGeoReg;\n" \
  "\n" \
  "        if (99 != givrListParu.trEltList[i].iGeoDept)\n" \
  "            iGeoDept = givrListParu.trEltList[i].iGeoDept;\n" \
  "\n" \
  "        if (99 != givrListParu.trEltList[i].iGeoLoc)\n" \
  "            iGeoLoc = givrListParu.trEltList[i].iGeoLoc;\n" \
  "\n" \
  "        if (99 != givrListParu.trEltList[i].iGeoArr)\n" \
  "            iGeoArr = givrListParu.trEltList[i].iGeoArr;\n" \
  "\n" \
  "        if (((int4)GIV::GIXCodeOK != iDblZU) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[i].iZU))\n" \
  "        {\n" \
  "            givrListParu.trEltList[i].iGeoReg = 99;\n" \
  "            givrListParu.trEltList[i].iGeoDept = 99;\n" \
  "            givrListParu.trEltList[i].iGeoLoc = 99;\n" \
  "            givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "            iDblZU = (int4)GIV::GIXCodeOK;\n" \
  "        }\n" \
  "        else if (((int4)GIV::GIXCodeOK == iDblZU) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[i].iZU))\n" \
  "        {\n" \
  "            if ((99 != givrListParu.trEltList[i].iGeoReg) || (99 != givrListParu.trEltList[i].iGeoDept) || (99 != givrListParu.trEltList[i].iGeoLoc) || (99 != givrListParu.trEltList[i].iGeoArr))\n" \
  "            {\n" \
  "                /* changement de ZU */\n" \
  "            }\n" \
  "\n" \
  "            givrListParu.trEltList[i].iGeoReg = 99;\n" \
  "            givrListParu.trEltList[i].iGeoDept = 99;\n" \
  "            givrListParu.trEltList[i].iGeoLoc = 99;\n" \
  "            givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "        }\n" \
  "        else if (((int4)GIV::GIXCodeOK == iDblZU) && ((int4)GIV::GIXCodeOK != givrListParu.trEltList[i].iZU))\n" \
  "        {\n" \
  "            if ((99 == givrListParu.trEltList[i].iGeoReg) && (99 == givrListParu.trEltList[i].iGeoDept) && (99 == givrListParu.trEltList[i].iGeoLoc))\n" \
  "            {\n" \
  "                /* parution sur même ZU */\n" \
  "                givrListParu.trEltList[i].iZU = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "\n" \
  "            if (99 == givrListParu.trEltList[i].iGeoReg)\n" \
  "                givrListParu.trEltList[i].iGeoReg = iGeoReg;\n" \
  "\n" \
  "            if (99 == givrListParu.trEltList[i].iGeoDept)\n" \
  "                givrListParu.trEltList[i].iGeoDept = iGeoDept;\n" \
  "\n" \
  "            if (99 == givrListParu.trEltList[i].iGeoLoc)\n" \
  "                givrListParu.trEltList[i].iGeoLoc = iGeoLoc;\n" \
  "\n" \
  "            if (99 == givrListParu.trEltList[i].iGeoArr)\n" \
  "                givrListParu.trEltList[i].iGeoArr = iGeoArr;\n" \
  "\n" \
  "            iDblZU = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        if (GIV::giv_LOC == iGeoReg)\n" \
  "        {\n" \
  "            if (GIV::giv_LOC == iGeoDept)\n" \
  "            {\n" \
  "                if (GIV::giv_LOC == iGeoLoc)\n" \
  "                {\n" \
  "                    if (99 != givrListParu.trEltList[i].iGeoReg)\n" \
  "                        givrListParu.trEltList[i].iGeoReg = GIV::giv_REG;\n" \
  "\n" \
  "                    if (99 != givrListParu.trEltList[i].iGeoDept)\n" \
  "                        givrListParu.trEltList[i].iGeoDept = GIV::giv_DEPT;\n" \
  "\n" \
  "                    if (99 != givrListParu.trEltList[i].iGeoLoc)\n" \
  "                        givrListParu.trEltList[i].iGeoLoc = GIV::giv_LOC;\n" \
  "\n" \
  "                    if ((GIV::giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))\n" \
  "                        givrListParu.trEltList[i].iGeoArr = GIV::giv_LOC;\n" \
  "                    else if ((GIV::giv_ARR == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))\n" \
  "                        givrListParu.trEltList[i].iGeoArr = GIV::giv_ARR;\n" \
  "                    else\n" \
  "                        givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    if (99 != givrListParu.trEltList[i].iGeoReg)\n" \
  "                        givrListParu.trEltList[i].iGeoReg = GIV::giv_REG;\n" \
  "\n" \
  "                    if (99 != givrListParu.trEltList[i].iGeoDept)\n" \
  "                        givrListParu.trEltList[i].iGeoDept = GIV::giv_DEPT;\n" \
  "\n" \
  "                    if (99 != givrListParu.trEltList[i].iGeoLoc)\n" \
  "                        givrListParu.trEltList[i].iGeoLoc = GIV::giv_DEPT;\n" \
  "\n" \
  "                    if ((GIV::giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))\n" \
  "                        givrListParu.trEltList[i].iGeoArr = GIV::giv_DEPT;\n" \
  "                    else\n" \
  "                        givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "                }\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                if (99 != givrListParu.trEltList[i].iGeoReg)\n" \
  "                    givrListParu.trEltList[i].iGeoReg = GIV::giv_REG;\n" \
  "\n" \
  "                if (99 != givrListParu.trEltList[i].iGeoDept)\n" \
  "                    givrListParu.trEltList[i].iGeoDept = GIV::giv_EXTL;\n" \
  "\n" \
  "                if (99 != givrListParu.trEltList[i].iGeoLoc)\n" \
  "                    givrListParu.trEltList[i].iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "                if ((GIV::giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))\n" \
  "                    givrListParu.trEltList[i].iGeoArr = GIV::giv_EXTL;\n" \
  "                else\n" \
  "                    givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            if (99 != givrListParu.trEltList[i].iGeoReg)\n" \
  "                givrListParu.trEltList[i].iGeoReg = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (99 != givrListParu.trEltList[i].iGeoDept)\n" \
  "                givrListParu.trEltList[i].iGeoDept = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (99 != givrListParu.trEltList[i].iGeoLoc)\n" \
  "                givrListParu.trEltList[i].iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            if ((GIV::giv_EXTL == iGeoArr) && (99 != givrListParu.trEltList[i].iGeoArr))\n" \
  "                givrListParu.trEltList[i].iGeoArr = GIV::giv_EXTL;\n" \
  "            else\n" \
  "                givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "        }\n" \
  "\n" \
  "        if ((99 == givrListParu.trEltList[i].iGeoReg) && (99 == givrListParu.trEltList[i].iGeoDept) && (99 == givrListParu.trEltList[i].iGeoLoc) && ((98 == givrListParu.trEltList[i].iGeoArr)\n" \
  "                || (99 == givrListParu.trEltList[i].iGeoArr)))\n" \
  "            givrListParu.trEltList[i].iRgGeoTri = -1;\n" \
  "        else\n" \
  "        {\n" \
  "            givrListParu.trEltList[i].iRgGeoTri = iRgGeoRub;\n" \
  "            iRgGeoRub++;\n" \
  "        }\n" \
  "\n" \
  "        if (0 == strcmp(\"999\", givrListParu.trEltList[i].dep))\n" \
  "        {\n" \
  "            /* ancienne région : seule la parution sur région est validée */\n" \
  "            givrListParu.trEltList[i].iGeoDept = GIV::giv_DFT;\n" \
  "            givrListParu.trEltList[i].iGeoLoc = GIV::giv_DFT;\n" \
  "            givrListParu.trEltList[i].iGeoArr = GIV::giv_DFT;\n" \
  "            givrListParu.trEltList[i].iGeoArr = GIV::giv_DFT;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution Géo-Dénom [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc,\n" \
  "                                 givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc,\n" \
  "                                 givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));\n" \
  "    }\n" \
  "\n" \
  "    for (j = 1; (j < (givrListParu.iNbr) && GIV::giv_RUB == iTri); j++)\n" \
  "    {\n" \
  "        /* restauration des iGeo pour dénom différentes */\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        ii = givrListParu.trEltRangList[j - 1];\n" \
  "\n" \
  "        if (99 == givrListParu.trEltList[i].iGeoReg)\n" \
  "            givrListParu.trEltList[i].iGeoReg = givrListParu.trEltList[ii].iGeoReg;\n" \
  "\n" \
  "        if (99 == givrListParu.trEltList[i].iGeoDept)\n" \
  "            givrListParu.trEltList[i].iGeoDept = givrListParu.trEltList[ii].iGeoDept;\n" \
  "\n" \
  "        if (99 == givrListParu.trEltList[i].iGeoLoc)\n" \
  "            givrListParu.trEltList[i].iGeoLoc = givrListParu.trEltList[ii].iGeoLoc;\n" \
  "\n" \
  "        if (99 == givrListParu.trEltList[i].iGeoArr)\n" \
  "            givrListParu.trEltList[i].iGeoArr = givrListParu.trEltList[ii].iGeoArr;\n" \
  "\n" \
  "        if (98 == givrListParu.trEltList[i].iGeoArr)\n" \
  "            givrListParu.trEltList[i].iGeoArr = givrListParu.trEltList[ii].iGeoArr;\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; (j < (givrListParu.iNbr) && GIV::giv_RUB == iTri); j++)\n" \
  "    {\n" \
  "        /* pas de restauration des iGeo pour iZU */\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if ((-1 == givrListParu.trEltList[i].iRgGeoTri) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[i].iZU))\n" \
  "        {\n" \
  "            givrListParu.trEltList[i].iGeoReg = 99;\n" \
  "            givrListParu.trEltList[i].iGeoDept = 99;\n" \
  "            givrListParu.trEltList[i].iGeoLoc = 99;\n" \
  "            givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution Géo-Dénom [%s], [%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc,\n" \
  "                                 givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc,\n" \
  "                                 givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU));\n" \
  "    }\n" \
  "\n" \
  "#if 0\n" \
  "\n" \
  "    for (j = 1; (j < (givrListInst.iNbr) && GIV::giv_RUB == iTri); j++)\n" \
  "    {\n" \
  "        /* restauration des iGeoArr d'installation pour dénom différentes */\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        ii = givrListInst.trEltRangList[j - 1];\n" \
  "\n" \
  "        if (99 == givrListInst.trEltList[i].iGeoArr)\n" \
  "            givrListInst.trEltList[i].iGeoArr = givrListInst.trEltList[ii].iGeoArr;\n" \
  "\n" \
  "        if (98 == givrListInst.trEltList[i].iGeoArr)\n" \
  "            givrListInst.trEltList[i].iGeoArr = givrListInst.trEltList[ii].iGeoArr;\n" \
  "    }\n" \
  "\n" \
  "#endif\n" \
  "    iRgGeoRub = 0;\n" \
  "    iRangRub = 0;\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "\n" \
  "        if (iRangRub != givrListInst.trEltList[i].iRangTri)\n" \
  "        {\n" \
  "            iRangRub = givrListInst.trEltList[i].iRangTri;\n" \
  "            iRgGeoRub = 0;\n" \
  "        }\n" \
  "\n" \
  "        if ((99 == givrListInst.trEltList[i].iGeoReg) && (99 == givrListInst.trEltList[i].iGeoDept) && (99 == givrListInst.trEltList[i].iGeoLoc) && ((98 == givrListInst.trEltList[i].iGeoArr)\n" \
  "                || (99 == givrListInst.trEltList[i].iGeoArr)))\n" \
  "            givrListInst.trEltList[i].iRgGeoTri = -1;\n" \
  "        else\n" \
  "        {\n" \
  "            givrListInst.trEltList[i].iRgGeoTri = iRgGeoRub;\n" \
  "            iRgGeoRub++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* nombre de rangs géographiques significatifs par rubrique */\n" \
  "    iNbGeoRub = 0;\n" \
  "    iRangRub = 0;\n" \
  "    iRangDeb = 0;\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (iRangRub != givrListParu.trEltList[i].iRangTri)\n" \
  "        {\n" \
  "            iRgGeoRub = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < j; l++)\n" \
  "            {\n" \
  "                k = givrListParu.trEltRangList[l];\n" \
  "                givrListParu.trEltList[k].iNbGeoTri = iNbGeoRub;\n" \
  "\n" \
  "                if (-1 != givrListParu.trEltList[k].iRgGeoTri)\n" \
  "                {\n" \
  "                    givrListParu.trEltList[k].iRgGeoTri = iRgGeoRub;\n" \
  "                    iRgGeoRub++;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            iRangRub = givrListParu.trEltList[i].iRangTri;\n" \
  "            iNbGeoRub = 0;\n" \
  "            iRangDeb = j;\n" \
  "        }\n" \
  "\n" \
  "        if (-1 != givrListParu.trEltList[i].iRgGeoTri)\n" \
  "            iNbGeoRub++;\n" \
  "\n" \
  "        if ((givrListParu.iNbr - 1) == j)\n" \
  "        {\n" \
  "            iRgGeoRub = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < (givrListParu.iNbr); l++)\n" \
  "            {\n" \
  "                k = givrListParu.trEltRangList[l];\n" \
  "                givrListParu.trEltList[k].iNbGeoTri = iNbGeoRub;\n" \
  "\n" \
  "                if (-1 != givrListParu.trEltList[k].iRgGeoTri)\n" \
  "                {\n" \
  "                    givrListParu.trEltList[k].iRgGeoTri = iRgGeoRub;\n" \
  "                    iRgGeoRub++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    iNbGeoRub = 0;\n" \
  "    iRangRub = 0;\n" \
  "    iRangDeb = 0;\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "\n" \
  "        if (iRangRub != givrListInst.trEltList[i].iRangTri)\n" \
  "        {\n" \
  "            iRgGeoRub = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < j; l++)\n" \
  "            {\n" \
  "                k = givrListInst.trEltRangList[l];\n" \
  "                givrListInst.trEltList[k].iNbGeoTri = iNbGeoRub;\n" \
  "\n" \
  "                if (-1 != givrListInst.trEltList[k].iRgGeoTri)\n" \
  "                {\n" \
  "                    givrListInst.trEltList[k].iRgGeoTri = iRgGeoRub;\n" \
  "                    iRgGeoRub++;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            iRangRub = givrListInst.trEltList[i].iRangTri;\n" \
  "            iNbGeoRub = 0;\n" \
  "            iRangDeb = j;\n" \
  "        }\n" \
  "\n" \
  "        if (-1 != givrListInst.trEltList[i].iRgGeoTri)\n" \
  "            iNbGeoRub++;\n" \
  "\n" \
  "        if ((givrListInst.iNbr - 1) == j)\n" \
  "        {\n" \
  "            iRgGeoRub = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < (givrListInst.iNbr); l++)\n" \
  "            {\n" \
  "                k = givrListInst.trEltRangList[l];\n" \
  "                givrListInst.trEltList[k].iNbGeoTri = iNbGeoRub;\n" \
  "\n" \
  "                if (-1 != givrListInst.trEltList[k].iRgGeoTri)\n" \
  "                {\n" \
  "                    givrListInst.trEltList[k].iRgGeoTri = iRgGeoRub;\n" \
  "                    iRgGeoRub++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* tri en fonction des tailles de blocs par geo/rub  */\n" \
  "    /* liste installation */\n" \
  "    qsort(givrListInst.trEltRangList, givrListInst.iNbr, sizeof(int4), givCompListInstTaille);\n" \
  "\n" \
  "    if (GIV::giv_OBJ != iTri)\n" \
  "        givrListInst.iNbrTot = givrListInst.iNbr;\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        givrListInst.trEltList[i].iRgTriDbl = -1;\n" \
  "\n" \
  "        if (-1 == givrListInst.trEltList[i].iRgGeoTri)\n" \
  "        {\n" \
  "            givrListInst.iNbr = j;\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givTriGeo 3 \\n\"));\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Installation [%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].iRgGeoTri, givrListInst.trEltList[i].iNbGeoTri,\n" \
  "                                 givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg,\n" \
  "                                 givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));\n" \
  "    }\n" \
  "\n" \
  "    /* recherche des rubriques ayant même géographie */\n" \
  "    /* recherche des rubriques ayant même géographie */\n" \
  "    /* liste installation */\n" \
  "    j = 0;\n" \
  "\n" \
  "    while (j < givrListInst.iNbr)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "\n" \
  "        if (-1 == givrListInst.trEltList[i].iRgTriDbl)\n" \
  "            givrListInst.trEltList[i].iRgTriDbl = givrListInst.trEltList[i].iRangTri;\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"iRgRubDbl [%d]\\n\", givrListInst.trEltList[i].iRgTriDbl));\n" \
  "        iNbGeoRub = givrListInst.trEltList[i].iNbGeoTri;\n" \
  "        l = j + iNbGeoRub;\n" \
  "        k = givrListInst.trEltRangList[l];\n" \
  "\n" \
  "        while ((l < givrListInst.iNbr) && (givrListInst.trEltList[i].iRangTri == givrListInst.trEltList[i].iRgTriDbl))\n" \
  "        {\n" \
  "            if ((givrListInst.trEltList[i].iNbGeoTri != givrListInst.trEltList[k].iNbGeoTri) || (-1 != givrListInst.trEltList[k].iRgTriDbl))\n" \
  "            {\n" \
  "                /* tailles différentes ou déjà doublé */\n" \
  "                iNbGeoRub = givrListInst.trEltList[k].iNbGeoTri;\n" \
  "                l = l + iNbGeoRub;\n" \
  "                k = givrListInst.trEltRangList[l];\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* même taille */\n" \
  "                for (m = 0; m < iNbGeoRub; m++)\n" \
  "                {\n" \
  "                    if (givrListInst.trEltList[givrListInst.trEltRangList[j + m]].iRgGeoTri != givrListInst.trEltList[givrListInst.trEltRangList[l + m]].iRgGeoTri)\n" \
  "                    {\n" \
  "                        /* rangs différents */\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].reg, givrListInst.trEltList[givrListInst.trEltRangList[l + m]].reg))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].dep, givrListInst.trEltList[givrListInst.trEltRangList[l + m]].dep))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].loc, givrListInst.trEltList[givrListInst.trEltRangList[l + m]].loc))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (0 != strcmp(givrListInst.trEltList[givrListInst.trEltRangList[j + m]].arr, givrListInst.trEltList[givrListInst.trEltRangList[l + m]].arr))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (givrListInst.trEltList[givrListInst.trEltRangList[j + m]].iGeoArr != givrListInst.trEltList[givrListInst.trEltRangList[l + m]].iGeoArr)\n" \
  "                        break;\n" \
  "                }\n" \
  "\n" \
  "                if (m == iNbGeoRub)\n" \
  "                {\n" \
  "                    /* égalité complète des rubriques */\n" \
  "                    givrListInst.trEltList[k].iRgTriDbl = givrListInst.trEltList[i].iRgTriDbl;\n" \
  "                    /* nombre de rubriques */\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Partie 3 Nombre de rubriques [%d]\\n\", givrListInst.iNbrTri));\n" \
  "                }\n" \
  "\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"iRgRubDbl [%d]\\n\", givrListInst.trEltList[k].iRgTriDbl));\n" \
  "                /* rubrique suivante */\n" \
  "                iNbGeoRub = givrListInst.trEltList[k].iNbGeoTri;\n" \
  "                l = l + iNbGeoRub;\n" \
  "                k = givrListInst.trEltRangList[l];\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        iNbGeoRub = givrListInst.trEltList[i].iNbGeoTri;\n" \
  "        j = j + iNbGeoRub;\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; (j < givrListInst.iNbr && GIV::giv_RUB == iTri); j++)\n" \
  "    {\n" \
  "        /* restauration de iRgTriDbl */\n" \
  "        jj = givrListInst.trEltRangList[j];\n" \
  "\n" \
  "        if (-1 != givrListInst.trEltList[jj].iRgTriDbl)\n" \
  "            ii = jj;\n" \
  "        else\n" \
  "            givrListInst.trEltList[jj].iRgTriDbl = givrListInst.trEltList[ii].iRgTriDbl;\n" \
  "    }\n" \
  "\n" \
  "    for (j = givrListInst.iNbr; (j < givrListInst.iNbrTot && GIV::giv_RUB == iTri); j++)\n" \
  "    {\n" \
  "        /* restauration de iRgTriDbl */\n" \
  "        jj = givrListInst.trEltRangList[j];\n" \
  "\n" \
  "        for (i = 0; i < givrListInst.iNbr; i++)\n" \
  "        {\n" \
  "            ii = givrListInst.trEltRangList[i];\n" \
  "\n" \
  "            if (givrListInst.trEltList[ii].iRangTri == givrListInst.trEltList[jj].iRangTri)\n" \
  "            {\n" \
  "                givrListInst.trEltList[jj].iRgTriDbl = givrListInst.trEltList[ii].iRgTriDbl;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* recherche des rubriques ayant même géographie */\n" \
  "    /* listes parution et installation confondues */\n" \
  "\n" \
  "    for (j = 0; j < givrListParu.iNbr; j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        /* même rubrique parution/installation */\n" \
  "        for (l = 0; l < givrListInst.iNbr; l++)\n" \
  "        {\n" \
  "            k = givrListInst.trEltRangList[l];\n" \
  "\n" \
  "            if (givrListParu.trEltList[i].iRangTri == givrListInst.trEltList[k].iRangTri)\n" \
  "            {\n" \
  "                givrListParu.trEltList[i].iRgTriDblBis = givrListInst.trEltList[k].iRgTriDbl;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (givrListInst.iNbr == l)\n" \
  "        {\n" \
  "            /* pas de rubrique installation */\n" \
  "            givrListParu.trEltList[i].iRgTriDblBis = -1;\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"iRgRubDblBis [%d]\\n\", givrListParu.trEltList[i].iRgTriDblBis));\n" \
  "    }\n" \
  "\n" \
  "    /* tri en fonction des tailles de blocs par geo/rub  */\n" \
  "    /* liste parution */\n" \
  "    qsort(givrListParu.trEltRangList, givrListParu.iNbr, sizeof(int4), givCompListParuTaille);\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution Tri Taille[%d],[%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].iRgGeoTri, givrListParu.trEltList[i].iNbGeoTri,\n" \
  "                                 givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgTriDbl, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr,\n" \
  "                                 givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr,\n" \
  "                                 givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));\n" \
  "    }\n" \
  "\n" \
  "    if (GIV::giv_RUB == iTri)\n" \
  "    {\n" \
  "        /* il peut y avoir des objets hors tri */\n" \
  "        givrListParu.iNbrTot = givrListParu.iNbr;\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        givrListParu.trEltList[i].iRgTriDbl = -1;\n" \
  "\n" \
  "        if (-1 == givrListParu.trEltList[i].iRgGeoTri)\n" \
  "        {\n" \
  "            givrListParu.iNbr = j;\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution Tri Taille[%d],[%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].iRgGeoTri, givrListParu.trEltList[i].iNbGeoTri,\n" \
  "                                 givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgTriDbl, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr,\n" \
  "                                 givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr,\n" \
  "                                 givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));\n" \
  "    }\n" \
  "\n" \
  "    /* recherche des rubriques ayant même géographie */\n" \
  "    /* liste parution */\n" \
  "    j = 0;\n" \
  "\n" \
  "    while (j < givrListParu.iNbr)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (-1 == givrListParu.trEltList[i].iRgTriDbl)\n" \
  "            givrListParu.trEltList[i].iRgTriDbl = givrListParu.trEltList[i].iRangTri;\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"iRgRubDbl [%d],[%d]\\n\", givrListParu.trEltList[i].iRgTriDbl, givrListParu.trEltList[i].iRangTri));\n" \
  "        iNbGeoRub = givrListParu.trEltList[i].iNbGeoTri;\n" \
  "        l = j + iNbGeoRub;\n" \
  "        k = givrListParu.trEltRangList[l];\n" \
  "\n" \
  "        while ((l < givrListParu.iNbr) && (givrListParu.trEltList[i].iRangTri == givrListParu.trEltList[i].iRgTriDbl))\n" \
  "        {\n" \
  "            if ((givrListParu.trEltList[i].iNbGeoTri != givrListParu.trEltList[k].iNbGeoTri) || (-1 != givrListParu.trEltList[k].iRgTriDbl))\n" \
  "            {\n" \
  "                /* tailles différentes ou déjà doublé */\n" \
  "                iNbGeoRub = givrListParu.trEltList[k].iNbGeoTri;\n" \
  "                l = l + iNbGeoRub;\n" \
  "                k = givrListParu.trEltRangList[l];\n" \
  "            }\n" \
  "            else if (givrListParu.trEltList[i].iRgTriDblBis != givrListParu.trEltList[k].iRgTriDblBis)\n" \
  "            {\n" \
  "                /* installations différentes */\n" \
  "                iNbGeoRub = givrListParu.trEltList[k].iNbGeoTri;\n" \
  "                l = l + iNbGeoRub;\n" \
  "                k = givrListParu.trEltRangList[l];\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* même taille */\n" \
  "                for (m = 0; m < iNbGeoRub; m++)\n" \
  "                {\n" \
  "                    if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iRgGeoTri != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iRgGeoTri)\n" \
  "                    {\n" \
  "                        /* rangs différents */\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].reg, givrListParu.trEltList[givrListParu.trEltRangList[l + m]].reg))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoReg != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoReg)\n" \
  "                        break;\n" \
  "\n" \
  "                    if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].dep, givrListParu.trEltList[givrListParu.trEltRangList[l + m]].dep))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoDept != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoDept)\n" \
  "                        break;\n" \
  "\n" \
  "                    if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].loc, givrListParu.trEltList[givrListParu.trEltRangList[l + m]].loc))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoLoc != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoLoc)\n" \
  "                        break;\n" \
  "\n" \
  "                    if (0 != strcmp(givrListParu.trEltList[givrListParu.trEltRangList[j + m]].arr, givrListParu.trEltList[givrListParu.trEltRangList[l + m]].arr))\n" \
  "                        break;\n" \
  "\n" \
  "                    if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iGeoArr != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iGeoArr)\n" \
  "                        break;\n" \
  "\n" \
  "                    if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].iZU != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].iZU)\n" \
  "                        break;\n" \
  "\n" \
  "                    if (givrListParu.trEltList[givrListParu.trEltRangList[j + m]].cParuloc != givrListParu.trEltList[givrListParu.trEltRangList[l + m]].cParuloc)\n" \
  "                        break;\n" \
  "                }\n" \
  "\n" \
  "                if (m == iNbGeoRub)\n" \
  "                {\n" \
  "                    /* égalité complète des rubriques */\n" \
  "                    givrListParu.trEltList[k].iRgTriDbl = givrListParu.trEltList[i].iRgTriDbl;\n" \
  "                    /* nombre de rubriques */\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Partie 3 Nombre de rubriques [%d]\\n\", givrListParu.iNbrTri));\n" \
  "                }\n" \
  "\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"iRgRubDbl [%d],[%d]\\n\", givrListParu.trEltList[k].iRgTriDbl, givrListParu.trEltList[k].iRangTri));\n" \
  "                /* rubrique suivante */\n" \
  "                iNbGeoRub = givrListParu.trEltList[k].iNbGeoTri;\n" \
  "                l = l + iNbGeoRub;\n" \
  "                k = givrListParu.trEltRangList[l];\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        iNbGeoRub = givrListParu.trEltList[i].iNbGeoTri;\n" \
  "        j = j + iNbGeoRub;\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; (j < givrListParu.iNbr && GIV::giv_RUB == iTri); j++)\n" \
  "    {\n" \
  "        /* restauration de iRgTriDbl */\n" \
  "        jj = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (-1 != givrListParu.trEltList[jj].iRgTriDbl)\n" \
  "            ii = jj;\n" \
  "        else\n" \
  "            givrListParu.trEltList[jj].iRgTriDbl = givrListParu.trEltList[ii].iRgTriDbl;\n" \
  "    }\n" \
  "\n" \
  "    for (j = givrListParu.iNbr; (j < givrListParu.iNbrTot && GIV::giv_RUB == iTri); j++)\n" \
  "    {\n" \
  "        /* restauration de iRgTriDbl */\n" \
  "        jj = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        for (i = 0; i < givrListParu.iNbr; i++)\n" \
  "        {\n" \
  "            ii = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "            if (givrListParu.trEltList[ii].iRangTri == givrListParu.trEltList[jj].iRangTri)\n" \
  "            {\n" \
  "                givrListParu.trEltList[jj].iRgTriDbl = givrListParu.trEltList[ii].iRgTriDbl;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nb Parution [%d],[%d]\\n\", givrListParu.iNbrTot, givrListParu.iNbr));\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbrTot); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution [%d],[%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].iRgGeoTri, givrListParu.trEltList[i].iNbGeoTri,\n" \
  "                                 givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgTriDbl, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr,\n" \
  "                                 givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr,\n" \
  "                                 givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne, givrListParu.trEltList[i].iRgObj));\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nb Installation [%d],[%d]\\n\", givrListInst.iNbrTot, givrListInst.iNbr));\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbrTot); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Installation [%d],[%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].iRgGeoTri, givrListInst.trEltList[i].iNbGeoTri,\n" \
  "                                 givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg,\n" \
  "                                 givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));\n" \
  "    }\n" \
  "\n" \
  "    /* Retourner sans erreur */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "int4 givPreparerRequetesIeBloc()\n" \
  "{\n" \
  "    int4 iCodRet = (int4)GIV::GIXCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = (int4)GIV::GIXCodeOK; /* Code retour des appels internes */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char tcRequete[1024];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iDejaPrepare)\n" \
  "    {\n" \
  "        /* suppressions */\n" \
  "        (void)sprintf(tcRequete, GIV_DEL_IEBLOC, GIXcNomDest);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtDelIeBloc\n" \
  "        from: tcRequete;\n" \
  "        (void)sprintf(tcRequete, GIV_DEL_IEBLOC_CRC, GIXcNomDest);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtDelIeBlocCRC\n" \
  "        from: tcRequete;\n" \
  "        iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerRequetesIeBloc\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLecturePELREP ()                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche du libelle de       */\n" \
  "/*             localite a partir du code localite dans la table GYTtabPelrep  */\n" \
  "/*                                                                        */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "extern int4 givPreparerLectureLocAtt(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureLocAtt\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_LIB_LJLORN);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_LIB_LJLORN);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureLocAtt\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureLocAtt\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureLocAtt : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureLocAtt\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureLocAtt\n" \
  "            cursor\n" \
  "            for rqtLectureLocAtt;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureLocAtt ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_LOC_DEP);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_LOC_DEP);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureLocDep\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureLocDep\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureLocDep : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureLocDep\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureLocDep\n" \
  "            cursor\n" \
  "            for rqtLectureLocDep;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureLocDep ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureLocAtt\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureTypeURL ()                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche du type de          */\n" \
  "/*             l'URL a partir du numero d'objet dans la table GYTtabPemicURL  */\n" \
  "/*                                                                        */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "extern int4 givPreparerLectureTypeURL(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureTypeURL\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_TYPE_URL);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_TYPE_URL);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureTypeURL\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureTypeURL\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureTypeURL : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureTypeURL\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureTypeURL\n" \
  "            cursor\n" \
  "            for rqtLectureTypeURL;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureTypeURL ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureTypeURL\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureEmbauche ()                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             ref à partir de numcli dans la table GYTtabEmbauche            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureEmbauche(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureEmbauche\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_EMBAUCHE);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_EMBAUCHE);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureEmbauche\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureEmbauche\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureEmbauche : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureEmbauche\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureEmbauche\n" \
  "            cursor\n" \
  "            for rqtLectureEmbauche;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureEmbauche ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureEmbauche\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureStat ()                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche du                  */\n" \
  "/*             code statistique de l'annonceur                                */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureStat(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureStat\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_STAT);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_STAT);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureStat\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureStat\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureStat : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureStat\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureStat\n" \
  "            cursor\n" \
  "            for rqtLectureStat;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureStat ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureStat\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureImag ()                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche du                  */\n" \
  "/*             nombre d'images pour le produit PVI                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureImag(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureImag\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_IMAG);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_IMAG);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureImag\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureImag\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureImag : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureImag\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureImag\n" \
  "            cursor\n" \
  "            for rqtLectureImag;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureImag ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureImag\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureMotsCles ()                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche du                  */\n" \
  "/*             crc mots cles                                                  */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureMotsCles(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureImag\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_SLC_MOT_CLE);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_SLC_MOT_CLE);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureMCles\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureMCles\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureMCles : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureMCles\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureMCles\n" \
  "            cursor\n" \
  "            for rqtLectureMCles;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureMCles ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureMCles\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureBonPlan ()                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             ref à partir de etab dans la table GYTtabBonPlan               */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureBonPlan(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE * 2];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureBonPlan\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_BONPLAN_PUB);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_BONPLAN_PUB);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureBonPlanPub\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureBonPlanPub\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureBonPlanPub : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureBonPlanPub\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureBonPlanPub\n" \
  "            cursor\n" \
  "            for rqtLectureBonPlanPub;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureBonPlanPub ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureBonPlan\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureBUC ()                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             numcli à partir de etab dans la table GYTtabIeInsc             */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureBUC()\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureBUC\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_BUC);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_BUC);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureBUC\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureBUC\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureBUC : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureBUC\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureBUC\n" \
  "            cursor\n" \
  "            for rqtLectureBUC;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureBUC ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureBUC\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureSEO ()                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             numcli à partir de etab dans la table GYTtabIeInsc             */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureSEO(char* apcDepart)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    char conf[50];\n" \
  "    char* pChar;\n" \
  "    char tcClause[GWT_LG_MAX_LIGNE];\n" \
  "    char tcBlocDoc[4]; /* destinataire bloc doc associé */\n" \
  "    EXEC SQL begin declare section;\n" \
  "    char cRequete[6 * giv_LG_REQUETE];\n" \
  "    EXEC SQL end declare section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureSEO\\n\"));\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_BLOC_DOC_EPJ\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, tcBlocDoc);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(tcBlocDoc, GIXcNomDest);\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Destinataire des blocs Pertimm : %s\\n\", tcBlocDoc));\n" \
  "    /* Préparer la requête de version */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"select version de bloc\");\n" \
  "    (void)sprintf(cRequete, GIV_VERS_SEO, tcBlocDoc);\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_GRAVE, (\"%s\\n\", cRequete));\n" \
  "\n" \
  "\n" \
  "    EXEC SQL prepare rqtVersSEO from: cRequete;\n" \
  "    EXEC SQL DECLARE crsVersSEO CURSOR FOR rqtVersSEO;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_CLAUSE_SEO_SERVICE\", GIXcNomDest);\n" \
  "\n" \
  "    if (0 != GWTLireConf(conf, &givtcClause[0]))\n" \
  "        strcpy(givtcClause, \"\");\n" \
  "\n" \
  "    pChar = &givtcClause[0];\n" \
  "\n" \
  "    while (*pChar != 0)\n" \
  "    {\n" \
  "        if ('@' == *pChar)\n" \
  "            *pChar = '=';\n" \
  "\n" \
  "        pChar++;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"La clause where SEO_SERVICE est : [%s],%d\\n\", givtcClause, strlen(givtcClause)));\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_SRV_SEO) + strlen(givtcClause);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"SEO_SERVICE : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_SRV_SEO, givtcClause);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureSrvSEO\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureSrvSEO\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureSrvSEO : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureSrvSEO\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureSrvSEO\n" \
  "            cursor\n" \
  "            for rqtLectureSrvSEO;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureSrvSEO ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_DNOM_PRINC);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_DNOM_PRINC, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureDnomPrinc\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureDnomPrinc\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureDnomPrinc : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureDnomPrinc\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureDnomPrinc\n" \
  "            cursor\n" \
  "            for rqtLectureDnomPrinc;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureDnomPrinc ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureSEO\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureExtraLoc ()                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             extra loc à partir de etab dans la table GYTtabIeInsc          */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureExtraLoc(char* apcDepart)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[6 * giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureExtraLoc\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_EXTRA_LOC_IS);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_EXTRA_LOC_IS, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureExtraLocIS\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureExtraLocIS\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureExtraLocIS : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureExtraLocIS\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureExtraLocIS\n" \
  "            cursor\n" \
  "            for rqtLectureExtraLocIS;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureExtraLocIS ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_EXTRA_LOC_INTER_IS);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_EXTRA_LOC_INTER_IS, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureExtraLocInterIS\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureExtraLocInterIS\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureExtraLocInterIS : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureExtraLocIS\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureExtraLocInterIS\n" \
  "            cursor\n" \
  "            for rqtLectureExtraLocInterIS;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureExtraLocInterIS ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_EXTRA_LOC_IO);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_EXTRA_LOC_IO, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour, GIXcNomDest, apcDepart, GIXcNomFour,\n" \
  "                      GIXcNomDest, apcDepart);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureExtraLocIO\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureExtraLocIO\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureExtraLocIO : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureExtraLocIO\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureExtraLocIO\n" \
  "            cursor\n" \
  "            for rqtLectureExtraLocIO;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureExtraLocIO ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureExtraLoc\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureEvIlo ()                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             ref à partir de etab dans la table GYTtabEvIlo                 */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureEvIlo(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureEvIlo\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_EVILO);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_EVILO);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureEvIlo\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureEvIlo\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureEvIlo : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureEvIlo\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureEvIlo\n" \
  "            cursor\n" \
  "            for rqtLectureEvIlo;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureEvIlo ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureEvIlo\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureSIRET ()                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche du type de          */\n" \
  "/*             SIRET a partir de la table GYTtabPagesPro                      */\n" \
  "/*                                                                        */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "extern int4 givPreparerLectureSIRET(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureSIRET\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_SIRET);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_SIRET);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureSIRET\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureSIRET\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureSIRET : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureSIRET\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureSIRET\n" \
  "            cursor\n" \
  "            for rqtLectureSIRET;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureSIRET ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureSIRET\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureOppositionPart ()                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             l'opposition à partir du partenaire dans table GYTtabOppPart   */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureOppositionPart(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureOppositionPart\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_OPP_PART);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_OPP_PART);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureOppPart\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureOppositionPart\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureOppositionPart : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureOppositionPart\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureOppPart\n" \
  "            cursor\n" \
  "            for rqtLectureOppPart;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureOppPart ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureOppositionPart\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureOppositionsURLGratuite ()            */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             l'opposition dans tables GYTTabURLGrOpp et GYTTabURLGrProf     */\n" \
  "/*             pour les contenus de type GS                                   */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureOppositionsURLGratuite(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureOppositionsURLGratuite\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_OPP_URLGR);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_OPP_URLGR);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureOppURLGr\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureOppURLGr\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureOppURLGr : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureOppURLGr\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureOppURLGr\n" \
  "            cursor\n" \
  "            for rqtLectureOppURLGr;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureOppURLGr ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_PROF_URLGR);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_PROF_URLGR);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureProfURLGr\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureProfURLGr\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureProfURLGr : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureProfURLGr\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureProfURLGr\n" \
  "            cursor\n" \
  "            for rqtLectureProfURLGr;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureProfURLGr ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureOppositionsURLGratuite\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLecturePrioProfCRC ()                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             priorité selon CRC et An8 dans table GYTTabCRCProfPrio         */\n" \
  "/*             pour les contenus                                              */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLecturePrioProfCRC(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLecturePrioProfCRC\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_PRIO_PROF_CRC);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_PRIO_PROF_CRC);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLecturePrioProfCRC\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLecturePrioProfCRC\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLecturePrioProfCRC : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLecturePrioProfCRC\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLecturePrioProfCRC\n" \
  "            cursor\n" \
  "            for rqtLecturePrioProfCRC;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLecturePrioProfCRC ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_BL_CRC_LR);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_BL_CRC_LR);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureBLCRCLR\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureBLCRCLR\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureBLCRCLR : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureBLCRCLR\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureBLCRCLR\n" \
  "            cursor\n" \
  "            for rqtLectureBLCRCLR;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureBLCRCLR ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_BL_EPJ_FD);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_BL_EPJ_FD);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureBLEPJFD\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureBLEPJFD\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureBLEPJFD : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureBLEPJFD\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureBLEPJFD\n" \
  "            cursor\n" \
  "            for rqtLectureBLEPJFD;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureBLEPJFD ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_BL_CRC_FD);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_BL_CRC_FD);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureBLCRCFD\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureBLCRCFD\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureBLCRCFD : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureBLCRCFD\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureBLCRCFD\n" \
  "            cursor\n" \
  "            for rqtLectureBLCRCFD;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureBLCRCFD ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_BL_EPJ_PROF);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_BL_EPJ_PROF);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureBLEPJProf\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureBLEPJProf\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureBLEPJProf : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureBLEPJProf\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureBLEPJProf\n" \
  "            cursor\n" \
  "            for rqtLectureBLEPJProf;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureBLEPJProf ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLecturePrioProfCRC\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerSynonyme ()                                               */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de                  */\n" \
  "/*             synomymes d'une dénomination                                   */\n" \
  "/*             dans la table GYTtabDenomSynonyme                              */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerSynonyme()\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[6 * giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerSynonyme\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)giv_LG_REQUETE);\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIVRequeteSyno);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        strcpy(cRequete, GIVRequeteSyno);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requete SQL Paruadr : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureSyno\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureSyno\");\n" \
  "        iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureSyno : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureSyno\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureSyno\n" \
  "            cursor\n" \
  "            for rqtLectureSyno;\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureSyno ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerSynonyme\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : supprimer_doublon                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : supprimer les doublons dans les champs de critere selection    */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : le buffer                                                      */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : le même buffer                                                 */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 supprimer_doublon(char* liste, char delim)\n" \
  "{\n" \
  "    char* pt_fin_liste;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_debut_doublon;\n" \
  "    char* pt_fin_doublon;\n" \
  "    int4 lg_element;\n" \
  "    int4 lg_doublon;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Taille buffer doublons : %d\\n\", strlen(liste)));\n" \
  "\n" \
  "    if (strlen(liste) >= sizeof(buf_concat))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Buffer doublons : %s\\n\", liste));\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Buffer doublons : %d,%s\\n\", strlen(buf_concat), buf_concat));\n" \
  "        return (strlen(liste));\n" \
  "    }\n" \
  "\n" \
  "    pt_fin_liste = liste + strlen(liste);\n" \
  "\n" \
  "    for (pt_debut_element = liste; pt_debut_element < pt_fin_liste;)\n" \
  "    {\n" \
  "        pt_fin_element = strchr(pt_debut_element, delim);\n" \
  "\n" \
  "        if (pt_fin_element == 0)\n" \
  "            pt_fin_element = pt_fin_liste;\n" \
  "        else\n" \
  "        {\n" \
  "            lg_element = pt_fin_element - pt_debut_element;\n" \
  "\n" \
  "            /* suppression des doublons */\n" \
  "            for (pt_debut_doublon = pt_fin_element + 1; pt_debut_doublon < pt_fin_liste;)\n" \
  "            {\n" \
  "                pt_fin_doublon = strchr(pt_debut_doublon, delim);\n" \
  "\n" \
  "                if (pt_fin_doublon == 0)\n" \
  "                {\n" \
  "                    pt_fin_doublon = pt_fin_liste;\n" \
  "                    lg_doublon = pt_fin_doublon - pt_debut_doublon;\n" \
  "\n" \
  "                    /* voir s'ils sont identique */\n" \
  "                    if ((lg_doublon == lg_element) && (strncmp(pt_debut_element, pt_debut_doublon, lg_element) == 0))\n" \
  "                    {\n" \
  "                        pt_fin_liste -= pt_fin_doublon - pt_debut_doublon + 1;\n" \
  "                        *pt_fin_liste = 0;\n" \
  "                        pt_debut_doublon = pt_fin_liste;\n" \
  "                    }\n" \
  "                    else\n" \
  "                        pt_debut_doublon = pt_fin_doublon + 1;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    /* voir s'ils sont identique */\n" \
  "                    lg_doublon = pt_fin_doublon - pt_debut_doublon;\n" \
  "\n" \
  "                    if ((lg_doublon == lg_element) && (strncmp(pt_debut_element, pt_debut_doublon, lg_element) == 0))\n" \
  "                    {\n" \
  "                        if (pt_fin_liste - pt_fin_doublon - 1 > 0)\n" \
  "                            memmove(pt_debut_doublon, pt_fin_doublon + 1, pt_fin_liste - pt_fin_doublon - 1);\n" \
  "\n" \
  "                        pt_fin_liste -= pt_fin_doublon + 1 - pt_debut_doublon;\n" \
  "                        *pt_fin_liste = 0;\n" \
  "                    }\n" \
  "                    else\n" \
  "                        pt_debut_doublon = pt_fin_doublon + 1;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        pt_debut_element = pt_fin_element + 1;\n" \
  "    }\n" \
  "\n" \
  "    return (pt_fin_liste - liste);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givPreparerLectureRJRUPR\n" \
  " *\n" \
  " * But : Prépération de la requête de lecture de la table rjrupr\n" \
  " *\n" \
  " * Description :\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureRJRUPR(void)\n" \
  "{\n" \
  "    int4 iCodRet = 0;\n" \
  "    int4 iIntRet = 0;\n" \
  "    GYBrParam_erreurT vErreurSQL;\n" \
  "    int4 iLgBuffer = 0;\n" \
  "    int4 iLgRequete = 0;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[300];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)300);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iDejaPrepare)\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureIAPROF\\n\"));\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIVRequeteLectureRJRUPR);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        strcpy(cRequete, GIVRequeteLectureRJRUPR);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requete SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureRJRUPR\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureRJRUPR\");\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur prepare rqtLectureRJRUPR : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureRJRUPR\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureRJRUPR\n" \
  "            cursor\n" \
  "            for rqtLectureRJRUPR;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur DECLARE crsLectureRJRUPR ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureIAPROF\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givPreparerLectureThemeED\n" \
  " *\n" \
  " * But : Prépération de la requête de lecture de la table ThemeED\n" \
  " *\n" \
  " * Description :\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureThemeED(void)\n" \
  "{\n" \
  "    int4 iCodRet = 0;\n" \
  "    int4 iIntRet = 0;\n" \
  "    GYBrParam_erreurT vErreurSQL;\n" \
  "    int4 iLgBuffer = 0;\n" \
  "    int4 iLgRequete = 0;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[300];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, (size_t)300);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iDejaPrepare)\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureThemeED\\n\"));\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIVRequeteLectureThemeED);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        strcpy(cRequete, GIVRequeteLectureThemeED);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requete SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureThemeED\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureThemeED\");\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur prepare rqtLectureThemeED : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureThemeED\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureThemeED\n" \
  "            cursor\n" \
  "            for rqtLectureThemeED;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur DECLARE crsLectureThemeED ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureThemeED\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureZU ()                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de zone urbaine     */\n" \
  "/*             a partir des codes dep et loc dans GYTTabPelzu                  */\n" \
  "/*                                                                        */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureZU(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, sizeof(cRequete));\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iDejaPrepare)\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureZU\\n\"));\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_ZU);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_ZU);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureZU\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureZU\");\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureZU : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureZU\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureZU\n" \
  "            cursor\n" \
  "            for rqtLectureZU;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureZU ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureZU\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureLocFus ()                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de localité         */\n" \
  "/*             fusionnée à partir des codes dep et loc dans GYTTabPelFusion   */\n" \
  "/*                                                                              */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureLocFus(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, sizeof(cRequete));\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iDejaPrepare)\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureLocFus\\n\"));\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_LOCFUS);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_LOCFUS);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureLocFus\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureLocFus\");\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureLocFus : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureLocFus\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureLocFus\n" \
  "            cursor\n" \
  "            for rqtLectureLocFus;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureLocFus ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureLocFus\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureCRC ()                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de CRC              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                        */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureCRC(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureCRC\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, sizeof(cRequete));\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_CRC);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        (void)sprintf(cRequete,\n" \
  "                      GIV_RQ_SELECT_CRC);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureCRC\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureCRC\");\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureCRC : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureCRC\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureCRC\n" \
  "            cursor\n" \
  "            for rqtLectureCRC;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureCRC ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureCRC\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givPreparerLectureRegion ()                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : Preparation de la requete SQL de recherche de région     */\n" \
  "/*             a partir du code dep dans LJDEPT                         */\n" \
  "/*                                                                        */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givPreparerLectureRegion(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)memset((void*)cRequete, 0x00, sizeof(cRequete));\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iDejaPrepare)\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureRegion\\n\"));\n" \
  "    /* Controle de la longueur du texte de la requete */\n" \
  "    iLgRequete = strlen(GIV_RQ_SELECT_NEW_REGION);\n" \
  "    iLgBuffer = sizeof(cRequete);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "    if (iLgBuffer <= iLgRequete)\n" \
  "    {\n" \
  "        /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Construction du texte de la requete */\n" \
  "    if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "    {\n" \
  "        if (0 == strcmp(givtcRegCECI, \"NON\"))\n" \
  "        {\n" \
  "            (void)sprintf(cRequete,\n" \
  "                          GIV_RQ_SELECT_REGION);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            (void)sprintf(cRequete,\n" \
  "                          GIV_RQ_SELECT_NEW_REGION);\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Requete SQL CECI : %s\\n\", cRequete));\n" \
  "        /* Controle et parsing de la requete SQL */\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectureRegion\n" \
  "        from: cRequete;\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureRegion\");\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureRegion : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureRegion\");\n" \
  "            EXEC SQL\n" \
  "            declare crsLectureRegion\n" \
  "            cursor\n" \
  "            for rqtLectureRegion;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureRegion ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givPreparerLectureRegion\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givLecAncBloc                                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : Récupération du blocid antérieur                               */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Surement portable                                              */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "int4 givLecAncBloc(char* apcNumnat, char* apcNumlo, char* apcNumls, char* apcBlocid)\n" \
  "{\n" \
  "    int4 iCodRet = (int4)GIV::GWZOk;\n" \
  "    int4 iIntRet = (int4)GIV::GYBok;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    GYBrParam_erreurT rErreurSQL;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char tcRequete[800];\n" \
  "    char* pcNumnat;\n" \
  "    char* pcNumlo;\n" \
  "    char* pcNumls;\n" \
  "    char cBlocid[27 + 1];\n" \
  "    int2 indicatrice_Blocid;\n" \
  "    int4 iNbIns;\n" \
  "    EXEC SQL\n" \
  "    VAR cBlocid\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "\n" \
  "    /* Préparer la requête */\n" \
  "    if ((int4)GIV::GWCCodeOK != iDejaPrepare)\n" \
  "    {\n" \
  "        (void)sprintf(tcRequete, GIV_RQ_SELECT_ANC_BLOC, GIXcNomFour, GIXcNomDest, GIXcDepartement, GIXcDepartement);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtLectAncBloc\n" \
  "        from: tcRequete;\n" \
  "        iIntRet = GIVBlocErreur(&rErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur prepare rqtLectAncBloc: [COD=%d TXT=%s]\\n\", iIntRet, rErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GWZKo;\n" \
  "        }\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        declare crsLectAncBloc\n" \
  "        cursor\n" \
  "        for rqtLectAncBloc;\n" \
  "        iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    /* initialisation des variables */\n" \
  "    if ((int4)GIV::GWZOk == iCodRet)\n" \
  "    {\n" \
  "        pcNumnat = apcNumnat;\n" \
  "        pcNumlo = apcNumlo;\n" \
  "        pcNumls = apcNumls;\n" \
  "    }\n" \
  "\n" \
  "    cBlocid[0] = '\\0';\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"LecAncBloc: <%s>,<%s>,<%s>\\n\", apcNumnat, apcNumlo, apcNumls));\n" \
  "\n" \
  "    /* Ouvrir le curseur */\n" \
  "    if (GIV::GWZOk == iCodRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        OPEN crsLectAncBloc\n" \
  "        USING :pcNumnat,:pcNumlo,:pcNumls;\n" \
  "        iIntRet = GIVBlocErreur(&rErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur open crsLectAncBloc: [COD=%d TXT=%s]\\n\", iIntRet, rErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GWZKo;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Récupération des indicateurs */\n" \
  "    if (GIV::GWZOk == iCodRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectAncBloc\n" \
  "        INTO: cBlocid: indicatrice_Blocid;\n" \
  "        iIntRet = GIVBlocErreur(&rErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur fetch crsLectAncBloc: [COD=%d TXT=%s]\\n\", iIntRet, rErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GWZKo;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* fermer le curseur */\n" \
  "    EXEC SQL\n" \
  "    close crsLectAncBloc;\n" \
  "    iIntRet = GIVBlocErreur(&rErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Erreur fermeture crsLectAncBloc: [COD=%d TXT=%s]\\n\", iIntRet, rErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GWZKo;\n" \
  "    }\n" \
  "\n" \
  "    if (((int2)GIV::GYBok != indicatrice_Blocid) || (GIV::GWZOk != iCodRet))\n" \
  "        apcBlocid[0] = '\\0';\n" \
  "    else\n" \
  "        strcpy(apcBlocid, cBlocid);\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureLibRub\n" \
  " *\n" \
  " * But : Conversion du type de voie en libélé de type de voie.\n" \
  " *\n" \
  " * Description : Lecture du libélé de type de voie correspondant au type de voie\n" \
  " *               dans la table GYTtabPetvoi.\n" \
  " *               En cas d'absence ddu type de voie dans la table GYTtabPetvoi\n" \
  " *               on prend le type de voie tel quel.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureLibRub(char* val_codan9)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iIdx, iLg;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    VARCHAR libelle_rub[300 + 1];\n" \
  "    VARCHAR codeAn9[8 + 1];\n" \
  "    int2 sLibCod_i = -1;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = givPreparerLectureRJRUPR();\n" \
  "    GIVBuffInter[0] = '\\0';\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "    {\n" \
  "        memset((char*)codeAn9.arr, ' ', sizeof(codeAn9.arr));\n" \
  "        memcpy((char*)codeAn9.arr, val_codan9, strlen(val_codan9));\n" \
  "        codeAn9.len = strlen(val_codan9);\n" \
  "    }\n" \
  "    else\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"code an9: <%s>,%d\\n\", val_codan9, strlen(val_codan9)));\n" \
  "\n" \
  "    if (GIV::GIXCodeOK == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        OPEN crsLectureRJRUPR\n" \
  "        USING: codeAn9;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureRJRUPR: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iIntRet = (int4)GIV::GWZKo;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (GIV::GIXCodeOK == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureRJRUPR\n" \
  "        INTO: libelle_rub: sLibCod_i;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            if (GIV::GYBnodata == iIntRet)\n" \
  "                iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur fetch crsLectureRJRUPR: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            memcpy(GIVBuffInter, (char*)libelle_rub.arr, libelle_rub.len);\n" \
  "            GIVBuffInter[libelle_rub.len] = '\\0';\n" \
  "\n" \
  "            if ((int4)GIV::GWCCodeOK == giviPart)\n" \
  "            {\n" \
  "                iLg = libelle_rub.len;\n" \
  "                GIVBuffInter[iLg] = '\\0';\n" \
  "            }\n" \
  "\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"libellé de rub: <%s>,%d\\n\", GIVBuffInter, libelle_rub.len));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureRJRUPR;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureRJRUPR: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureLibLocAtt\n" \
  " *\n" \
  " * But : localite de rattachement.\n" \
  " *\n" \
  " * Description : Lecture du libéllé de localité de rattachement\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureLibLocAtt(char** buf_pos_in, char* apcDepLocInst, char* apcEtab)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPelrepT* pvCodloc;\n" \
  "    GYBrIndPelrepT* pvIndCodloc;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    char* buf_pos;\n" \
  "    int4 lg_write;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givLectureLibLocAtt\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Valorisation du pointeur vers la structure de description de la table PAYS */\n" \
  "    pvCodloc = &GIVvLocrep;\n" \
  "    pvIndCodloc = &GIVvIndLocrep;\n" \
  "    /* Valorisation du pointeur vers la structure de description */\n" \
  "    /*   du tableau de recuperation des correspondances AN8/AN9 */\n" \
  "    (void)memcpy(pvCodloc->acDepart, &apcDepLocInst[0], GYBIeinscLgDeppar);\n" \
  "    pvCodloc->acDepart[GYBIeinscLgDeppar] = '\\0';\n" \
  "    (void)strcpy(pvCodloc->acNumloc, &apcDepLocInst[GYBIeinscLgDeppar]);\n" \
  "    /* Ouverture curseur SQL (car requete type SELECT) */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureLocAtt\");\n" \
  "    EXEC SQL\n" \
  "    open crsLectureLocAtt\n" \
  "    using :pvCodloc->acDepart,\n" \
  "    :pvCodloc->acNumloc;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur declaration curseur SQL */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur open rqtLectureLocAtt : [COD=%d TXT=%s EPJ=%s LOC=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcDepLocInst));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        pipe = 0;\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureLocAtt\");\n" \
  "            EXEC SQL\n" \
  "            fetch crsLectureLocAtt\n" \
  "            into\n" \
  "            :pvCodloc->acLibloc\n" \
  "            :pvIndCodloc->sLiblocI;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            /* Analyse du code retour SQL */\n" \
  "            switch (iIntRet)\n" \
  "            {\n" \
  "            case (int4)GIV::GYBok:\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "                if (pipe == 0)\n" \
  "                    pipe = 1;\n" \
  "\n" \
  "                lg_write = giv_ecrit_balise(buf_pos, GIVvLocrep.acLibloc, \"liblocatt\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            case (int4)GIV::GYBnodata:\n" \
  "            {\n" \
  "                /* la localite n'existe pas */\n" \
  "                /* generer une signalisation */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            default:\n" \
  "            {\n" \
  "                /* la consultation de la base s'est mal passee */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur execute rqtLectureLocAtt : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                break;\n" \
  "            }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        /* Fermeture du curseur */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"close crsLectureLocAtt\");\n" \
  "        EXEC SQL\n" \
  "        close crsLectureLocAtt;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur fermeture curseur SQL */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur CLOSE crsLectureLocAtt ...\\n\"));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GIVLectureLibLocAtt\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureLocDep\n" \
  " *\n" \
  " * But : localite d'un département.\n" \
  " *\n" \
  " * Description : Lecture du libéllé de localité de rattachement\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureLocDep(char* apcDep, int4* apiAjout)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPelrepT* pvCodloc;\n" \
  "    GYBrIndPelrepT* pvIndCodloc;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givLectureLocDep\\n\"));\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "    /* Valorisation du pointeur vers la structure de description de la table PAYS */\n" \
  "    pvCodloc = &GIVvLocrep;\n" \
  "    pvIndCodloc = &GIVvIndLocrep;\n" \
  "    /* Valorisation du pointeur vers la structure de description */\n" \
  "    /*   du tableau de recuperation des correspondances AN8/AN9 */\n" \
  "    (void)strcpy(pvCodloc->acDepart, apcDep);\n" \
  "    /* Ouverture curseur SQL (car requete type SELECT) */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureLocDep\");\n" \
  "    EXEC SQL\n" \
  "    open crsLectureLocDep\n" \
  "    using :pvCodloc->acDepart;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur declaration curseur SQL */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur OPEN crsLectureLocDep ...\\n\"));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureLocDep\");\n" \
  "            EXEC SQL\n" \
  "            fetch crsLectureLocDep\n" \
  "            into\n" \
  "            :pvCodloc->acNumloc\n" \
  "            :pvIndCodloc->sNumlocI;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            /* Analyse du code retour SQL */\n" \
  "            switch (iIntRet)\n" \
  "            {\n" \
  "            case (int4)GIV::GYBok:\n" \
  "            {\n" \
  "                if (0 == *apiAjout)\n" \
  "                {\n" \
  "                    strcpy(buf_concat, apcDep);\n" \
  "                    *apiAjout = 1;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    strcat(buf_concat, \"|\");\n" \
  "                    strcat(buf_concat, apcDep);\n" \
  "                }\n" \
  "\n" \
  "                strcat(buf_concat, GIVvLocrep.acNumloc);\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            case (int4)GIV::GYBnodata:\n" \
  "            {\n" \
  "                /* fin */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            default:\n" \
  "            {\n" \
  "                /* la consultation de la base s'est mal passee */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur execute rqtLectureLocDep : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                break;\n" \
  "            }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        /* Fermeture du curseur */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"close crsLectureLocDep\");\n" \
  "        EXEC SQL\n" \
  "        close crsLectureLocDep;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur fermeture curseur SQL */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur CLOSE crsLectureLocDep ...\\n\"));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givLectureLocDep %s\\n\", buf_concat));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureThemeRub\n" \
  " *\n" \
  " * But : theme de rubrique.\n" \
  " *\n" \
  " * Description : Lecture du theme d'une rubrique\n" \
  " *               dans la table GYTtabThemeED.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureThemeED(char* val_codan9)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iIdx;\n" \
  "    int4 j;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char theme_rub;\n" \
  "    char codeAn9[8 + 1];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    iIntRet = givPreparerLectureThemeED();\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "        strcpy(&codeAn9[0], val_codan9);\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"code an9: <%s>,%d\\n\", val_codan9, strlen(val_codan9)));\n" \
  "\n" \
  "    if (GIV::GIXCodeOK == iIntRet)\n" \
  "    {\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureThemeED\");\n" \
  "        EXEC SQL\n" \
  "        OPEN crsLectureThemeED\n" \
  "        USING: codeAn9;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureThemeED: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iIntRet = (int4)GIV::GWZKo;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (GIV::GIXCodeOK == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureThemeED\n" \
  "        INTO: theme_rub;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            if (GIV::GYBnodata == iIntRet)\n" \
  "                iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur fetch crsLectureThemeED: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            buf_concat[0] = theme_rub;\n" \
  "            buf_concat[1] = '\\0';\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"theme de rub: <%s>\\n\", buf_concat));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureThemeED;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureThemeED: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureTypeURL\n" \
  " *\n" \
  " * But : type de l'URL.\n" \
  " *\n" \
  " * Description : Lecture du type d'URL\n" \
  " *               dans la table GYTtabPemicURL.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureTypeURL(GYBrIamicT* aprIamic, GYBrIndIamicT* aprIndIamic)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 i, j;\n" \
  "    size_t lgInter, lg_in;\n" \
  "    iconv_t iConv;\n" \
  "    char* buf_in;\n" \
  "    char* buf_out;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIamicT* prOraIamic;\n" \
  "    GYBrIndIamicT* prOraIndIamic;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    prOraIamic = aprIamic;\n" \
  "    prOraIndIamic = aprIndIamic;\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureTypeURL\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureTypeURL\n" \
  "    USING :prOraIamic->acNumobj,\n" \
  "    :prOraIamic->acTypobj,\n" \
  "    :prOraIamic->acTpdsob;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureTypeURL: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureTypeURL\n" \
  "        INTO\n" \
  "        :prOraIamic->acTpdUrl\n" \
  "        :prOraIndIamic->sTpdUrlI,\n" \
  "        :prOraIamic->acLibUrl:prOraIndIamic->sLibUrlI;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureTypeURL;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if (((int4)GIV::GYBok != iIntRet) || ((int4)GIV::GYBok != prOraIndIamic->sLibUrlI))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureTypeURL: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "        givConvURL(aprIamic->acLibUrl);\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureImag\n" \
  " *\n" \
  " * But : nombre d'images d'un produit PVI.\n" \
  " *\n" \
  " * Description : Lecture du nombre\n" \
  " *               dans la table GYTtabPVIMAG.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureImag(GYBrIamicT* aprIamic, char* prNbimag, char* prImagCat, char* pcMenu)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iIdx;\n" \
  "    int4 j;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIamicT* prOraIamic;\n" \
  "    char prOraRef[20];\n" \
  "    int2 sIndic;\n" \
  "    char tcOraRef[2];\n" \
  "    char cOraMenu;\n" \
  "    EXEC SQL\n" \
  "    VAR prOraRef\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    prOraIamic = aprIamic;\n" \
  "    prNbimag[0] = '\\0';\n" \
  "    prImagCat[0] = '\\0';\n" \
  "    tcOraRef[0] = '\\0';\n" \
  "    prOraRef[0] = '\\0';\n" \
  "    pcMenu[0] = '\\0';\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureImag\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureImag\n" \
  "    USING: prOraIamic->acNumobj;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureImag: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureImag\n" \
  "        INTO\n" \
  "        :prOraRef:sIndic, :tcOraRef, :cOraMenu;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        else\n" \
  "        {\n" \
  "            strcpy(prNbimag, prOraRef);\n" \
  "            strcpy(prImagCat, tcOraRef);\n" \
  "            *pcMenu = cOraMenu;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureImag;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureImag: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Imag: %s, %s, %c\\n\", prOraIamic->acNumobj, prNbimag, pcMenu));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureMotsCles\n" \
  " *\n" \
  " * But : crc mots cles\n" \
  " *\n" \
  " * Description : lecture terme de cri\n" \
  " *               dans la table GYTtabMotsClesCri.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureMotsCles(GYBrIamicT* aprIamic)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 i, j;\n" \
  "    char tcAn9Courant[GYBPaprofLgCodan9 + 1];\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIamicT* prOraIamic;\n" \
  "    GYBrIaprofT prOraIaprof;\n" \
  "    GYBstrMClesCriAnnotT tcAnnotMCle; /* annotation mots clés */\n" \
  "    GYBstrMClesCriIdT tcIdMCle;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    prOraIamic = aprIamic;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureMCles\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureMCles\n" \
  "    USING: prOraIamic->acNumobj;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureMCles: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Objet Mot Clé cherché : '%s'\\n\", prOraIamic->acNumobj));\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureMCles\n" \
  "            INTO\n" \
  "            :tcIdMCle,\n" \
  "            :prOraIaprof.acCodan8,\n" \
  "            :tcAnnotMCle;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            switch (iIntRet)\n" \
  "            {\n" \
  "            case (int4)GIV::GYBok:\n" \
  "            {\n" \
  "                if (NULL != strstr(GIVBuffClob, tcIdMCle))\n" \
  "                    break;\n" \
  "\n" \
  "                /* recherche de la rubrique de CRI parmi les rubriques du bloc */\n" \
  "                i = 0;\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Critère Mot Clé trouvé : '%s', '%s'\\n\", tcIdMCle, prOraIaprof.acCodan8));\n" \
  "                strcpy(tcAn9Courant, givcR00000000);\n" \
  "\n" \
  "                for (i = 0; i < (givrListParu.iNbr); i++)\n" \
  "                {\n" \
  "                    j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                    if (0 != strcmp(tcAn9Courant, givrListParu.trEltList[j].rub))\n" \
  "                    {\n" \
  "                        strcpy(tcAn9Courant, givrListParu.trEltList[j].rub);\n" \
  "\n" \
  "                        if (0 == strcmp(prOraIaprof.acCodan8, givrListParu.trEltList[j].rubinit))\n" \
  "                            break;\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                if ((givrListParu.iNbr != i) && (0 != strcmp(givcR000000, prOraIaprof.acCodan8)))\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Critère Mot Clé validé : '%s', '%s'\\n\", tcIdMCle, prOraIaprof.acCodan8));\n" \
  "                    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "                    if ((int4)sizeof(GIVBuffInter) <= ((int4)strlen(GIVBuffInter) + (int4)strlen(tcAnnotMCle)))\n" \
  "                    {\n" \
  "                        /* fin car buffer insuffisant */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"Buffer lecture CRI Mots Clés insuffisant : %d, %s\\n\", (int4)strlen(GIVBuffInter), prOraIamic->acNumobj));\n" \
  "                        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                        indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    (void)strcat(GIVBuffInter, tcAnnotMCle);\n" \
  "\n" \
  "                    if ((int4)sizeof(GIVBuffClob) <= ((int4)strlen(GIVBuffClob) + (int4)strlen(tcIdMCle)))\n" \
  "                    {\n" \
  "                        /* fin car buffer insuffisant */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"Buffer lecture ID Mots Clés insuffisant : %d, %s\\n\", (int4)strlen(GIVBuffClob), prOraIamic->acNumobj));\n" \
  "                        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                        indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (0 == strlen(GIVBuffClob))\n" \
  "                        strcpy(GIVBuffClob, tcIdMCle);\n" \
  "                    else\n" \
  "                    {\n" \
  "                        strcat(GIVBuffClob, \"|\");\n" \
  "                        strcat(GIVBuffClob, tcIdMCle);\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            case (int4)GIV::GYBnodata:\n" \
  "            {\n" \
  "                /* il n'existe pas ou plus de liens */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            default:\n" \
  "            {\n" \
  "                /* la consultation de la base s'est mal passee */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur execute rqtLectureMCles : [COD=%d TXT=%s] [numobj=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour, prOraIamic->acNumobj));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                break;\n" \
  "            }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureMCles;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureMCles: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"MotsCles: %d, %s\\n\", iCodRet, tcAnnotMCle));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureEtabDonSupp\n" \
  " *\n" \
  " * But : données enrichies, données additionnelles.\n" \
  " *\n" \
  " * Description : lecture\n" \
  " *               dans la table GYTtabPeetab ou  GYTtabDonAddEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureEtabDonSupp(char* apcEtab, char* apcObj, char* apcTyp, char* apcSource)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour des appels internes */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraEtab;\n" \
  "    char* pcOraObj;\n" \
  "    char* pcOraTyp;\n" \
  "    char* pcOraSce;\n" \
  "    OCIClobLocator* pClob;\n" \
  "    static int4 iLgEcrit = 0;\n" \
  "    char tcRequete[800];\n" \
  "    nat8 length;\n" \
  "    int2 sInd, sIndic;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    GIVBuffInter[0] = '\\0';\n" \
  "    /* init CLOB PeEtab */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"Allocate de CLOB\");\n" \
  "    EXEC SQL\n" \
  "    ALLOCATE: pClob;\n" \
  "    EXEC SQL\n" \
  "    LOB CREATE\n" \
  "    TEMPORARY: pClob;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Allocation CLOB pour GYTtabPeEtab\\n\"));\n" \
  "\n" \
  "    /* Analyse du code resultat SQL */\n" \
  "    if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "    {\n" \
  "        iCodRet = iIntRet;\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"Prepare SlcDonSupp\");\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iDejaPrepare)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Préparation accès clob pour GYTtabPeEtab\\n\"));\n" \
  "        iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_DONENR);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcDonEnr\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcDonEnr\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcDonEnr;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_DONREL);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcDonRel\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcDonRel\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcDonRel;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_DONADD);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcDonRes\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcDonRes\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcDonRes;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_DONADD_GCEN);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcDonGC\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcDonGC\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcDonGC;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_ANNONC);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcContAnnc\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcContAnnc\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcContAnnc;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_ETAB);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcContEtab\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcContEtab\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcContEtab;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_ANNOT);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcContAnot\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcContAnot\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcContAnot;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_DHNA);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcDonDHNA\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcDonDHNA\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcDonDHNA;\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_DHNE);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcDonDHNE\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcDonDHNE\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcDonDHNE;\n" \
  "    }\n" \
  "\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"SlcDonSupp\");\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Ouverture SlcDonSupp\\n\"));\n" \
  "\n" \
  "    if (0 == strcmp(giv_HPN, apcSource))\n" \
  "    {\n" \
  "        pcOraTyp = apcTyp;\n" \
  "        pcOraObj = apcObj;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcDonDHNA\n" \
  "        using :pcOraTyp,:pcOraObj;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcDonDHNA: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcObj));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcDonDHNA\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_HGN, apcSource))\n" \
  "    {\n" \
  "        pcOraEtab = apcEtab;\n" \
  "        pcOraTyp = apcTyp;\n" \
  "        pcOraObj = apcObj;\n" \
  "\n" \
  "        if (0 == strcmp(apcTyp, \"DE\"))\n" \
  "        {\n" \
  "            sIndic = (int2) - 1;\n" \
  "            pcOraObj = NULL;\n" \
  "        }\n" \
  "        else\n" \
  "            sIndic = (int2)0;\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        open crsSlcDonDHNE\n" \
  "        using :pcOraEtab,:pcOraTyp,:pcOraObj:sIndic;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcDonDHNE: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcDonDHNE\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strlen(apcEtab))\n" \
  "    {\n" \
  "        pcOraObj = apcObj;\n" \
  "        pcOraTyp = apcTyp;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcContAnnc\n" \
  "        using :pcOraObj, :pcOraTyp;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcContAnnc: [COD=%d TXT=%s] %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcObj, apcTyp));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcContAnnc\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_EPJ, apcSource))\n" \
  "    {\n" \
  "        pcOraEtab = apcEtab;\n" \
  "        pcOraObj = apcObj;\n" \
  "        pcOraTyp = apcTyp;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcContEtab\n" \
  "        using :pcOraEtab, :pcOraTyp, :pcOraObj;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcContEtab: [COD=%d TXT=%s] %s, %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcContEtab\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ANO, apcSource))\n" \
  "    {\n" \
  "        pcOraEtab = apcEtab;\n" \
  "        pcOraObj = apcObj;\n" \
  "        pcOraTyp = apcTyp;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcContAnot\n" \
  "        using :pcOraEtab, :pcOraTyp, :pcOraObj;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcContAnot: [COD=%d TXT=%s] %s, %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcContAnot\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ENR, apcSource))\n" \
  "    {\n" \
  "        pcOraEtab = apcEtab;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcDonEnr\n" \
  "        using :pcOraEtab;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcDonEnr: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcDonEnr\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_REL, apcSource))\n" \
  "    {\n" \
  "        pcOraEtab = apcEtab;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcDonRel\n" \
  "        using :pcOraEtab;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcDonRel: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcDonRel\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ADD, apcSource))\n" \
  "    {\n" \
  "        pcOraEtab = apcEtab;\n" \
  "        pcOraTyp = apcTyp;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcDonRes\n" \
  "        using :pcOraEtab, :pcOraTyp;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcDonRes: [COD=%d TXT=%s] %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcTyp));\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcDonRes\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ADG, apcSource))\n" \
  "    {\n" \
  "        pcOraEtab = apcEtab;\n" \
  "        pcOraTyp = apcTyp;\n" \
  "        EXEC SQL\n" \
  "        open crsSlcDonGC\n" \
  "        using :pcOraEtab, :pcOraTyp;\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcDonGC\n" \
  "        into: pClob: sInd;\n" \
  "    }\n" \
  "    else\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur ouverture curseur : %s,%s,-%s-,-%s-\\n\", apcTyp, apcSource, apcEtab, apcObj));\n" \
  "\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    /* Analyse du code resultat SQL */\n" \
  "    if (((int4)GIV::GWCCodeOK != iIntRet) || (NULL == pClob))\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "\n" \
  "    iLgEcrit = 0;\n" \
  "\n" \
  "    if (((int4)GIV::GWCCodeOK == iIntRet) && ((int4)GIV::GYBok == sInd))\n" \
  "    {\n" \
  "        /* lecture des données xmltype */\n" \
  "        EXEC SQL\n" \
  "        LOB\n" \
  "        OPEN :pClob READ\n" \
  "        ONLY;\n" \
  "        givLectClob(pClob, apcEtab, apcObj, apcTyp, apcSource);\n" \
  "        iLgEcrit = strlen(GIVBuffInter);\n" \
  "        /* conversion du XMLType */\n" \
  "        (void)givConvClob();\n" \
  "        EXEC SQL\n" \
  "        LOB\n" \
  "        CLOSE: pClob;\n" \
  "    }\n" \
  "\n" \
  "    if (0 == strcmp(giv_HPN, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcDonDHNA;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcDonDHNA: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcObj));\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_HGN, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcDonDHNE;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcDonDHNE: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));\n" \
  "    }\n" \
  "    else if (0 == strlen(apcEtab))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcContAnnc;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcContAnnc: [COD=%d TXT=%s] %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcObj, apcTyp));\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_EPJ, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcContEtab;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcContEtab: [COD=%d TXT=%s] %s, %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ANO, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcContAnot;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcContAnot: [COD=%d TXT=%s] %s, %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcObj, apcTyp));\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ENR, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcDonEnr;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcDonEnr: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_REL, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcDonRel;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcDonRel: [COD=%d TXT=%s] %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ADD, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcDonRes;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur close crsSlcDonRes: [COD=%d TXT=%s] %s, %s\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab, apcTyp));\n" \
  "    }\n" \
  "    else if (0 == strcmp(giv_ADG, apcSource))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcDonGC;\n" \
  "    }\n" \
  "    else\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur fermeture curseur : %s,%s,-%s-,-%s-\\n\", apcTyp, apcSource, apcEtab, apcObj));\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Liberation CLOB pour GYTtabPeEtab\\n\"));\n" \
  "    /* liberation CLOB */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"Liberation de CLOB\");\n" \
  "    EXEC SQL\n" \
  "    LOB FREE\n" \
  "    TEMPORARY: pClob;\n" \
  "    EXEC SQL\n" \
  "    FREE: pClob;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    /* Analyse du code resultat SQL */\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur libération Clob PeEtab\\n\"));\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"EtabDonSupp: %d, %s\\n\", strlen(GIVBuffInter), GIVBuffInter));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLecturePartEtab\n" \
  " *\n" \
  " * But : données enrichies.\n" \
  " *\n" \
  " * Description : lecture\n" \
  " *               dans la table GYTtabPartEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLecturePartEtab(GYBrIapartT* apIapart, int4 aiClob)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    static OCIClobLocator* pClob1;\n" \
  "    static OCIClobLocator* pClob2;\n" \
  "    static int2 sInd1I;\n" \
  "    static int2 sInd2I;\n" \
  "    OCIClobLocator* pClob;\n" \
  "    char tcRequete[800];\n" \
  "    nat8 length;\n" \
  "    GYBrIapartT rIapart;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iLgEcrit;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    iLgEcrit = 0;\n" \
  "    GIVBuffInter[0] = '\\0';\n" \
  "    iCodRet = (int4)GIV::GWCCodeOK;\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iDejaPrepare)\n" \
  "    {\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"SlcPartEtab\");\n" \
  "        (void)sprintf(tcRequete, GIV_SLC_CLOB_PART);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtSlcPart\n" \
  "        from: tcRequete;\n" \
  "        EXEC SQL\n" \
  "        DECLARE crsSlcPart\n" \
  "        CURSOR FOR\n" \
  "        rqtSlcPart;\n" \
  "        iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    if (GIV::GIXCodeOK == aiClob)\n" \
  "    {\n" \
  "        /* init CLOB PeEtab */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Allocate de CLOB1\");\n" \
  "        sInd1I = (int4)GIV::GYBnok;\n" \
  "        sInd2I = (int4)GIV::GYBnok;\n" \
  "        EXEC SQL\n" \
  "        ALLOCATE: pClob1;\n" \
  "        EXEC SQL\n" \
  "        LOB CREATE\n" \
  "        TEMPORARY: pClob1;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Allocation CLOB pour GYTtabPartEtab\\n\"));\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "        {\n" \
  "            iCodRet = iIntRet;\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Allocate de CLOB2\");\n" \
  "        EXEC SQL\n" \
  "        ALLOCATE: pClob2;\n" \
  "        EXEC SQL\n" \
  "        LOB CREATE\n" \
  "        TEMPORARY: pClob2;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Allocation CLOB pour GYTtabPartEtab\\n\"));\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            LOB FREE\n" \
  "            TEMPORARY: pClob1;\n" \
  "            EXEC SQL\n" \
  "            FREE: pClob1;\n" \
  "            iCodRet = iIntRet;\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        (void)strcpy(rIapart.acOriPart, apIapart->acOriPart);\n" \
  "        (void)strcpy(rIapart.acRefPart, apIapart->acRefPart);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"GYTtabPartEtab : %s,%s\\n\", apIapart->acOriPart, apIapart->acRefPart));\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"SlcPartEtab\");\n" \
  "        EXEC SQL\n" \
  "        open crsSlcPart\n" \
  "        using :rIapart.acOriPart, :rIapart.acRefPart;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsSlcPart: [COD=%d TXT=%s] %s,%s\\n\", iIntRet, vErreurSQL.acDonnees_retour, rIapart.acOriPart, rIapart.acRefPart));\n" \
  "            iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "            EXEC SQL\n" \
  "            LOB FREE\n" \
  "            TEMPORARY: pClob1;\n" \
  "            EXEC SQL\n" \
  "            FREE: pClob1;\n" \
  "            EXEC SQL\n" \
  "            LOB FREE\n" \
  "            TEMPORARY: pClob2;\n" \
  "            EXEC SQL\n" \
  "            FREE: pClob2;\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        fetch crsSlcPart\n" \
  "        into :pClob1:sInd1I, :pClob2:sInd2I;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if (((int4)GIV::GWCCodeOK != iIntRet) || (((int4)GIV::GYBok != sInd1I) && ((int4)GIV::GYBok != sInd2I)))\n" \
  "        {\n" \
  "            iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "            EXEC SQL\n" \
  "            close crsSlcPart;\n" \
  "            EXEC SQL\n" \
  "            LOB FREE\n" \
  "            TEMPORARY: pClob1;\n" \
  "            EXEC SQL\n" \
  "            FREE: pClob1;\n" \
  "            EXEC SQL\n" \
  "            LOB FREE\n" \
  "            TEMPORARY: pClob2;\n" \
  "            EXEC SQL\n" \
  "            FREE: pClob2;\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((GIV::GIXCodeOK == aiClob) && ((int4)GIV::GYBok == sInd1I))\n" \
  "    {\n" \
  "        pClob = pClob1;\n" \
  "        EXEC SQL\n" \
  "        LOB\n" \
  "        OPEN :pClob1 READ\n" \
  "        ONLY;\n" \
  "    }\n" \
  "    else if ((GIV::GIXCodeOK != aiClob) && ((int4)GIV::GYBok == sInd2I))\n" \
  "    {\n" \
  "        pClob = pClob2;\n" \
  "        EXEC SQL\n" \
  "        LOB\n" \
  "        OPEN :pClob2 READ\n" \
  "        ONLY;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Pas de donnée xmltype %d\\n\", aiClob));\n" \
  "\n" \
  "        if (GIV::GIXCodeOK != aiClob)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            close crsSlcPart;\n" \
  "            EXEC SQL\n" \
  "            LOB FREE\n" \
  "            TEMPORARY: pClob1;\n" \
  "            EXEC SQL\n" \
  "            FREE: pClob1;\n" \
  "            EXEC SQL\n" \
  "            LOB FREE\n" \
  "            TEMPORARY: pClob2;\n" \
  "            EXEC SQL\n" \
  "            FREE: pClob2;\n" \
  "        }\n" \
  "\n" \
  "        iCodRet = (int4)GIV::GWCCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* lecture des données xmltype */\n" \
  "    givLectClob(pClob, apIapart->acOriPart, apIapart->acRefPart, giv_PRT, giv_PRT);\n" \
  "    /* conversion du XMLType */\n" \
  "    (void)givConvClob();\n" \
  "    GIVBuffXML[0] = '\\0';\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"PartEtab: %d, %s\\n\", strlen(GIVBuffInter), GIVBuffInter));\n" \
  "\n" \
  "    if (GIV::GIXCodeOK == aiClob)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        LOB\n" \
  "        CLOSE: pClob1;\n" \
  "    }\n" \
  "    else if (GIV::GIXCodeOK != aiClob)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsSlcPart;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Liberation CLOB pour GYTtabPartEtab\\n\"));\n" \
  "        /* liberation CLOB */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Liberation de CLOB\");\n" \
  "        EXEC SQL\n" \
  "        LOB FREE\n" \
  "        TEMPORARY: pClob1;\n" \
  "        EXEC SQL\n" \
  "        FREE: pClob1;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur libération Clob PartEtab\\n\"));\n" \
  "        }\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        LOB\n" \
  "        CLOSE: pClob2;\n" \
  "        EXEC SQL\n" \
  "        LOB FREE\n" \
  "        TEMPORARY: pClob2;\n" \
  "        EXEC SQL\n" \
  "        FREE: pClob2;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur libération Clob PartEtab\\n\"));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureEtabMC\n" \
  " *\n" \
  " * But : type de l'URL.\n" \
  " *\n" \
  " * Description : Lecture des données de niveau inscription\n" \
  " *               dans la table GYTtabPeeatb.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureEtabMC(char* apcEtab, char acPar, char** buf_pos_in)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 lg_ecr, iIdx, j;\n" \
  "    char* buf_pos;\n" \
  "    static char tcEtab[GYBIeinscLgEtab2] = \"\"; /* code etablissement */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    static GYBrPeEtabT rEtab;\n" \
  "    static GYBrIndPeEtabT rIndEtab;\n" \
  "    static char tcCount[6];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    lg_ecr = 0;\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    if (0 != strcmp(tcEtab, apcEtab))\n" \
  "    {\n" \
  "        /* changement d'etab */\n" \
  "        strcpy(tcEtab, apcEtab);\n" \
  "        strcpy(rEtab.acEtab, apcEtab);\n" \
  "        strcpy(tcCount, \"00000\");\n" \
  "        rIndEtab.copysLibUrlI(GIV::GYBnok);\n" \
  "\n" \
  "        /* Traitement des erreurs SQL */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureEtabMC\");\n" \
  "        EXEC SQL\n" \
  "        OPEN crsLectureEtabMC\n" \
  "        USING: rEtab.acEtab;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureEtabMC: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureEtabMC\n" \
  "            INTO\n" \
  "            :rEtab.acSiret\n" \
  "            :rIndEtab.sSiretI,\n" \
  "            :rEtab.acLibUrl:rIndEtab.sLibUrlI,\n" \
  "            :rEtab.acTefEt:rIndEtab.sTefEtI,\n" \
  "            :rEtab.acTefEn:rIndEtab.sTefEnI,\n" \
  "            :rEtab.acSiege:rIndEtab.sSiegeI,\n" \
  "            :rEtab.acCJ:rIndEtab.sCJI,\n" \
  "            :rEtab.acLibCJ:rIndEtab.sLibCJI,\n" \
  "            :rEtab.acLibAPE:rIndEtab.sLibAPEI,\n" \
  "            :rEtab.acDat:rIndEtab.sDatI;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "        }\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        close crsLectureEtabMC;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureEtabMC: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == rIndEtab.sSiretI)\n" \
  "        {\n" \
  "            /* utilisation de siren (9 car de siret) */\n" \
  "            rEtab.acSiret[9] = '\\0';\n" \
  "            /* Traitement des erreurs SQL */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureSiren\");\n" \
  "            EXEC SQL\n" \
  "            OPEN crsLectureSiren\n" \
  "            USING: rEtab.acSiret;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureSiren: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                EXEC SQL\n" \
  "                FETCH crsLectureSiren\n" \
  "                INTO: tcCount;\n" \
  "                iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "                EXEC SQL\n" \
  "                close crsLectureSiren;\n" \
  "                iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != iIntRet)\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureSiren: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ('0' == acPar)\n" \
  "    {\n" \
  "        rIndEtab.copyValues(GIV::GYBnok);\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sLibUrlI)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acLibUrl, \"etaburl\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sTefEtI)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acTefEt, \"eta_tefet\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sTefEnI)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acTefEn, \"eta_tefen\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    if (((int4)GIV::GYBok == rIndEtab.sSiegeI) && ('0' == rEtab.acSiege))\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, \"0\", \"eta_siege\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "    else if ((int4)GIV::GYBok == rIndEtab.sSiegeI)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, \"1\", \"eta_siege\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sCJI)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acCJ, \"eta_cj\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sSiretI)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, rEtab.acSiret, \"siren\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, tcCount, \"nbetsiren\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sLibCJI)\n" \
  "        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acLibCJ, \"eta_cjlib\");\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sLibAPEI)\n" \
  "        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acLibAPE, \"libape\");\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == rIndEtab.sDatI)\n" \
  "        lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acDat, \"dtcreentr\");\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureSynonyme\n" \
  " *\n" \
  " * But : synonymes de dénomination.\n" \
  " *\n" \
  " * Description : Lecture des données de niveau bloc\n" \
  " *               dans la table GYTtabDenomSynonyme.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureSynonyme(GYBrDOCUMENTEpj* doc, char** buf_pos_in, int4 aiRang, int4 aIndice)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    char* buf_pos;\n" \
  "    int4 lg_ecr;\n" \
  "    int4 i, j;\n" \
  "    int4 iDeb;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrDenomSynoT rOraSyno;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    iDeb = 1;\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    strcpy(rOraSyno.acDenom, (doc + aiRang)->value.intitule.denomination);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureSyno\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureSyno\n" \
  "    USING: rOraSyno.acDenom;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureSyno: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureSyno\");\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureSyno\n" \
  "            INTO\n" \
  "            :rOraSyno.acCodan8,\n" \
  "            :rOraSyno.acSyno;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Syno : %s, %s\\n\", rOraSyno.acCodan8, rOraSyno.acSyno));\n" \
  "\n" \
  "                for (i = 0; i < aIndice; i++)\n" \
  "                {\n" \
  "                    if ((doc + aiRang)->value.intitule.iRgDnom == (doc + i)->value.intitule.iRgDnom)\n" \
  "                    {\n" \
  "                        for (j = 0; j < (doc + i)->value.rubriques.iNban9; j++)\n" \
  "                        {\n" \
  "                            if (0 == strcmp((doc + i)->value.rubriques.Tan9[j].val_codan8, rOraSyno.acCodan8))\n" \
  "                                break;\n" \
  "                        }\n" \
  "\n" \
  "                        if ((doc + i)->value.rubriques.iNban9 != j)\n" \
  "                            break;\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                if (aIndice != i)\n" \
  "                {\n" \
  "                    if (1 == iDeb)\n" \
  "                    {\n" \
  "                        lg_ecr = giv_ecrit_noeud_simple(buf_pos, \"synonymes\");\n" \
  "                        buf_pos = buf_pos + lg_ecr;\n" \
  "                        iDeb = 0;\n" \
  "                    }\n" \
  "\n" \
  "                    lg_ecr = giv_ecrit_balise_iso(buf_pos, rOraSyno.acSyno, \"synonyme\");\n" \
  "                    buf_pos = buf_pos + lg_ecr;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (1 != iDeb)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"synonymes\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureSyno;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureSyno: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureEmbauche\n" \
  " *\n" \
  " * But : ref d'Embauche\n" \
  " *\n" \
  " * Description : Lecture de ref\n" \
  " *               dans la table GYTtabEmbauche.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureEmbauche(char* apcNumcli, char* apcRefext)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iIdx;\n" \
  "    int4 j;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraCli;\n" \
  "    char pcOraRef[17 + 1];\n" \
  "    int2 sIndic;\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraCli\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraRef\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pcOraCli = apcNumcli;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureEmbauche\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureEmbauche\n" \
  "    USING: pcOraCli;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureEmbauche: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    apcRefext[0] = '\\0';\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureEmbauche\n" \
  "        INTO: pcOraRef: sIndic;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if (((int4)GIV::GYBok != iIntRet) || ((int4)GIV::GYBok != sIndic))\n" \
  "            apcRefext[0] = '\\0';\n" \
  "        else\n" \
  "            (void)strcpy(&apcRefext[0], &pcOraRef[0]);\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureEmbauche;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureEmbauche: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Embauche: %s, %s\\n\", apcNumcli, apcRefext));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureStat\n" \
  " *\n" \
  " * But : code statistique\n" \
  " *\n" \
  " * Description : Lecture de ref\n" \
  " *               dans la table GYTtabEStatAn.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureStat(char* apcNumcli, char* apcStat)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iIdx;\n" \
  "    int4 j;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraCli;\n" \
  "    char pcOraRef[100 + 1];\n" \
  "    int2 sIndic;\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraCli\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraRef\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pcOraCli = apcNumcli;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureStat\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureStat\n" \
  "    USING: pcOraCli;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureStat: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    apcStat[0] = '\\0';\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureStat\n" \
  "        INTO: pcOraRef: sIndic;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if (((int4)GIV::GYBok != iIntRet) || ((int4)GIV::GYBok != sIndic))\n" \
  "            apcStat[0] = '\\0';\n" \
  "        else\n" \
  "            (void)strcpy(&apcStat[0], &pcOraRef[0]);\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureStat;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureStat: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Stat: %s, %s\\n\", apcNumcli, apcStat));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givEcritureMotsCles\n" \
  " *\n" \
  " * But : cri mots cles\n" \
  " *\n" \
  " * Description : criture temre de cri\n" \
  " *               depuis la table GYTtabMotsClesCri.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givEcritureMotsCles(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 iRef, int4 iObj, int4 indice, char* pcBalise)\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char* pt_debut_liste, *pt_fin_liste, *pcFin;\n" \
  "    int4 lg_write;\n" \
  "    int4 i, j, k, iNbCRC, iDiff;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    GYBrPrioCRCT rPrioCRC;\n" \
  "    GYBstrMClesCriIdT tcIdMCle;\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Critère Mot Clé écrit\\n\"));\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    /* conversion du XMLType de GIVBuffInter */\n" \
  "    (void)givConvClob();\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    strcat(buf_pos, \"<annonceur etablissement=\\\"\\\" id=\\\"\");\n" \
  "    lg_write = strlen(buf_pos);\n" \
  "    memcpy(buf_pos + lg_write, &(doc + iRef)->value.objets_pub.micro[iObj].id[4], 8);\n" \
  "    *(buf_pos + lg_write + 8) = '\\0';\n" \
  "    strcat(buf_pos, \"\\\">\");\n" \
  "    lg_write = strlen(buf_pos);\n" \
  "    *(buf_pos + lg_write) = SEPARE_LIGNE;\n" \
  "    *(buf_pos + (lg_write + 1)) = LINE_FEED;\n" \
  "    *(buf_pos + (lg_write + 2)) = '\\0';\n" \
  "    buf_pos = (buf_pos + lg_write + 2);\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"listMC\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    pt_fin_lst = GIVBuffClob + strlen(GIVBuffClob);\n" \
  "\n" \
  "    for (pt_debut = GIVBuffClob; pt_debut < pt_fin_lst;)\n" \
  "    {\n" \
  "        pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "        if (pt_fin == 0)\n" \
  "            pt_fin = pt_fin_lst;\n" \
  "\n" \
  "        /* analyse id */\n" \
  "        memcpy(tcIdMCle, pt_debut, (pt_fin - pt_debut));\n" \
  "        tcIdMCle[(pt_fin - pt_debut)] = '\\0';\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Critère Mot Clé écrit %s,%d\\n\", tcIdMCle, strlen(tcIdMCle)));\n" \
  "        lg_write = giv_ecrit_element(buf_pos, \"idMC\", tcIdMCle);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        pt_debut = pt_fin + 1;\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"listMC\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"annotation\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    iNbCRC = giviNbCRC;\n" \
  "    iRet = givAnalyseObjetXML(\"MO\", doc, GIVBuffInter, &buf_pos);\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"annotation\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"annonceur\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* Ecriture dans le fichier de sortie de l'annotation déjà en UTF8 */\n" \
  "    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    if (giviNbCRC != iNbCRC)\n" \
  "    {\n" \
  "        iDiff = giviNbCRC - iNbCRC;\n" \
  "\n" \
  "        for (i = 1; i < indice; i++)\n" \
  "        {\n" \
  "            for (k = 0; k < i; k++)\n" \
  "            {\n" \
  "                if (0 == strcmp((doc + i)->value.a_classer.etab, (doc + k)->value.a_classer.etab))\n" \
  "                    break;\n" \
  "            }\n" \
  "\n" \
  "            if (k == i)\n" \
  "            {\n" \
  "                for (j = 0; j < iDiff; j++)\n" \
  "                {\n" \
  "                    (void)strcpy(rPrioCRC.acTpdsob, givrListCRC.trEltList[iNbCRC + j].acTpdsob);\n" \
  "                    (void)strcpy(rPrioCRC.acCodan8, givrListCRC.trEltList[iNbCRC + j].acCodan8);\n" \
  "                    (void)strcpy(rPrioCRC.acType, givrListCRC.trEltList[iNbCRC + j].acType);\n" \
  "                    (void)strcpy(rPrioCRC.acEtab, (doc + i)->value.a_classer.etab);\n" \
  "                    (void)strcpy(rPrioCRC.acCRC, givrListCRC.trEltList[iNbCRC + j].acCRC);\n" \
  "                    rPrioCRC.iPrioCRC = givrListCRC.trEltList[iNbCRC + j].iPrioCRC;\n" \
  "                    iRet = givAjoutListCRC(rPrioCRC);\n" \
  "\n" \
  "                    if ((int4)GIV::GIXCodeOK != iRet)\n" \
  "                        break;\n" \
  "                }\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK != iRet)\n" \
  "                    break;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givEcritureBonPlan\n" \
  " *\n" \
  " * But : ref de Bon Plan\n" \
  " *\n" \
  " * Description : Lecture de ref\n" \
  " *               dans la table GYTtabBonPlan.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givEcritureBonPlan(char* apcEtab, char** buf_pos_in)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iIdx, lg_ecr;\n" \
  "    int4 j;\n" \
  "    char* buf_pos;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char tcEtab[GYBIeinscLgEtab2]; /* etab */\n" \
  "    char tcNumcli[GYBIeinscLgNumcli2]; /* client */\n" \
  "    char datfin[GYBIeinscLgDatmod + 1]; /* date fin */\n" \
  "    char tcNb[6]; /* nombre */\n" \
  "    char cTyp;\n" \
  "    GYBrIamicT rOraIamic;\n" \
  "    int2 sIndic;\n" \
  "    EXEC SQL\n" \
  "    VAR tcEtab\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    VAR tcNb\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(tcEtab, apcEtab);\n" \
  "    lg_ecr = 0;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureBonPlanPub\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureBonPlanPub\n" \
  "    USING :tcEtab, :tcEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsLectureBonPlanPub: [COD=%d TXT=%s EPJ=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour, apcEtab));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* accès via Objet Pub au BonPlan */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureBonPlanPub\");\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureBonPlanPub\n" \
  "        INTO\n" \
  "        :tcEtab,:datfin:sIndic,:tcNb,:rOraIamic.acTpdsob,:cTyp,:tcNumcli;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Pas de Bon Plan sur objet pub client : %s\\n\", tcEtab));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Bon Plan sur objet pub client : %s,%c,%c\\n\", tcEtab, tcNb, cTyp));\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureBonPlanPub;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureBonPlanPub: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeKO != iCodRet)\n" \
  "    {\n" \
  "        /* référence de BonPlan */\n" \
  "        if ((int4)GIV::GYBok != sIndic)\n" \
  "            (void)strcpy(datfin, \"\");\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"BonPlanPub: %s, %s, %s, %s\\n\", tcEtab, datfin, tcNb, rOraIamic.acTpdsob));\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, \"1\", \"bonplan\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, tcNb, \"nb_bonplan\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "        lg_ecr = giv_ecrit_balise(buf_pos, datfin, \"bonplan_df\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "        strcpy(buf_pos, \"<offre_bonplan etab=\");\n" \
  "        strcat(buf_pos, \"\\\"\");\n" \
  "        strcat(buf_pos, tcEtab);\n" \
  "        strcat(buf_pos, \"\\\">\");\n" \
  "        strcat(buf_pos, rOraIamic.acTpdsob);\n" \
  "        strcat(buf_pos, \"</offre_bonplan>\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf_pos = (buf_pos + lg_ecr);\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givServiceEtabSEO\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de présence\n" \
  " *               dans la table GYTtabSEOService.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givServiceEtabSEO(GYBrDOCUMENTEpj* doc, char* apInfo, char* apAvis)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT rInscrip;\n" \
  "    char cOraInfo, cOraAvis;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    int4 i;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    (void)strcpy(rInscrip.acEtab, doc->value.a_classer.etab);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureSrvSEO\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureSrvSEO\n" \
  "    USING: rInscrip.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureSrvSEO: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureSrvSEO\");\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureSrvSEO\n" \
  "            INTO\n" \
  "            :cOraInfo,:cOraAvis;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            else\n" \
  "            {\n" \
  "                *apInfo = cOraInfo;\n" \
  "                *apAvis = cOraAvis;\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureSrvSEO;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureSrvSEO: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givDnomPrincEtab\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de meilleure pub via etab\n" \
  " *               dans la table GYTtabIAMIC.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givDnomPrincEtab(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT rInscrip;\n" \
  "    char* pcVersion;\n" \
  "    char cDepart[GYBIeinscLgDeppar + 1];\n" \
  "    char rOraTri[40];\n" \
  "    int4 iVolee;\n" \
  "    char tcBlocid[28 + 1];\n" \
  "    int2 indic;\n" \
  "    EXEC SQL\n" \
  "    VAR rOraTri\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    VAR tcBlocid\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    char rTri[38];\n" \
  "    int4 i, iRang;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(rInscrip.acEtab, doc->value.a_classer.etab);\n" \
  "    iRang = -1;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureDnomPrinc\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureDnomPrinc\n" \
  "    USING: rInscrip.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureDnomPrinc: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureDnomPrinc\");\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureDnomPrinc\n" \
  "            INTO: rOraTri;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" DnomPrinc... %s\\n\", rOraTri));\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "\n" \
  "                for (i = 0; i < indice; i++)\n" \
  "                {\n" \
  "                    if (0 != strcmp((doc + i)->value.inscription[0].val_lslo, \"0000\"))\n" \
  "                        (void)strcpy(rTri, \"0\");\n" \
  "                    else\n" \
  "                        (void)strcpy(rTri, \"1\");\n" \
  "\n" \
  "                    (void)strcpy(rTri, (doc + i)->value.inscription[0].val_num);\n" \
  "                    (void)strcat(rTri, (doc + i)->value.inscription[0].val_lols);\n" \
  "                    (void)strcat(rTri, (doc + i)->value.inscription[0].val_lslo);\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" DnomPrinc Doc ... %s\\n\", rTri));\n" \
  "\n" \
  "                    if (0 == strcmp(&rOraTri[21], rTri))\n" \
  "                        break;\n" \
  "                }\n" \
  "\n" \
  "                if (indice == i)\n" \
  "                    iRang = -1;\n" \
  "                else\n" \
  "                    iRang = i;\n" \
  "\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" DnomPrinc Rang ... %s,%d\\n\", rOraTri, iRang));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureDnomPrinc;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureDnomPrinc: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if (-1 != iRang)\n" \
  "    {\n" \
  "        indic = -1;\n" \
  "        (void)strcpy(rInscrip.acNumnat, (doc + iRang)->value.inscription[0].val_num);\n" \
  "        (void)strcpy(rInscrip.acNumlo, (doc + iRang)->value.inscription[0].val_lo);\n" \
  "        (void)strcpy(rInscrip.acNumls, (doc + iRang)->value.inscription[0].val_ls);\n" \
  "        (doc + iRang)->value.numero_bloc_parution_ref[0] = '\\0';\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"crsVersSeo\");\n" \
  "        EXEC SQL open crsVersSEO using :rInscrip.acNumnat, :rInscrip.acNumlo, :rInscrip.acNumls;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsVersSeo pour blocid principal : [COD=%d TXT=%s],%s,%s,%s\\n\", iIntRet, vErreurSQL.acDonnees_retour, rInscrip.acNumnat, rInscrip.acNumlo, rInscrip.acNumls));\n" \
  "        else\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            fetch crsVersSEO\n" \
  "            into: tcBlocid: indic;\n" \
  "\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if (((int4)GIV::GYBok != iIntRet) || (0 != indic))\n" \
  "            {\n" \
  "                (doc + iRang)->value.numero_bloc_parution_ref[0] = '\\0';\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Absence de blocidlr pour ippal : %s,%s,%s et epj : %s\\n\", rInscrip.acNumnat, rInscrip.acNumlo, rInscrip.acNumls, rInscrip.acEtab));\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                strcpy((doc + iRang)->value.numero_bloc_parution_ref, &tcBlocid[1]);\n" \
  "\n" \
  "                if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "                    strcat((doc + iRang)->value.numero_bloc_parution_ref, \"C0002\");\n" \
  "                else\n" \
  "                    strcat((doc + iRang)->value.numero_bloc_parution_ref, \"C0001\");\n" \
  "            }\n" \
  "\n" \
  "            EXEC SQL\n" \
  "            close crsVersSEO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    return (iRang);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givExtraLocIS\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de ligne locale via etab, activité\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givExtraLocIS(char* apcEtab, char* apcCodAn8)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT rInscrip;\n" \
  "    GYBrIaprofT rIaprof;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "    {\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    (void)strcpy(rInscrip.acEtab, apcEtab);\n" \
  "    (void)strcpy(rIaprof.acCodan8, apcCodAn8);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureExtraLocIS\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureExtraLocIS\n" \
  "    USING :rIaprof.acCodan8,\n" \
  "    :rInscrip.acEtab,\n" \
  "    :rInscrip.acEtab,\n" \
  "    :rIaprof.acCodan8;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureExtraLocIS %s: [COD=%d TXT=%s]\\n\", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureExtraLocIS\");\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureExtraLocIS\n" \
  "            INTO: rIaprof.acCodan8;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" ExtraLocIS... %s\\n\", rIaprof.acCodan8));\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" ExtraLocIS... %d\\n\", iCodRet));\n" \
  "    EXEC SQL\n" \
  "    close crsLectureExtraLocIS;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureExtraLocIS: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "int4 givExtraLocInterIS(char* apcEtab, char* apcCodAn8, GYBrDOCUMENTEpj* docIG, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int4 i, j;\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT rInscrip;\n" \
  "    GYBrIaprofT rIaprof;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "    {\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    (void)strcpy(rInscrip.acEtab, apcEtab);\n" \
  "    (void)strcpy(rIaprof.acCodan8, apcCodAn8);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureExtraLocInterIS\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureExtraLocInterIS\n" \
  "    USING :rIaprof.acCodan8,\n" \
  "    :rInscrip.acEtab,\n" \
  "    :rInscrip.acEtab,\n" \
  "    :rIaprof.acCodan8;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureExtraLocInterIS %s: [COD=%d TXT=%s]\\n\", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureExtraLocInterIS\");\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureExtraLocInterIS\n" \
  "            INTO\n" \
  "            :rInscrip.acNumnat,\n" \
  "            :rInscrip.acNumlo,\n" \
  "            :rInscrip.acNumls;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" ExtraLocInterIS... %s,%s,%s\\n\", rInscrip.acNumnat, rInscrip.acNumlo, rInscrip.acNumls));\n" \
  "\n" \
  "                for (i = 0; i < indice; i++)\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" ExtraLocInterIS... %s,%s,%s\\n\", (docIG + i)->value.inscription[0].val_num, (docIG + i)->value.inscription[0].val_lols, (docIG + i)->value.inscription[0].val_lslo));\n" \
  "\n" \
  "                    if ((0 == strcmp((docIG + i)->value.inscription[0].val_num, rInscrip.acNumnat)) && (0 == strcmp((docIG + i)->value.inscription[0].val_lols, rInscrip.acNumlo))\n" \
  "                            && (0 == strcmp((docIG + i)->value.inscription[0].val_lslo, rInscrip.acNumls)))\n" \
  "                    {\n" \
  "                        /* inscription trouvée dans le bloc */\n" \
  "                        break;\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                if (indice != i)\n" \
  "                {\n" \
  "                    /* inscription trouvée dans le bloc */\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                /* inscription non trouvée dans le bloc */\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" ExtraLocInterIS... %d\\n\", iCodRet));\n" \
  "    EXEC SQL\n" \
  "    close crsLectureExtraLocInterIS;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureExtraLocInterIS: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givExtraLocIO\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de ligne locale via etab, activité\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givExtraLocIO(GYBrDOCUMENTEpj* doc)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT rInscrip;\n" \
  "    GYBrIaprofT rIaprof;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    (void)strcpy(rInscrip.acEtab, doc->value.a_classer.etab);\n" \
  "    (void)strcpy(rInscrip.acNumnat, doc->value.inscription[0].val_num);\n" \
  "    (void)strcpy(rInscrip.acNumlo, doc->value.inscription[0].val_lo);\n" \
  "    (void)strcpy(rInscrip.acNumls, doc->value.inscription[0].val_ls);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureExtraLocIO\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureExtraLocIO\n" \
  "    USING :rInscrip.acEtab,\n" \
  "    :rInscrip.acNumnat,\n" \
  "    :rInscrip.acNumlo,\n" \
  "    :rInscrip.acNumls,\n" \
  "    :rInscrip.acEtab,\n" \
  "    :rInscrip.acNumnat,\n" \
  "    :rInscrip.acNumlo,\n" \
  "    :rInscrip.acNumls,\n" \
  "    :rInscrip.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureExtraLocIO %s: [COD=%d TXT=%s]\\n\", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureExtraLocIO\");\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureExtraLocIO\n" \
  "            INTO: rIaprof.acCodan8;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" ExtraLocIO... %s\\n\", rIaprof.acCodan8));\n" \
  "                iCodRet = givExtraLocIS(doc->value.a_classer.etab, rIaprof.acCodan8);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "                {\n" \
  "                    /* existence de locale */\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" ExtraLocIO... %d\\n\", iCodRet));\n" \
  "    EXEC SQL\n" \
  "    close crsLectureExtraLocIO;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureExtraLocIO: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givOppositionPart\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de la liste d'opposition\n" \
  " *               d'une référence de partenaire.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givOppositionPart(char** buf, char* val)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIapartT rIapart;\n" \
  "    char rOraOpp[16];\n" \
  "    EXEC SQL\n" \
  "    VAR rOraOpp\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    int4 pipe;\n" \
  "    int4 lg_write = 0;\n" \
  "    char* buf_pos;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pipe = 0;\n" \
  "    buf_pos = *buf;\n" \
  "    (void)strcpy(rIapart.acOriPart, &val[strlen(val) - 4]);\n" \
  "    (void)memcpy(rIapart.acRefPart, val, strlen(val) - 4);\n" \
  "    rIapart.acRefPart[strlen(val) - 4] = '\\0';\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureOppPart\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureOppPart\n" \
  "    USING :rIapart.acOriPart,\n" \
  "    :rIapart.acRefPart;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureOppPart %s,%s: [COD=%d TXT=%s]\\n\", rIapart.acOriPart, rIapart.acRefPart, iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureOppPart\");\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" Opposition Partenaire... %s,%s\\n\", rIapart.acOriPart, rIapart.acRefPart));\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureOppPart\n" \
  "            INTO: rOraOpp;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"%s\\n\", rOraOpp));\n" \
  "                lg_write = giv_ecrit_balise(buf_pos, rOraOpp, \"opp_part\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                pipe = 1;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf = buf_pos;\n" \
  "    EXEC SQL\n" \
  "    close crsLectureOppPart;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureOppPart: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givOppositionURLGratuite\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de l'ooposition sur le fichier GS lié à l'URL Gratuite\n" \
  " *               dans la table GYTTabURLGrOpp.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givOppositionURLGratuite(char* apcEtab, char* apcCodAn8)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT rInscrip;\n" \
  "    GYBrIaprofT rIaprof;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    int4 i;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    (void)strcpy(rInscrip.acEtab, apcEtab);\n" \
  "    (void)strcpy(rIaprof.acCodan8, apcCodAn8);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureOppURLGr\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureOppURLGr\n" \
  "    USING :rInscrip.acEtab,\n" \
  "    :rIaprof.acCodan8;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureOppURLGr %s: [COD=%d TXT=%s]\\n\", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureOppURLGr\");\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" OppURLGr... %s,%s\\n\", rIaprof.acCodan8, rInscrip.acEtab));\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureOppURLGr\n" \
  "            INTO: rIaprof.acCodan8;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* sortie sur opposition trouvée */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureOppURLGr;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureOppURLGr: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureBListCRCLR\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture du black-listage en liste réponse\n" \
  " *               dans la table GYTTabBListCRCLR.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureBListCRCLR(GYBrPrioCRCT* aprPrioCRC)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPrioCRCT rPrioCRC;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    /* variables Oracle */\n" \
  "    (void)strcpy(rPrioCRC.acEtab, aprPrioCRC->acEtab);\n" \
  "    (void)strcpy(rPrioCRC.acCodan8, aprPrioCRC->acCodan8);\n" \
  "    (void)strcpy(rPrioCRC.acTpdsob, aprPrioCRC->acTpdsob);\n" \
  "    (void)strcpy(rPrioCRC.acCRC, aprPrioCRC->acCRC);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureBLCRCLR\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureBLCRCLR\n" \
  "    USING :rPrioCRC.acEtab,\n" \
  "    :rPrioCRC.acCodan8,\n" \
  "    :rPrioCRC.acTpdsob,\n" \
  "    :rPrioCRC.acCRC;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureBLCRCLR : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureBLCRCLR\");\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" BLCRCLR... %s,%s,%s,%s\\n\", rPrioCRC.acCodan8, rPrioCRC.acEtab, rPrioCRC.acTpdsob, rPrioCRC.acCRC));\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureBLCRCLR\n" \
  "            INTO: rPrioCRC.acCodan8;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* sortie sur opposition trouvée */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureBLCRCLR;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureBLCRCLR: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureBListCRCFD\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture du black-listage en fiche détaillée\n" \
  " *               dans la table GYTTabBListCRCLR.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureBListCRCFD(GYBrPrioCRCT* aprPrioCRC)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPrioCRCT rPrioCRC;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    /* variables Oracle */\n" \
  "    (void)strcpy(rPrioCRC.acEtab, aprPrioCRC->acEtab);\n" \
  "    (void)strcpy(rPrioCRC.acCRC, aprPrioCRC->acCRC);\n" \
  "    (void)strcpy(rPrioCRC.acTpdsob, aprPrioCRC->acTpdsob);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureBLCRCFD\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureBLCRCFD\n" \
  "    USING :rPrioCRC.acEtab,\n" \
  "    :rPrioCRC.acCRC,\n" \
  "    :rPrioCRC.acTpdsob;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureBLCRCFD : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureBLCRCFD\");\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" BLCRCFD... %s,%s,%s,%s\\n\", rPrioCRC.acCodan8, rPrioCRC.acEtab, rPrioCRC.acTpdsob, rPrioCRC.acCRC));\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureBLCRCFD\n" \
  "            INTO: rPrioCRC.acTpdsob;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* sortie sur opposition trouvée */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureBLCRCFD;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureBLCRCFD: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureBListEPJFD\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture du black-listage en fiche détaillée\n" \
  " *               dans la table GYTTabBListEPJFD.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureBListEPJFD(char* acEtab)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPrioCRCT rPrioCRC;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    /* variables Oracle */\n" \
  "    (void)strcpy(rPrioCRC.acEtab, acEtab);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureBLEPJFD\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureBLEPJFD\n" \
  "    USING: rPrioCRC.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureBLEPJFD : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureBLEPJFD\");\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureBLEPJFD\n" \
  "            INTO: rPrioCRC.acEtab;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* sortie sur opposition trouvée */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" BLEPJFD... %s,%d\\n\", rPrioCRC.acEtab, iCodRet));\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureBLEPJFD;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureBLEPJFD: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureBListEPJProf\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture du black-listage\n" \
  " *               dans la table GYTTabBListEPJProf.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureBListEPJProf(char* apcEtab, char* apcCodAn8)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT rInscrip;\n" \
  "    GYBrIaprofT rIaprof;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    /* variables Oracle */\n" \
  "    (void)strcpy(rInscrip.acEtab, apcEtab);\n" \
  "    (void)strcpy(rIaprof.acCodan8, apcCodAn8);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureBLEPJProf\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureBLEPJProf\n" \
  "    USING :rInscrip.acEtab,\n" \
  "    :rIaprof.acCodan8;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureBLEPJProf : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureBLEPJProf\");\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" BLEPJProf... %s,%s\\n\", rIaprof.acCodan8, rInscrip.acEtab));\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureBLEPJProf\n" \
  "            INTO: rIaprof.acCodan8;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* sortie sur opposition trouvée */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureBLEPJProf;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureBLEPJProf: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureBUC\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de numcli via etab\n" \
  " *               dans la table GYTtabIEINSC.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureBUC(char* apcEtab, char* acMin, char* acMax)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char tcEtab[GYBIeinscLgEtab2]; /* etab */\n" \
  "    char tcNumcli[GYBIeinscLgNumcli2]; /* client */\n" \
  "    char OraMin[5], OraMax[5];\n" \
  "    int2 sIndic;\n" \
  "    EXEC SQL\n" \
  "    VAR tcNumcli\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(tcEtab, apcEtab);\n" \
  "    (void)strcpy(OraMin, acMin);\n" \
  "    (void)strcpy(OraMax, acMax);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureBUC\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureBUC\n" \
  "    USING :tcEtab,:OraMin,:OraMax;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureBUC: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"BUC: %s\\n\", apcEtab));\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureBUC\");\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureBUC\n" \
  "            INTO: tcNumcli: sIndic;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if (((int4)GIV::GYBok != iIntRet) || ((int4)GIV::GYBok != sIndic))\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            else\n" \
  "            {\n" \
  "                if (0 == strlen(buf_concat))\n" \
  "                    strcpy(buf_concat, &tcNumcli[4]);\n" \
  "                else\n" \
  "                {\n" \
  "                    strcat(buf_concat, \"|\");\n" \
  "                    strcat(buf_concat, &tcNumcli[4]);\n" \
  "                }\n" \
  "\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" BUC... %s\\n\", buf_concat));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureBUC;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureBUC: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureEvIlo\n" \
  " *\n" \
  " * But : ref back office ILO\n" \
  " *\n" \
  " * Description : Lecture de ref\n" \
  " *               dans la table GYTtabEVILO.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureEvIlo(char* apcEtab, char* acEvt, char* acPrg)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraEtab;\n" \
  "    char cOraEvt = '\\0', cOraPrg = '\\0';\n" \
  "    int2 sIndEvt, sIndPrg;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pcOraEtab = apcEtab;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureEvIlo\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureEvIlo\n" \
  "    USING: pcOraEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureEvIlo: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    *acEvt = '\\0';\n" \
  "    *acPrg = '\\0';\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureEvIlo\n" \
  "        INTO\n" \
  "        :cOraEvt:sIndEvt,:cOraPrg:sIndPrg;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == sIndEvt)\n" \
  "            *acEvt = cOraEvt;\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == sIndPrg)\n" \
  "            *acPrg = cOraPrg;\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureEvIlo;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureEvIlo: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"EvIlo: %s, %c, %c\\n\", apcEtab, *acEvt, *acPrg));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureSIRET\n" \
  " *\n" \
  " * But : SIRET de Pages.\n" \
  " *\n" \
  " * Description : Lecture du siret\n" \
  " *               dans la table GYTtabPagesPro.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureSIRET(char* apcSiret)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch = 0;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iIdx;\n" \
  "    int4 j;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char tcSiret[GYBIeinscLgSiret2]; /* siret */\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(tcSiret, apcSiret);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureSIRET\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureSIRET\n" \
  "    USING: tcSiret;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureSIRET: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureSIRET\n" \
  "        INTO: tcSiret;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureSIRET;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureSIRET: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction    :  GIVLectureTabPeEtab ()\n" \
  " *\n" \
  " * But         : Lecture d'un tuple dans la table PEETAB\n" \
  " *\n" \
  " * Description :\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres         :\n" \
  " *\n" \
  " *  Valeurs retournées : -1 : erreur dans le traitement\n" \
  " *                        0 : acces a la table correct\n" \
  " *\n" \
  " *  Erreurs            : erreur SQL sur execution de la requete SELECT\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :    Jun/03/1996  (jli)\n" \
  " *\n" \
  " * Modification (Mar/08/2006 - mb) : Rappel Gratuit\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 GIVLectureTabPeEtab(char* pcEtab)\n" \
  "{\n" \
  "    /* définition et initialisation des données locales */\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour interne */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT rErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 iQualite;\n" \
  "    /* données d'interface sgbd */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIeinscT* pvInscrip;\n" \
  "    GYBrIndIeinscT* pvIndInscrip;\n" \
  "    GYBrPeadrT* pvAdr;\n" \
  "    GYBrIndPeadrT* pvIndAdr;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    /* la lecture se fait dans les vaibles globales */\n" \
  "    /** limite les passages d'argument des 60 champs et assure la cohérence de fiat */\n" \
  "    pvInscrip = &GIVvInscrip;\n" \
  "    pvIndInscrip = &GIVvIndInscrip;\n" \
  "    pvAdr = &GIVvAdr;\n" \
  "    pvIndAdr = &GIVvIndAdr;\n" \
  "    /* initialisation des éléments de lcé de lecture de la table etab */\n" \
  "    strcpy(pvInscrip->acEtab, pcEtab);\n" \
  "    /* Ouverture curseur SQL (car requete type SELECT) */\n" \
  "    (void)strcpy(rErreurSQL.acOrdre_sql, \"open crsLecturePeETAB\");\n" \
  "    EXEC SQL\n" \
  "    open crsLecturePeEtab\n" \
  "    using :pvInscrip->acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&rErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur declaration curseur SQL */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur OPEN crsLecturePeEtab ...\\n\"));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Execution requete de recherche (FETCH du curseur) */\n" \
  "        (void)strcpy(rErreurSQL.acOrdre_sql, \"fetch crsLecturePeEtab\");\n" \
  "        pvIndInscrip->sArrondI = (int4)GIV::GYBnok;\n" \
  "        EXEC SQL\n" \
  "        fetch crsLecturePeEtab\n" \
  "        into\n" \
  "        :pvInscrip->acEtab\n" \
  "        :pvIndInscrip->sEtabI,\n" \
  "        :pvInscrip->acSiret:pvIndInscrip->sSiretI,\n" \
  "        :pvInscrip->acNaf:pvIndInscrip->sNafI,\n" \
  "        :pvInscrip->acDenom:pvIndInscrip->sDenomI,\n" \
  "        :pvInscrip->acCompln:pvIndInscrip->sComplnI,\n" \
  "        :pvInscrip->acCoddep:pvIndInscrip->sCoddepI,\n" \
  "        :pvInscrip->acCodloc:pvIndInscrip->sCodlocI,\n" \
  "        :pvInscrip->acAdrnr:pvIndInscrip->sAdrnrI,\n" \
  "        :pvInscrip->acCodvoi:pvIndInscrip->sCodvoiI,\n" \
  "        :pvInscrip->acTypvoi:pvIndInscrip->sTypvoiI,\n" \
  "        :pvInscrip->acLibvoi:pvIndInscrip->sLibvoiI,\n" \
  "        :pvInscrip->acNovoie:pvIndInscrip->sNovoieI,\n" \
  "        :pvInscrip->acCplnov:pvIndInscrip->sCplnovI,\n" \
  "        :pvAdr->acLongitude:pvIndAdr->sLongitudeI,\n" \
  "        :pvAdr->acLatitude:pvIndAdr->sLatitudeI,\n" \
  "        :pvAdr->acPrec:pvIndAdr->sPrecI;\n" \
  "        iIntRet = GIVBlocErreur(&rErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur execute LecturePeETAB : [COD=%d TXT=%s]\\n\", iIntRet, rErreurSQL.acDonnees_retour));\n" \
  "\n" \
  "            if ((int4)GIV::GYBnodata == iIntRet)\n" \
  "                GWTTrace(GWT_NIV_BIZAR, (\"pas de donnée dans PeEtab : [COD=%d TXT=%s]\\n\", iIntRet, rErreurSQL.acDonnees_retour));\n" \
  "\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        /* Fermeture du curseur */\n" \
  "        (void)strcpy(rErreurSQL.acOrdre_sql, \"close crsLecturePeEtab\");\n" \
  "        EXEC SQL\n" \
  "        close crsLecturePeEtab;\n" \
  "        iIntRet = GIVBlocErreur(&rErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur fermeture curseur SQL */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur CLOSE crsLecturePeEtab ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* support et parution par défaut */\n" \
  "    GIVvIndInscrip.sInsuppI = 0;\n" \
  "    GIVvInscrip.acInsupp[0] = 1;\n" \
  "    GIVvIndInscrip.sInparuI = 0;\n" \
  "    strcpy(GIVvInscrip.acInparu, \"0000\");\n" \
  "\n" \
  "    /* Tester la validité du géocodage */\n" \
  "    if (-1 == GIVvIndAdr.sPrecI)\n" \
  "    {\n" \
  "        iQualite = 99;\n" \
  "        snprintf(GIVvGeocod.tcQualite, GIVGeocodLgQualite + 1, \"%2d\", 99);\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        iQualite = atoi(GIVvAdr.acPrec);\n" \
  "        snprintf(GIVvGeocod.tcQualite, GIVGeocodLgQualite + 1, \"%2s\", GIVvAdr.acPrec);\n" \
  "    }\n" \
  "\n" \
  "    switch (iQualite)\n" \
  "    {\n" \
  "    case 96:\n" \
  "        GIVvGeocod.iStatus = GIVGeocodSEnvXY;\n" \
  "        break;\n" \
  "\n" \
  "    case 97:\n" \
  "        GIVvGeocod.iStatus = GIVGeocodSEnvIndic;\n" \
  "        break;\n" \
  "\n" \
  "    case 98:\n" \
  "        GIVvGeocod.iStatus = GIVGeocodSEnvXY;\n" \
  "        break;\n" \
  "\n" \
  "    case 99:\n" \
  "        GIVvGeocod.iStatus = GIVGeocodSEnvRien;\n" \
  "        break;\n" \
  "\n" \
  "    default:\n" \
  "        GIVvGeocod.iStatus = GIVGeocodSEnvXYQ;\n" \
  "        break;\n" \
  "    }\n" \
  "\n" \
  "    if (-1 == GIVvIndAdr.sLongitudeI)\n" \
  "        GIVvGeocod.tcLongitude[0] = '\\0';\n" \
  "    else\n" \
  "        snprintf(GIVvGeocod.tcLongitude, GIVGeocodLgLongitude + 1, \"%s\", GIVvAdr.acLongitude);\n" \
  "\n" \
  "    if (-1 == GIVvIndAdr.sLatitudeI)\n" \
  "        GIVvGeocod.tcLatitude[0] = '\\0';\n" \
  "    else\n" \
  "        snprintf(GIVvGeocod.tcLatitude, GIVGeocodLgLatitude + 1, \"%s\", GIVvAdr.acLatitude);\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction    :  givLectureTabZU ()\n" \
  " *\n" \
  " * But         :  Recherche de la zone urbaine\n" \
  " *\n" \
  " * Description :\n" \
  " *\n" \
  " *\n" \
  " *\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres         :\n" \
  " *\n" \
  " *  Valeurs retournées : -1 : erreur dans le traitement\n" \
  " *                            0 : pas de tuple trouve\n" \
  " *\n" \
  " *\n" \
  " *  Erreurs            : erreur SQL sur execution de la requete SELECT\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/17/2006  (mb)\n" \
  " *\n" \
  " * Modification (MM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureTabZU(char* pcDep, char* pcLoc)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPelzuT* pvPole;\n" \
  "    GYBrIndPelzuT* pvIndPole;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givLectureZU\\n\"));\n" \
  "\n" \
  "    if (0 == strcmp(givcLocFictive, pcLoc))\n" \
  "    {\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        /* appael inutile pour LF */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    iIntRet = givPreparerLectureZU();\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur prepare curseur SQL */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur  crsLectureZU ...\\n\"));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Initialisation des variables locales */\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        /* Valorisation du pointeur vers la structure de description de la table PAYS */\n" \
  "        pvPole = &GIVvPole;\n" \
  "        pvIndPole = &GIVvIndPole;\n" \
  "        /* Valorisation du pointeur vers la structure de description */\n" \
  "        /*   du tableau de recuperation des correspondances AN8/AN9 */\n" \
  "        (void)strcpy((char*)pvPole->acDepart, (const char*)pcDep);\n" \
  "        (void)strcpy((char*)pvPole->acNumloc, (const char*)pcLoc);\n" \
  "        /* Ouverture curseur SQL (car requete type SELECT) */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureZU\");\n" \
  "        EXEC SQL\n" \
  "        open crsLectureZU\n" \
  "        using :pvPole->acDepart,\n" \
  "        :pvPole->acNumloc;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur declaration curseur SQL */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur OPEN crsLectureZU ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "            indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "            while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "            {\n" \
  "                (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureZU\");\n" \
  "                EXEC SQL\n" \
  "                fetch crsLectureZU\n" \
  "                into\n" \
  "                :pvPole->acDepPole\n" \
  "                :pvIndPole->sDepPoleI,\n" \
  "                :pvPole->acLocPole:pvIndPole->sLocPoleI\n" \
  "                ;\n" \
  "                iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "                /* Analyse du code retour SQL */\n" \
  "                switch (iIntRet)\n" \
  "                {\n" \
  "                case (int4)GIV::GYBok:\n" \
  "                {\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                case (int4)GIV::GYBnodata:\n" \
  "                {\n" \
  "                    /* la localite n'existe pas */\n" \
  "                    /* generer une signalisation */\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                default:\n" \
  "                {\n" \
  "                    /* la consultation de la base s'est mal passee */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Erreur execute rqtLectureZU : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                    break;\n" \
  "                }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* Fermeture du curseur */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"close crsLectureZU\");\n" \
  "            EXEC SQL\n" \
  "            close crsLectureZU;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur fermeture curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur CLOSE crsLectureZU ...\\n\"));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GIVLectureZU\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction    :  givLectureTabLocFus ()\n" \
  " *\n" \
  " * But         :  Recherche de la localité fusionnée\n" \
  " *\n" \
  " * Description :\n" \
  " *\n" \
  " *\n" \
  " *\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres         :\n" \
  " *\n" \
  " *  Valeurs retournées : -1 : erreur dans le traitement\n" \
  " *                            0 : pas de tuple trouve\n" \
  " *\n" \
  " *\n" \
  " *  Erreurs            : erreur SQL sur execution de la requete SELECT\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Nov/17/2016  (mb)\n" \
  " *\n" \
  " * Modification (MM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureTabLocFus(char* pcDep, char* pcLoc)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPelzuT* pvPole;\n" \
  "    GYBrIndPelzuT* pvIndPole;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givLectureLocFus\\n\"));\n" \
  "\n" \
  "    if (0 == strcmp(givcLocFictive, pcLoc))\n" \
  "    {\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        /* appael inutile pour LF */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    iIntRet = givPreparerLectureLocFus();\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur prepare curseur SQL */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur  crsLectureLocFus ...\\n\"));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Initialisation des variables locales */\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        /* Valorisation du pointeur vers la structure de description de la table PAYS */\n" \
  "        pvPole = &GIVvPole;\n" \
  "        pvIndPole = &GIVvIndPole;\n" \
  "        /* Valorisation du pointeur vers la structure de description */\n" \
  "        /*   du tableau de recuperation des correspondances AN8/AN9 */\n" \
  "        (void)strcpy((char*)pvPole->acDepart, (const char*)pcDep);\n" \
  "        (void)strcpy((char*)pvPole->acNumloc, (const char*)pcLoc);\n" \
  "        /* Ouverture curseur SQL (car requete type SELECT) */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureLocFus\");\n" \
  "        EXEC SQL\n" \
  "        open crsLectureLocFus\n" \
  "        using :pvPole->acDepart,\n" \
  "        :pvPole->acNumloc;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur declaration curseur SQL */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur OPEN crsLectureLocFus ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "            indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "            while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "            {\n" \
  "                (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureLocFus\");\n" \
  "                EXEC SQL\n" \
  "                fetch crsLectureLocFus\n" \
  "                into\n" \
  "                :pvPole->acDepPole\n" \
  "                :pvIndPole->sDepPoleI,\n" \
  "                :pvPole->acLocPole:pvIndPole->sLocPoleI\n" \
  "                ;\n" \
  "                iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "                /* Analyse du code retour SQL */\n" \
  "                switch (iIntRet)\n" \
  "                {\n" \
  "                case (int4)GIV::GYBok:\n" \
  "                {\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                case (int4)GIV::GYBnodata:\n" \
  "                {\n" \
  "                    /* la localite n'existe pas */\n" \
  "                    /* generer une signalisation */\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                default:\n" \
  "                {\n" \
  "                    /* la consultation de la base s'est mal passee */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Erreur execute rqtLectureLocFus : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                    break;\n" \
  "                }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* Fermeture du curseur */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"close crsLectureLocFus\");\n" \
  "            EXEC SQL\n" \
  "            close crsLectureLocFus;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur fermeture curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur CLOSE crsLectureLocFus ...\\n\"));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction    :  GIVLectureTabRegion ()\n" \
  " *\n" \
  " * But         :  Recherche de la région\n" \
  " *\n" \
  " * Description :\n" \
  " *\n" \
  " *\n" \
  " *\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres         :\n" \
  " *\n" \
  " *  Valeurs retournées : -1 : erreur dans le traitement\n" \
  " *                            0 : pas de tuple trouve\n" \
  " *\n" \
  " *\n" \
  " *  Erreurs            : erreur SQL sur execution de la requete SELECT\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/25/2006  (mb)\n" \
  " *\n" \
  " * Modification (MM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureTabRegion(char* pcDep)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrLjdeptT* pvRegion;\n" \
  "    GYBrIndLjdeptT* pvIndRegion;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givLectureRegion\\n\"));\n" \
  "    iIntRet = givPreparerLectureRegion();\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur prepare curseur SQL */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur  crsLectureRegion ...\\n\"));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Initialisation des variables locales */\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        /* Valorisation du pointeur vers la structure de description de la table PAYS */\n" \
  "        pvRegion = &GIVvRegion;\n" \
  "        pvIndRegion = &GIVvIndRegion;\n" \
  "        /* Valorisation du pointeur vers la structure de description */\n" \
  "        /*   du tableau de recuperation des correspondances AN8/AN9 */\n" \
  "        (void)strcpy((char*)pvRegion->acDepart, (const char*)pcDep);\n" \
  "        /* Ouverture curseur SQL (car requete type SELECT) */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureRegion\");\n" \
  "        EXEC SQL\n" \
  "        open crsLectureRegion\n" \
  "        using :pvRegion->acDepart;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur declaration curseur SQL */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur OPEN crsLectureRegion ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "            indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "            while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "            {\n" \
  "                (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureRegion\");\n" \
  "\n" \
  "                if (0 == strcmp(givtcRegCECI, \"NON\"))\n" \
  "                {\n" \
  "                    EXEC SQL\n" \
  "                    fetch crsLectureRegion\n" \
  "                    into\n" \
  "                    :pvRegion->acRegion\n" \
  "                    :pvIndRegion->sRegionI;\n" \
  "                    (void)strcpy(pvRegion->acAncReg, pvRegion->acRegion);\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    EXEC SQL\n" \
  "                    fetch crsLectureRegion\n" \
  "                    into\n" \
  "                    :pvRegion->acRegion\n" \
  "                    :pvIndRegion->sRegionI,\n" \
  "                    :pvRegion->acAncReg\n" \
  "                    ;\n" \
  "                }\n" \
  "\n" \
  "                iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "                /* Analyse du code retour SQL */\n" \
  "                switch (iIntRet)\n" \
  "                {\n" \
  "                case (int4)GIV::GYBok:\n" \
  "                {\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                case (int4)GIV::GYBnodata:\n" \
  "                {\n" \
  "                    /* la localite n'existe pas */\n" \
  "                    /* generer une signalisation */\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                default:\n" \
  "                {\n" \
  "                    /* la consultation de la base s'est mal passee */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Erreur execute rqtLectureRegion : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                    indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                    break;\n" \
  "                }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* Fermeture du curseur */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"close crsLectureRegion\");\n" \
  "            EXEC SQL\n" \
  "            close crsLectureRegion;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur fermeture curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur CLOSE crsLectureRegion ...\\n\"));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GIVLectureRegion\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_balise ()                                             */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit une balise avec le nom des noeud et la valeur            */\n" \
  "/*             correspondante entre les balises.                              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, le contenu et le nom des balises                    */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_balise(char* buf, char* contenu, char* nom_balise)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "    lg_ecr = 0;\n" \
  "\n" \
  "    /* debut des methodes d'ecriture de balise simple*/\n" \
  "    if ((strlen(contenu) > 0) || (0 == strcmp(\"ippal\", nom_balise)))\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_balise);\n" \
  "\n" \
  "        if (0 == strcmp(\"ippal\", nom_balise))\n" \
  "        {\n" \
  "            strcat(buf, \" \");\n" \
  "            strcat(buf, \"blocidlr\");\n" \
  "            strcat(buf, \"=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, contenu);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \">\");\n" \
  "            strcat(buf, \"true\");\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            strcat(buf, \">\");\n" \
  "            strcat(buf, contenu);\n" \
  "        }\n" \
  "\n" \
  "        strcat(buf, \"</\");\n" \
  "        strcat(buf, nom_balise);\n" \
  "        strcat(buf, \">\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr += 2;\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"bonplan_df\", nom_balise))\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_balise);\n" \
  "        strcat(buf, \">\");\n" \
  "        strcat(buf, \"</\");\n" \
  "        strcat(buf, nom_balise);\n" \
  "        strcat(buf, \">\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr += 2;\n" \
  "    }\n" \
  "\n" \
  "    return (lg_ecr);\n" \
  "} /* fin des methodes d'ecriture de balise simple   */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_balise_epj ()                                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit une balise avec le nom des noeud et la valeur            */\n" \
  "/*             correspondante entre les balises avec traitement &,>,<         */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, le contenu et le nom des balises                    */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_balise_epj(char** buf_pos_in, char* contenu, char* nom_balise)\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    int4 lg_ecr, i, j, iLg;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK;\n" \
  "    lg_ecr = 0;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    iLg = strlen(contenu);\n" \
  "\n" \
  "    if (strlen(contenu) > 0)\n" \
  "    {\n" \
  "        j = 0;\n" \
  "\n" \
  "        for (i = 0; i < iLg; i++)\n" \
  "        {\n" \
  "            if ('<' == contenu[i])\n" \
  "            {\n" \
  "                GIVBuffInter[j] = '\\0';\n" \
  "                strcat(GIVBuffInter, \"&lt;\");\n" \
  "                j = strlen(GIVBuffInter);\n" \
  "            }\n" \
  "            else if ('>' == contenu[i])\n" \
  "            {\n" \
  "                GIVBuffInter[j] = '\\0';\n" \
  "                strcat(GIVBuffInter, \"&gt;\");\n" \
  "                j = strlen(GIVBuffInter);\n" \
  "            }\n" \
  "            else if ('\"' == contenu[i])\n" \
  "            {\n" \
  "                GIVBuffInter[j] = '\\0';\n" \
  "                strcat(GIVBuffInter, \"&quot;\");\n" \
  "                j = strlen(GIVBuffInter);\n" \
  "            }\n" \
  "            else if ('&' == contenu[i])\n" \
  "            {\n" \
  "                GIVBuffInter[j] = '\\0';\n" \
  "                strcat(GIVBuffInter, givTrad);\n" \
  "                j = strlen(GIVBuffInter);\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                GIVBuffInter[j] = contenu[i];\n" \
  "                j++;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GIVBuffInter[j] = '\\0';\n" \
  "        /* conversion du XMLType */\n" \
  "        (void)givConvClob();\n" \
  "\n" \
  "        if (0 != strlen(nom_balise))\n" \
  "        {\n" \
  "            strcpy(buf_pos, \"<\");\n" \
  "            strcat(buf_pos, nom_balise);\n" \
  "            strcat(buf_pos, \">\");\n" \
  "        }\n" \
  "\n" \
  "        strcat(buf_pos, GIVBuffInter);\n" \
  "\n" \
  "        if (0 != strlen(nom_balise))\n" \
  "        {\n" \
  "            strcat(buf_pos, \"</\");\n" \
  "            strcat(buf_pos, nom_balise);\n" \
  "            strcat(buf_pos, \">\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "            *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "            lg_ecr += 2;\n" \
  "        }\n" \
  "\n" \
  "        /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "        iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_balise_iso ()                                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit une balise avec le nom des noeud et la valeur            */\n" \
  "/*             correspondante entre les balises avec traitement &,>,<         */\n" \
  "/*             et traduction ASCIAE Iso                                       */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, le contenu et le nom des balises                    */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_balise_iso(char* buf_pos_in, char* contenu, char* nom_balise)\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    int4 lg, lg_ecr, i, j;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK;\n" \
  "    size_t lgInter, lg_in;\n" \
  "    iconv_t iConv;\n" \
  "    char* buf_in;\n" \
  "    char* buf_out;\n" \
  "    lg_ecr = 0;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = buf_pos_in;\n" \
  "    lg = strlen(contenu);\n" \
  "\n" \
  "    if (lg > 0)\n" \
  "    {\n" \
  "        strcpy(GIVBuffInter, contenu);\n" \
  "        j = 0;\n" \
  "\n" \
  "        for (i = 0; i < lg; i++)\n" \
  "        {\n" \
  "            if ('<' == GIVBuffInter[i])\n" \
  "            {\n" \
  "                GIVBuffClob[j] = '\\0';\n" \
  "                strcat(GIVBuffClob, \"&lt;\");\n" \
  "                j = strlen(GIVBuffClob);\n" \
  "            }\n" \
  "            else if ('>' == GIVBuffInter[i])\n" \
  "            {\n" \
  "                GIVBuffClob[j] = '\\0';\n" \
  "                strcat(GIVBuffClob, \"&gt;\");\n" \
  "                j = strlen(GIVBuffClob);\n" \
  "            }\n" \
  "            else if ('&' == GIVBuffInter[i])\n" \
  "            {\n" \
  "                GIVBuffClob[j] = '\\0';\n" \
  "                strcat(GIVBuffClob, givTrad);\n" \
  "                j = strlen(GIVBuffClob);\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                GIVBuffClob[j] = GIVBuffInter[i];\n" \
  "                j++;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GIVBuffClob[j] = '\\0';\n" \
  "        /* Traduction UTF8 */\n" \
  "        iConv = iconv_open(\"UTF-8\", \"ISO8859-1\");\n" \
  "        buf_in = GIVBuffClob;\n" \
  "        lg_in = strlen(GIVBuffClob) + 1;\n" \
  "        buf_out = GIVBuffInter;\n" \
  "        lgInter = sizeof(GIVBuffInter);\n" \
  "\n" \
  "        if ((iconv_t)(-1) != iConv)\n" \
  "        {\n" \
  "            iconv(iConv, &buf_in, (size_t*)&lg_in, &buf_out, (size_t*)&lgInter);\n" \
  "            iconv_close(iConv);\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"libellé iso: <%s>,%d\\n\", GIVBuffInter, lg));\n" \
  "        strcpy(buf_pos, \"<\");\n" \
  "        strcat(buf_pos, nom_balise);\n" \
  "        strcat(buf_pos, \">\");\n" \
  "        strcat(buf_pos, GIVBuffInter);\n" \
  "        strcat(buf_pos, \"</\");\n" \
  "        strcat(buf_pos, nom_balise);\n" \
  "        strcat(buf_pos, \">\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr += 2;\n" \
  "        /* Pas d'Ecriture dans le fichier de sortie sans changement de format */\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Buffer iso: <%s>,%d\\n\", buf_pos, lg));\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_simple ()                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit un noeud avec le nom du  noeud                           */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, le nom du noeud                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_simple(char* buf, char* nom_noeud)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "\n" \
  "    if (strlen(nom_noeud) == 0)\n" \
  "        return (0);\n" \
  "\n" \
  "    if (strlen(nom_noeud) > 0)\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    return (lg_ecr + 2);\n" \
  "} /* Fin ecrire noeud simple */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_attr ()                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit un noeud avec le nom du  noeud                           */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, le nom du noeud                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_attr(char* buf, char* nom_noeud, char* val)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "\n" \
  "    if ((0 == strcmp(nom_noeud, \"equipe\")) && (0 != strlen(val)))\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \" cle=\\\"\");\n" \
  "        strcat(buf, val);\n" \
  "        strcat(buf, \"\\\">\");\n" \
  "    }\n" \
  "    else if ((0 == strcmp(nom_noeud, \"services\")) && (0 != strlen(val)))\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \" cle=\\\"\");\n" \
  "        strcat(buf, val);\n" \
  "        strcat(buf, \"\\\">\");\n" \
  "    }\n" \
  "    else if ((0 == strcmp(nom_noeud, \"cle\")) && (0 != strlen(val)))\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \" type=\\\"PJDOC\\\">\");\n" \
  "        strcat(buf, val);\n" \
  "        strcat(buf, \"</\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "    else if (strlen(nom_noeud) > 0)\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    return (lg_ecr + 2);\n" \
  "} /* Fin ecrire noeud simple */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_fin_noeud ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la fin d'un noeud avec le nom du  noeud                  */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, le nom du noeud                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_fin_noeud(char** buf_pos_in, char* nom_noeud)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "    char* buf_pos;\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    if (strlen(nom_noeud) == 0)\n" \
  "        return (0);\n" \
  "\n" \
  "    if (0 == strcmp(\"document\", nom_noeud))\n" \
  "    {\n" \
  "        strcpy(buf_pos, \"</\");\n" \
  "        strcat(buf_pos, \"blocepj\");\n" \
  "        strcat(buf_pos, \">\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf_pos = (buf_pos + lg_ecr);\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iIntRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "        strcpy(buf_pos, \"</\");\n" \
  "        strcat(buf_pos, \"CONTENT\");\n" \
  "        strcat(buf_pos, \">\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf_pos = (buf_pos + lg_ecr);\n" \
  "        strcpy(buf_pos, \"</\");\n" \
  "        strcat(buf_pos, \"OPERATION\");\n" \
  "        strcat(buf_pos, \">\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf_pos = (buf_pos + lg_ecr);\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"documents\", nom_noeud))\n" \
  "    {\n" \
  "        strcpy(buf_pos, \"</\");\n" \
  "        strcat(buf_pos, \"OPERATIONS\");\n" \
  "        strcat(buf_pos, \">\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        if (strlen(nom_noeud) > 0)\n" \
  "        {\n" \
  "            strcpy(buf_pos, \"</\");\n" \
  "            strcat(buf_pos, nom_noeud);\n" \
  "            strcat(buf_pos, \">\");\n" \
  "        }\n" \
  "\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (lg_ecr);\n" \
  "} /* Fin ecrire fin noeud  */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud ()                                             */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit un noeud avec le nom du noeud et son contenu             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, contenu du noeud, le nom du noeud, denomination     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud(char* buf, char* contenu_noeud, char* nom_noeud, char* name)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "\n" \
  "    if ((0 == memcmp(\"aff\", contenu_noeud, strlen(\"aff\"))) || (0 == memcmp(\"anot\", contenu_noeud, strlen(\"anot\"))))\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, contenu_noeud);\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "    else if (strlen(name) > 0)\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, name);\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, contenu_noeud);\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, nom_noeud);\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    return (lg_ecr + 2);\n" \
  "} /* Fin ecrire noeud */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_element ()                                           */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit un element avec le nom de l'element et                   */\n" \
  "/*             une balise simple suivi de son contenu                         */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, le nom d'element, valeur                            */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_element(char* buf, char* nom, char* valeur)\n" \
  "{\n" \
  "    int4 lg_ecr, lg_write, lg_bal, lg_cpy;\n" \
  "    char* buf_bis = buf;\n" \
  "    char* buf_be = buf;\n" \
  "    int4 iRet;\n" \
  "    lg_ecr = 0;\n" \
  "\n" \
  "    /* S'il y a un mot a ecrire */\n" \
  "    if ((strlen(nom) > 0) && (strlen(valeur) > 0))\n" \
  "    {\n" \
  "        /* Ecrire la balise */\n" \
  "        if ((0 == memcmp(\"pjdep\", nom, strlen(\"pjdep\"))) || (0 == memcmp(\"pjreg\", nom, strlen(\"pjreg\"))) || (0 == memcmp(\"ipjdep\", nom, strlen(\"ipjdep\"))) || (0 == memcmp(\"ipjreg\", nom, strlen(\"ipjreg\")))\n" \
  "                || (NULL != strstr(nom, \"crc\")) || (0 == memcmp(\"pjmotsrubriques\", nom, strlen(\"pjmotsrubriques\"))) || (0 == memcmp(\"pjmotcontenus\", nom, strlen(\"pjmotcontenus\")))\n" \
  "                || (0 == memcmp(\"pjmotscontenusnormalise\", nom, strlen(\"pjmotscontenusnormalise\"))) || (0 == memcmp(\"pjmotscles\", nom, strlen(\"pjmotscles\"))))\n" \
  "        {\n" \
  "            /* suppression des doubles géographiques/an9 */\n" \
  "            iRet = supprimer_doublon(valeur, '|');\n" \
  "        }\n" \
  "        else if (0 == memcmp(\"pjrubriques\", nom, strlen(\"pjrubriques\")))\n" \
  "        {\n" \
  "            /* suppression des doubles géographiques/an9 */\n" \
  "            iRet = supprimer_doublon(valeur, '|');\n" \
  "        }\n" \
  "\n" \
  "        lg_ecr = giv_ecrit_balise(buf_bis, valeur, nom);\n" \
  "    }\n" \
  "\n" \
  "    return (lg_ecr);\n" \
  "} /* Fin ecrire element */\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givEcritureEtab\n" \
  " *\n" \
  " * But : champs du siret.\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabPeeatb.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givEcritureEtab(GYBrDOCUMENTEpj* doc, char** buf_pos_in, int4* apiDeb)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 lg_ecr;\n" \
  "    char* buf_pos;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPeEtabT rEtab;\n" \
  "    GYBrIndPeEtabT rIndEtab;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(rEtab.acEtab, doc->value.a_classer.etab);\n" \
  "    lg_ecr = 0;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    doc->value.a_classer.opphoto = '\\0';\n" \
  "    doc->value.a_classer.parinsee = '0';\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureEtab\n" \
  "    USING: rEtab.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureEtab\n" \
  "        INTO\n" \
  "        :rEtab.acDenom\n" \
  "        :rIndEtab.sDenomI,\n" \
  "        :rEtab.acNomDirgt:rIndEtab.sNomDirgtI,\n" \
  "        :rEtab.acParInsee,\n" \
  "        :rEtab.acRS:rIndEtab.sRSI,\n" \
  "        :rEtab.acRSCompl:rIndEtab.sRSComplI,\n" \
  "        :rEtab.acEnsgne:rIndEtab.sEnsgneI,\n" \
  "        :rEtab.acSigle:rIndEtab.sSigleI,\n" \
  "        :rEtab.acOppPhoto;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            doc->value.a_classer.opphoto = rEtab.acOppPhoto;\n" \
  "            doc->value.a_classer.parinsee = rEtab.acParInsee;\n" \
  "\n" \
  "            if (1 == *apiDeb)\n" \
  "                *apiDeb = 0;\n" \
  "\n" \
  "            if ('1' != rEtab.acParInsee)\n" \
  "            {\n" \
  "                /* opposition sur les données Insee */\n" \
  "                rIndEtab.sRSI = (int4)GIV::GYBnok;\n" \
  "                rIndEtab.sEnsgneI = (int4)GIV::GYBnok;\n" \
  "                rIndEtab.sSigleI = (int4)GIV::GYBnok;\n" \
  "                rIndEtab.sRSComplI = (int4)GIV::GYBnok;\n" \
  "            }\n" \
  "\n" \
  "            strcpy(buf_pos, \"<intitulesiret etab=\\\"\");\n" \
  "            strcat(buf_pos, doc->value.a_classer.etab);\n" \
  "            strcat(buf_pos, \"\\\">\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "            *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "            lg_ecr = lg_ecr + 2;\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == rIndEtab.sNomDirgtI)\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acNomDirgt, \"nomdirigeant\");\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == rIndEtab.sRSI)\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acRS, \"siretrs\");\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == rIndEtab.sRSComplI)\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acRSCompl, \"siretrscompl\");\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == rIndEtab.sEnsgneI)\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acEnsgne, \"siretenseigne\");\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == rIndEtab.sSigleI)\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acSigle, \"siretsigle\");\n" \
  "\n" \
  "            lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"intitulesiret\");\n" \
  "            buf_pos = buf_pos + lg_ecr;\n" \
  "        }\n" \
  "\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givEcritureDenomEtab\n" \
  " *\n" \
  " * But : champs de dénominations secondaires.\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabDenomsEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givEcritureDenomEtab(GYBrDOCUMENTEpj* doc, char** buf_pos_in, int4* apiDeb)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 lg_ecr, i, j;\n" \
  "    char* buf_pos;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPeEtabT rEtab;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(rEtab.acEtab, doc->value.a_classer.etab);\n" \
  "    lg_ecr = 0;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureDenomEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureDenomEtab\n" \
  "    USING: rEtab.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureDenomEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* écriture utf8 */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    while ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureDenomEtab\n" \
  "        INTO\n" \
  "        :rEtab.acParInsee,\n" \
  "        :rEtab.acDenom;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            if ('6' != rEtab.acParInsee)\n" \
  "            {\n" \
  "                /* seul libref traité */\n" \
  "                continue;\n" \
  "            }\n" \
  "\n" \
  "            if (1 == *apiDeb)\n" \
  "            {\n" \
  "                strcpy(buf_pos, \"<intitulelibref etab=\\\"\");\n" \
  "                strcat(buf_pos, rEtab.acEtab);\n" \
  "                strcat(buf_pos, \"\\\">\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "                lg_ecr = lg_ecr + 2;\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                /* écriture utf8 */\n" \
  "                iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "                *apiDeb = 0;\n" \
  "            }\n" \
  "\n" \
  "            lg_ecr = giv_ecrit_balise_epj(&buf_pos, rEtab.acDenom, \"denomlibref\");\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureDenomEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureDenomEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if (0 == *apiDeb)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"intitulelibref\");\n" \
  "        buf_pos = buf_pos + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"crsLectureDenomEtab: <%s> <%c>]\\n\", doc->value.a_classer.etab, doc->value.a_classer.parinsee));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureObjetsEtab\n" \
  " *\n" \
  " * But : champs des objets pub de l'établissement.\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabPeeatb.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureObjetsEtab(char* apcEtab, GYBrDOCUMENTEpj* doc, int4 iNb)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraEtab;\n" \
  "    GYBrIamicT rIamicEtab;\n" \
  "    GYBrIamicT rIamicClient;\n" \
  "    GYBrIndIamicT rIndIamic;\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraEtab\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    time_t date;\n" \
  "    int4 i, j, x, y, z, iRef;\n" \
  "    GYBrIapartT rIapart;\n" \
  "    int4 iPJDC, iCHRO;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    iPJDC = -1;\n" \
  "    iCHRO = GIV::GIXCodeKO;\n" \
  "    pcOraEtab = apcEtab;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLecturePubEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLecturePubEtab\n" \
  "    USING :pcOraEtab,\n" \
  "    :pcOraEtab,\n" \
  "    :pcOraEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLecturePubEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    while ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLecturePubEtab\n" \
  "        INTO\n" \
  "        :rIamicEtab.acNumobj\n" \
  "        :rIndIamic.sNumobjI,\n" \
  "        :rIamicEtab.acTpdsob,\n" \
  "        :rIamicEtab.acStobj,\n" \
  "        :rIamicClient.acNumobj:rIndIamic.sNumobjI,\n" \
  "        :rIamicEtab.acDatact:rIndIamic.sDatactI;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            nb_micro = doc->value.objets_pub.nb_micro;\n" \
  "\n" \
  "            if ((0 == strcmp(rIamicEtab.acTpdsob, giv_sCHRO)) && (0 == strcmp(rIamicEtab.acStobj, giv_ssCHRO)) && (NULL == strstr(givtcFourPart, giv_CHRO)))\n" \
  "            {\n" \
  "                /* protection car LC-CH remplacé par le partenaire CHRONORESTO */\n" \
  "                continue;\n" \
  "            }\n" \
  "\n" \
  "            if ((0 == strcmp(rIamicEtab.acTpdsob, giv_sPJDC)) && (0 == strcmp(rIamicEtab.acStobj, giv_ssPJDC)) && (NULL == strstr(givtcFourPart, giv_PJDC)))\n" \
  "            {\n" \
  "                /* protection car LP-CR remplacé par le partenaire PJDOC */\n" \
  "                iPJDC = nb_micro;\n" \
  "            }\n" \
  "\n" \
  "            if (-1 == rIndIamic.sDatactI)\n" \
  "                rIamicEtab.acDatact[0] = '\\0';\n" \
  "\n" \
  "            if (-1 == rIndIamic.sNumobjI)\n" \
  "            {\n" \
  "                strcpy(rIamicEtab.acNumobj, \"0002\");\n" \
  "                strcat(rIamicEtab.acNumobj, apcEtab);\n" \
  "                strcat(rIamicEtab.acNumobj, \"0001\");\n" \
  "                date = time(NULL);\n" \
  "                (void)strftime(rIamicEtab.acDatact, sizeof(rIamicEtab.acDatact), \"%Y%m%d\", localtime(&date));\n" \
  "            }\n" \
  "\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].type, \"X\");\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stype, rIamicEtab.acTpdsob);\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].sstype, rIamicEtab.acStobj);\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].id, rIamicEtab.acNumobj);\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, rIamicEtab.acDatact);\n" \
  "            doc->value.objets_pub.micro[nb_micro].valeur[0] = '\\0';\n" \
  "            doc->value.objets_pub.micro[nb_micro].iCVI = 0;\n" \
  "            doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\\0';\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stypint, rIamicEtab.acTpdsob);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Objet etab : %s,%s,%s\\n\", rIamicEtab.acTpdsob, rIamicEtab.acStobj, rIamicEtab.acNumobj));\n" \
  "            nb_micro++;\n" \
  "            doc->value.objets_pub.nb_micro = nb_micro;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLecturePubEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLecturePubEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* ajout de l'objet LC-CH pour le partenaire CHRONORESTO */\n" \
  "    for (x = 0; x < iNb; x++)\n" \
  "    {\n" \
  "        for (i = 0; i < (doc + x)->value.a_classer.iNbPart; i++)\n" \
  "        {\n" \
  "            iRef = strlen((doc + x)->value.a_classer.trpart[i].rpart);\n" \
  "            (void)strcpy(rIapart.acOriPart, &(doc + x)->value.a_classer.trpart[i].rpart[iRef - 4]);\n" \
  "\n" \
  "            if (((0 == strcmp(rIapart.acOriPart, giv_CHRO)) && (NULL == strstr(givtcFourPart, rIapart.acOriPart)) && (GIV::GIXCodeKO == iCHRO)) || ((0 == strcmp(rIapart.acOriPart, giv_PJDC))\n" \
  "                    && (NULL == strstr(givtcFourPart, rIapart.acOriPart)) && (-1 == iPJDC)))\n" \
  "            {\n" \
  "                nb_micro = doc->value.objets_pub.nb_micro;\n" \
  "                strcpy(doc->value.objets_pub.micro[nb_micro].type, \"X\");\n" \
  "                strcpy(rIamicEtab.acNumobj, \"0002\");\n" \
  "                strcat(rIamicEtab.acNumobj, apcEtab);\n" \
  "                strcat(rIamicEtab.acNumobj, \"0001\");\n" \
  "                date = time(NULL);\n" \
  "                (void)strftime(rIamicEtab.acDatact, sizeof(rIamicEtab.acDatact), \"%Y%m%d\", localtime(&date));\n" \
  "\n" \
  "                if (0 == strcmp(rIapart.acOriPart, giv_CHRO))\n" \
  "                {\n" \
  "                    strcpy(doc->value.objets_pub.micro[nb_micro].stype, giv_sCHRO);\n" \
  "                    strcpy(doc->value.objets_pub.micro[nb_micro].sstype, giv_ssCHRO);\n" \
  "                    doc->value.objets_pub.micro[nb_micro].valeur[0] = '\\0';\n" \
  "                    iCHRO = GIV::GIXCodeOK;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    strcpy(doc->value.objets_pub.micro[nb_micro].stype, giv_sPJDC);\n" \
  "                    strcpy(doc->value.objets_pub.micro[nb_micro].sstype, giv_ssPJDC);\n" \
  "                    iRef -= 4;\n" \
  "\n" \
  "                    for (y = 0; (y < iRef && 0 == isdigit((doc + x)->value.a_classer.trpart[i].rpart[y])); y++)\n" \
  "                        ;\n" \
  "\n" \
  "                    for (z = y; (z < iRef && 0 != isdigit((doc + x)->value.a_classer.trpart[i].rpart[z])); z++)\n" \
  "                        ;\n" \
  "\n" \
  "                    (void)memcpy(doc->value.objets_pub.micro[nb_micro].valeur, &(doc + x)->value.a_classer.trpart[i].rpart[y], z - y);\n" \
  "                    doc->value.objets_pub.micro[nb_micro].valeur[z - y] = '\\0';\n" \
  "                    iPJDC = nb_micro;\n" \
  "                }\n" \
  "\n" \
  "                strcpy(doc->value.objets_pub.micro[nb_micro].id, rIamicEtab.acNumobj);\n" \
  "                strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, rIamicEtab.acDatact);\n" \
  "                doc->value.objets_pub.micro[nb_micro].iCVI = 0;\n" \
  "                doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\\0';\n" \
  "                strcpy(doc->value.objets_pub.micro[nb_micro].stypint, doc->value.objets_pub.micro[nb_micro].stype);\n" \
  "                nb_micro++;\n" \
  "                doc->value.objets_pub.nb_micro = nb_micro;\n" \
  "            }\n" \
  "            else if ((0 == strcmp(rIapart.acOriPart, giv_PJDC)) && (NULL == strstr(givtcFourPart, rIapart.acOriPart)) && (-1 != iPJDC))\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"LP CR modifié pour PJDC %d, %s\\n\", iPJDC, (doc + x)->value.a_classer.trpart[i].rpart));\n" \
  "                strcpy(rIamicEtab.acNumobj, \"0002\");\n" \
  "                strcat(rIamicEtab.acNumobj, apcEtab);\n" \
  "                strcat(rIamicEtab.acNumobj, \"0001\");\n" \
  "                strcpy(doc->value.objets_pub.micro[iPJDC].id, rIamicEtab.acNumobj);\n" \
  "                iRef -= 4;\n" \
  "\n" \
  "                for (y = 0; (y < iRef && 0 == isdigit((doc + x)->value.a_classer.trpart[i].rpart[y])); y++)\n" \
  "                    ;\n" \
  "\n" \
  "                for (z = y; (z < iRef && 0 != isdigit((doc + x)->value.a_classer.trpart[i].rpart[z])); z++)\n" \
  "                    ;\n" \
  "\n" \
  "                (void)memcpy(doc->value.objets_pub.micro[nb_micro].valeur, &(doc + x)->value.a_classer.trpart[i].rpart[y], z - y);\n" \
  "                doc->value.objets_pub.micro[nb_micro].valeur[z - y] = '\\0';\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((GIV::GIXCodeOK == iCHRO) && (-1 != iPJDC))\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; (i < iNb && -1 != iPJDC); i++)\n" \
  "    {\n" \
  "        /* recherche de l'existence d'une rubrique de type santé pour PJDOC */\n" \
  "        for (j = 0; (j < (doc + i)->value.rubriques.iNban9 && '0' == (doc + i)->value.rubriques.Tan9[j].dnex); j++)\n" \
  "            ;\n" \
  "\n" \
  "        if ((doc + i)->value.rubriques.iNban9 != j)\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    if ((-1 != iPJDC) && (iNb != i))\n" \
  "    {\n" \
  "        /* ajout du produit fictif de ranking PJDOC */\n" \
  "        nb_micro = doc->value.objets_pub.nb_micro;\n" \
  "        strcpy(doc->value.objets_pub.micro[nb_micro].type, \"X\");\n" \
  "        strcpy(rIamicEtab.acNumobj, \"0001\");\n" \
  "        strcat(rIamicEtab.acNumobj, apcEtab);\n" \
  "        strcat(rIamicEtab.acNumobj, \"0001\");\n" \
  "        date = time(NULL);\n" \
  "        (void)strftime(rIamicEtab.acDatact, sizeof(rIamicEtab.acDatact), \"%Y%m%d\", localtime(&date));\n" \
  "        strcpy(doc->value.objets_pub.micro[nb_micro].stype, giv_sRKPJDC);\n" \
  "        strcpy(doc->value.objets_pub.micro[nb_micro].sstype, giv_sRKPJDC);\n" \
  "        doc->value.objets_pub.micro[nb_micro].valeur[0] = '\\0';\n" \
  "        strcpy(doc->value.objets_pub.micro[nb_micro].id, rIamicEtab.acNumobj);\n" \
  "        strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, rIamicEtab.acDatact);\n" \
  "        doc->value.objets_pub.micro[nb_micro].iCVI = 0;\n" \
  "        doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\\0';\n" \
  "        strcpy(doc->value.objets_pub.micro[nb_micro].stypint, doc->value.objets_pub.micro[nb_micro].stype);\n" \
  "        nb_micro++;\n" \
  "        doc->value.objets_pub.nb_micro = nb_micro;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLecturePhotosEtab\n" \
  " *\n" \
  " * But : champs des photos de l'établissement.\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabPhotoEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLecturePhotosEtab(GYBrDOCUMENTEpj* doc, char** buf_pos_in, int4* apiDeb)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    int4 lg_ecr;\n" \
  "    char* buf_pos;\n" \
  "    int4 iDeb;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPhotosEtabT rPhoto;\n" \
  "    GYBrIndPhotosEtabT rIndPhoto;\n" \
  "    OCIClobLocator* pClob;\n" \
  "    int2 sIndI;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(rPhoto.acEtab, doc->value.a_classer.etab);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Photos pour Etab: %s\\n\", rPhoto.acEtab));\n" \
  "    lg_ecr = 0;\n" \
  "    iDeb = 0;\n" \
  "    GIVBuffInter[0] = '\\0';\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLecturePhotosEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLecturePhotosEtab\n" \
  "    USING: rPhoto.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsLecturePhotosEtab: [COD=%d TXT=%s] -%s-\\n\", iIntRet, vErreurSQL.acDonnees_retour, rPhoto.acEtab));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Allocate de CLOB\");\n" \
  "        EXEC SQL\n" \
  "        ALLOCATE: pClob;\n" \
  "        EXEC SQL\n" \
  "        LOB CREATE\n" \
  "        TEMPORARY: pClob;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Allocation CLOB pour GYTtabPhotosEtab\\n\"));\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            close crsLecturePhotosEtab;\n" \
  "            iCodRet = iIntRet;\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLecturePhotosEtab\n" \
  "            INTO\n" \
  "            :rPhoto.acPhoto\n" \
  "            :rIndPhoto.sPhotoI,\n" \
  "            :rPhoto.acTitre:rIndPhoto.sTitreI,\n" \
  "            :rPhoto.acCteUtil:rIndPhoto.sCteUtilI,\n" \
  "            :rPhoto.acOri:rIndPhoto.sOriI,\n" \
  "            :pClob:sIndI;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Photos pour Etab: %d,%d\\n\", iIntRet, sIndI));\n" \
  "\n" \
  "            if (1 == *apiDeb)\n" \
  "            {\n" \
  "                lg_ecr = giv_ecrit_noeud_simple(buf_pos, \"affugc\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "                *apiDeb = 0;\n" \
  "            }\n" \
  "\n" \
  "            if (0 == iDeb)\n" \
  "            {\n" \
  "                if (((int4)GIV::GYBnodata == iIntRet) && ('1' != doc->value.a_classer.opphoto))\n" \
  "                {\n" \
  "                    /* Etab sans photo et sans opposition photo : on n'écrit pas le bloc <ugcetab> */\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                strcpy(buf_pos, \"<ugcetab id=\\\"\");\n" \
  "                strcat(buf_pos, doc->value.a_classer.etab);\n" \
  "                strcat(buf_pos, \"\\\">\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "                lg_ecr = lg_ecr + 2;\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                strcpy(buf_pos, \"<oppphotos>\");\n" \
  "\n" \
  "                if ('1' == doc->value.a_classer.opphoto)\n" \
  "                    strcat(buf_pos, \"ugc\");\n" \
  "\n" \
  "                strcat(buf_pos, \"</oppphotos>\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "                lg_ecr = lg_ecr + 2;\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                lg_ecr = giv_ecrit_noeud_simple(buf_pos, \"ugcphotos\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "            }\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == iIntRet)\n" \
  "            {\n" \
  "                lg_ecr = giv_ecrit_noeud_simple(buf_pos, \"photo\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndPhoto.sPhotoI)\n" \
  "                    rPhoto.acPhoto[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndPhoto.sTitreI)\n" \
  "                    rPhoto.acTitre[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndPhoto.sCteUtilI)\n" \
  "                    rPhoto.acCteUtil[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndPhoto.sOriI)\n" \
  "                    rPhoto.acOri[0] = '\\0';\n" \
  "\n" \
  "                rPhoto.acLongitude[0] = '\\0';\n" \
  "                rPhoto.acLatitude[0] = '\\0';\n" \
  "                iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acPhoto, \"identifiantphoto\");\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acTitre, \"legende\");\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acOri, \"origine\");\n" \
  "                lg_ecr = giv_ecrit_balise_epj(&buf_pos, rPhoto.acCteUtil, \"uid\");\n" \
  "\n" \
  "                if ((int4)GIV::GYBok == sIndI)\n" \
  "                {\n" \
  "                    EXEC SQL\n" \
  "                    LOB\n" \
  "                    OPEN :pClob READ\n" \
  "                    ONLY;\n" \
  "                    /* lecture des données xmltype */\n" \
  "                    givLectClob(pClob, doc->value.a_classer.etab, \"\", giv_PHO, giv_PHO);\n" \
  "                    /* conversion du XMLType */\n" \
  "                    (void)givConvClob();\n" \
  "\n" \
  "                    if (0 != strlen(GIVBuffInter))\n" \
  "                    {\n" \
  "                        strcpy(buf_pos, GIVBuffInter);\n" \
  "                        lg_ecr = strlen(buf_pos);\n" \
  "                        buf_pos = (buf_pos + lg_ecr);\n" \
  "                    }\n" \
  "\n" \
  "                    EXEC SQL\n" \
  "                    LOB\n" \
  "                    CLOSE: pClob;\n" \
  "                }\n" \
  "\n" \
  "                lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"photo\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "                iDeb = 1;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* fin de boucle */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"ugcphotos\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "                lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"ugcetab\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "                iDeb = 1;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        close crsLecturePhotosEtab;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLecturePhotosEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Liberation CLOB pour GYTtabPhotosEtab\\n\"));\n" \
  "        /* liberation CLOB */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Liberation de CLOB\");\n" \
  "        EXEC SQL\n" \
  "        LOB FREE\n" \
  "        TEMPORARY: pClob;\n" \
  "        EXEC SQL\n" \
  "        FREE: pClob;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur libération Clob PhotosEtab\\n\"));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givExtractPartEtab\n" \
  " *\n" \
  " * But : champs du calendrier et des photos du partenaire.\n" \
  " *\n" \
  " * Description : extract\n" \
  " *               dans la table GYTtabPartEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givExtractPartEtab(GYBrIapartT* aprPart, char** buf_pos_in, char* apcType)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    int4 lg_ecr;\n" \
  "    char* buf_pos;\n" \
  "    int4 iDeb;\n" \
  "    int4 iLgBuffer;\n" \
  "    int4 iLgRequete;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cRequete[giv_LG_REQUETE * 4];\n" \
  "    GYBrIapartT rPart;\n" \
  "    static OCIClobLocator* pClob;\n" \
  "    int2 sIndI;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(rPart.acOriPart, aprPart->acOriPart);\n" \
  "    (void)strcpy(rPart.acRefPart, aprPart->acRefPart);\n" \
  "    lg_ecr = 0;\n" \
  "    iDeb = 0;\n" \
  "    GIVBuffInter[0] = '\\0';\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "    indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iDejaPrepare)\n" \
  "    {\n" \
  "        /* Controle de la longueur du texte de la requete */\n" \
  "        iLgRequete = strlen(GIV_RQ_SELECT_CALEND_PART);\n" \
  "        iLgBuffer = sizeof(cRequete);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Longueurs : (requete -> %d  buffer -> %d)\\n\", iLgRequete, iLgBuffer));\n" \
  "\n" \
  "        if (iLgBuffer <= iLgRequete)\n" \
  "        {\n" \
  "            /* Buffer locale trop petit pour la requete => probleme EVIDENT !!! */\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        /* Construction du texte de la requete */\n" \
  "        if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "        {\n" \
  "            (void)sprintf(cRequete,\n" \
  "                          GIV_RQ_SELECT_PHOTO_PART);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "            /* Controle et parsing de la requete SQL */\n" \
  "            EXEC SQL\n" \
  "            prepare rqtLecturePhotoPart\n" \
  "            from: cRequete;\n" \
  "            /* Traitement des erreurs SQL */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLecturePhotoPart\");\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLecturePhotoPart : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "                (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLecturePhotoPart\");\n" \
  "                EXEC SQL\n" \
  "                declare crsLecturePhotoPart\n" \
  "                cursor\n" \
  "                for rqtLecturePhotoPart;\n" \
  "                iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != iIntRet)\n" \
  "                {\n" \
  "                    /* Erreur sur declaration curseur SQL */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLecturePhotoPart ...\\n\"));\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            (void)sprintf(cRequete,\n" \
  "                          GIV_RQ_SELECT_CALEND_PART);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Requetee SQL : %s\\n\", cRequete));\n" \
  "            /* Controle et parsing de la requete SQL */\n" \
  "            EXEC SQL\n" \
  "            prepare rqtLectureCalendPart\n" \
  "            from: cRequete;\n" \
  "            /* Traitement des erreurs SQL */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"prepare rqtLectureCalendPart\");\n" \
  "            iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur prepare rqtLectureCalendPart : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* Declaration curseur SQL (car requete type SELECT) */\n" \
  "                (void)strcpy(vErreurSQL.acOrdre_sql, \"declare crsLectureCalendPart\");\n" \
  "                EXEC SQL\n" \
  "                declare crsLectureCalendPart\n" \
  "                cursor\n" \
  "                for rqtLectureCalendPart;\n" \
  "                iIntRet = GYBErreur(&vErreurSQL);\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != iIntRet)\n" \
  "                {\n" \
  "                    /* Erreur sur declaration curseur SQL */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Erreur DECLARE crsLectureCalendPart ...\\n\"));\n" \
  "                    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Allocate de CLOB\");\n" \
  "        EXEC SQL\n" \
  "        ALLOCATE: pClob;\n" \
  "        EXEC SQL\n" \
  "        LOB CREATE\n" \
  "        TEMPORARY: pClob;\n" \
  "        /* EXEC SQL LOB OPEN :pClob READ ONLY; */\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Allocation CLOB pour GYTtabPhotoPart\\n\"));\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "        {\n" \
  "            iCodRet = iIntRet;\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLecturePhotoPart\");\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Appel PhotoPart: %s,%s\\n\", rPart.acOriPart, rPart.acRefPart));\n" \
  "\n" \
  "    if (0 == strcmp(giv_PHO, apcType))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        OPEN crsLecturePhotoPart\n" \
  "        USING :rPart.acOriPart,\n" \
  "        :rPart.acRefPart;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        OPEN crsLectureCalendPart\n" \
  "        USING :rPart.acOriPart,\n" \
  "        :rPart.acRefPart;\n" \
  "    }\n" \
  "\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsLecturePhotoPart: [COD=%d TXT=%s] -%s-\\n\", iIntRet, vErreurSQL.acDonnees_retour, rPart.acRefPart));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "    {\n" \
  "        if (0 == strcmp(giv_PHO, apcType))\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLecturePhotoPart\n" \
  "            INTO: pClob: sIndI;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureCalendPart\n" \
  "            INTO: pClob: sIndI;\n" \
  "        }\n" \
  "\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            if ((int4)GIV::GYBok == sIndI)\n" \
  "            {\n" \
  "                /* lecture des données xmltype */\n" \
  "                givLectClob(pClob, \"\", aprPart->acRefPart, apcType, apcType);\n" \
  "                /* conversion du XMLType */\n" \
  "                (void)givConvClob();\n" \
  "\n" \
  "                if (0 != strlen(GIVBuffInter))\n" \
  "                {\n" \
  "                    strcpy(buf_pos, GIVBuffInter);\n" \
  "                    lg_ecr = strlen(buf_pos);\n" \
  "                    buf_pos = (buf_pos + lg_ecr);\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* fin de boucle */\n" \
  "            indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* fin de boucle */\n" \
  "            indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (0 == strcmp(giv_PHO, apcType))\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsLecturePhotoPart;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        close crsLectureCalendPart;\n" \
  "    }\n" \
  "\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLecturePhotoPart: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureLvsSeoEtab\n" \
  " *\n" \
  " * But : champs des liens vers les sites issus de SEO.\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabLvsSeoEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureLvsSeoEtab(GYBrDOCUMENTEpj* doc, char** buf_pos_in, int4* apiDeb)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    int4 lg_ecr;\n" \
  "    char* buf_pos;\n" \
  "    int4 iDeb;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrLvsSeoEtabT rLvs;\n" \
  "    GYBrIndLvsSeoEtabT rIndLvs;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(rLvs.acEtab, doc->value.a_classer.etab);\n" \
  "    lg_ecr = 0;\n" \
  "    iDeb = 0;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureLvsSeoEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureLvsSeoEtab\n" \
  "    USING: rLvs.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsLectureLvsSeoEtab: [COD=%d TXT=%s] -%s-\\n\", iIntRet, vErreurSQL.acDonnees_retour, rLvs.acEtab));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureLvsSeoEtab\n" \
  "            INTO\n" \
  "            :rLvs.acIdstat\n" \
  "            :rIndLvs.sIdstatI,\n" \
  "            :rLvs.acPartseo:rIndLvs.sPartseoI,\n" \
  "            :rLvs.acUrlseo:rIndLvs.sUrlseoI,\n" \
  "            :rLvs.acAncre:rIndLvs.sAncreI,\n" \
  "            :rLvs.acFollow:rIndLvs.sFollowI,\n" \
  "            :rLvs.acOrdre:rIndLvs.sOrdreI;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == iIntRet)\n" \
  "            {\n" \
  "                if (1 == *apiDeb)\n" \
  "                {\n" \
  "                    lg_ecr = giv_ecrit_noeud_simple(buf_pos, \"lvsparts\");\n" \
  "                    buf_pos = buf_pos + lg_ecr;\n" \
  "                    *apiDeb = 0;\n" \
  "                }\n" \
  "\n" \
  "                strcpy(buf_pos, \"<lvspart etab=\\\"\");\n" \
  "                strcat(buf_pos, doc->value.a_classer.etab);\n" \
  "                strcat(buf_pos, \"\\\">\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "                lg_ecr = lg_ecr + 2;\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLvs.sIdstatI)\n" \
  "                    rLvs.acIdstat[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLvs.sPartseoI)\n" \
  "                    rLvs.acPartseo[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLvs.sUrlseoI)\n" \
  "                    rLvs.acUrlseo[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLvs.sAncreI)\n" \
  "                    rLvs.acAncre[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLvs.sFollowI)\n" \
  "                    rLvs.acFollow[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLvs.sOrdreI)\n" \
  "                    rLvs.acOrdre[0] = '\\0';\n" \
  "\n" \
  "                lg_ecr = giv_ecrit_balise(buf_pos, rLvs.acIdstat, \"idstat\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "                iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "                if ((int4)GIV::GYBok == rIndLvs.sPartseoI)\n" \
  "                    lg_ecr = giv_ecrit_balise_epj(&buf_pos, rLvs.acPartseo, \"partenaire\");\n" \
  "\n" \
  "                if ((int4)GIV::GYBok == rIndLvs.sUrlseoI)\n" \
  "                {\n" \
  "                    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                    (void)strcpy(GIVBuffInter, rLvs.acUrlseo);\n" \
  "                    (void)givConvClob();\n" \
  "                    (void)strcpy(buf_concat, \"<![CDATA[\");\n" \
  "                    (void)strcat(buf_concat, GIVBuffInter);\n" \
  "                    (void)strcat(buf_concat, \"]]>\");\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"URL DATA: %s\\n\", buf_concat));\n" \
  "                    lg_ecr = giv_ecrit_balise(buf_pos, buf_concat, \"url\");\n" \
  "                    buf_pos = buf_pos + lg_ecr;\n" \
  "                    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                }\n" \
  "\n" \
  "                if ((int4)GIV::GYBok == rIndLvs.sAncreI)\n" \
  "                {\n" \
  "                    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                    (void)strcpy(GIVBuffInter, rLvs.acAncre);\n" \
  "                    (void)givConvClob();\n" \
  "                    (void)strcpy(buf_concat, \"<![CDATA[\");\n" \
  "                    (void)strcat(buf_concat, GIVBuffInter);\n" \
  "                    (void)strcat(buf_concat, \"]]>\");\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"ANCRE DATA: %s\\n\", buf_concat));\n" \
  "                    lg_ecr = giv_ecrit_balise(buf_pos, buf_concat, \"ancre\");\n" \
  "                    buf_pos = buf_pos + lg_ecr;\n" \
  "                    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                }\n" \
  "\n" \
  "                lg_ecr = giv_ecrit_balise(buf_pos, rLvs.acFollow, \"follow\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "                lg_ecr = giv_ecrit_balise(buf_pos, rLvs.acOrdre, \"ordre\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "                lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"lvspart\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* fin de boucle */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        close crsLectureLvsSeoEtab;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureLvsSeoEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        /* ecriture */\n" \
  "        iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureLiensEtab\n" \
  " *\n" \
  " * But : champs des liens par epj.\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabLvsEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureLiensEtab(GYBrDOCUMENTEpj* doc, char** buf_pos_in, int4* apiDeb, int4 iNb)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    int4 lg_ecr;\n" \
  "    char* buf_pos;\n" \
  "    int4 iDeb, iRef;\n" \
  "    GYBrIapartT rIapart;\n" \
  "    int4 i, k, kk, x;\n" \
  "    int4 iRang, iObj;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrLienEtabT rLien;\n" \
  "    GYBrIndLienEtabT rIndLien;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    (void)strcpy(rLien.acEtab, doc->value.a_classer.etab);\n" \
  "    lg_ecr = 0;\n" \
  "    iDeb = 0;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureLiensEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureLiensEtab\n" \
  "    USING: rLien.acEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur open crsLectureLiensEtab: [COD=%d TXT=%s] -%s-\\n\", iIntRet, vErreurSQL.acDonnees_retour, rLien.acEtab));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureLiensEtab\n" \
  "            INTO\n" \
  "            :rLien.acTpdsob,\n" \
  "            :rLien.acStobj,\n" \
  "            :rLien.acNumobj,\n" \
  "            :rLien.acCle:rIndLien.sCleI,\n" \
  "            :rLien.acValeur:rIndLien.sValeurI;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == iIntRet)\n" \
  "            {\n" \
  "                if ((0 == strcmp(rLien.acTpdsob, giv_sCHRO)) && (0 == strcmp(rLien.acStobj, giv_ssCHRO)) && (NULL == strstr(givtcFourPart, giv_CHRO)))\n" \
  "                {\n" \
  "                    for (x = 0; x < iNb; x++)\n" \
  "                    {\n" \
  "                        for (i = 0; i < (doc + x)->value.a_classer.iNbPart; i++)\n" \
  "                        {\n" \
  "                            /* ajout de LC-CH si partenaire CHRONORESTO */\n" \
  "                            iRef = strlen((doc + x)->value.a_classer.trpart[i].rpart);\n" \
  "                            (void)strcpy(rIapart.acOriPart, &(doc + x)->value.a_classer.trpart[i].rpart[iRef - 4]);\n" \
  "\n" \
  "                            if (0 == strcmp(rIapart.acOriPart, giv_CHRO))\n" \
  "                                break;\n" \
  "                        }\n" \
  "\n" \
  "                        if ((doc + x)->value.a_classer.iNbPart != i)\n" \
  "                            break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (iNb == x)\n" \
  "                    {\n" \
  "                        /* LC-CH non remplacé par le partenaire CHRONORESTO */\n" \
  "                        continue;\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                if (1 == *apiDeb)\n" \
  "                {\n" \
  "                    lg_ecr = giv_ecrit_noeud_simple(buf_pos, \"elementsproduits\");\n" \
  "                    buf_pos = buf_pos + lg_ecr;\n" \
  "                    *apiDeb = 0;\n" \
  "                }\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLien.sCleI)\n" \
  "                    rLien.acCle[0] = '\\0';\n" \
  "\n" \
  "                buf_concat[0] = '\\0';\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != rIndLien.sValeurI)\n" \
  "                    rLien.acValeur[0] = '\\0';\n" \
  "                else\n" \
  "                    givConvURL(rLien.acValeur);\n" \
  "\n" \
  "                iRang = -1;\n" \
  "\n" \
  "                for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "                {\n" \
  "                    k = givrListObj.trEltRangListObj[i];\n" \
  "                    kk = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "                    iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "                    if (iRang != givrListObj.trEltListObj[k].iRangTri)\n" \
  "                    {\n" \
  "                        iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "\n" \
  "                        if (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, rLien.acTpdsob) && 0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, rLien.acStobj)\n" \
  "                                && 0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].id, rLien.acNumobj))\n" \
  "                        {\n" \
  "                            if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, giv_sPJDC)) && (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, giv_ssPJDC))\n" \
  "                                    && (0 != strlen((doc + kk)->value.objets_pub.micro[iObj].valeur)))\n" \
  "                            {\n" \
  "                                /* si LP-CR pour PJDC */\n" \
  "                                /* garder valeur du partenaire */\n" \
  "                            }\n" \
  "                            else\n" \
  "                            {\n" \
  "                                strcpy((doc + kk)->value.objets_pub.micro[iObj].valeur, buf_concat);\n" \
  "                                break;\n" \
  "                            }\n" \
  "                        }\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                strcpy(buf_pos, \"<reference id=\\\"\");\n" \
  "                strcat(buf_pos, rLien.acNumobj);\n" \
  "                strcat(buf_pos, \"\\\" pjproduits=\\\"X\");\n" \
  "                strcat(buf_pos, rLien.acTpdsob);\n" \
  "                strcat(buf_pos, rLien.acStobj);\n" \
  "                strcat(buf_pos, \"\\\">\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "                lg_ecr = lg_ecr + 2;\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                strcpy(buf_pos, \"<clevaleur cle=\\\"\");\n" \
  "                strcat(buf_pos, rLien.acCle);\n" \
  "                strcat(buf_pos, \"\\\">\");\n" \
  "                strcat(buf_pos, buf_concat);\n" \
  "                strcat(buf_pos, \"</clevaleur>\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "                lg_ecr = lg_ecr + 2;\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                lg_ecr = giv_ecrit_fin_noeud(&buf_pos, \"reference\");\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* fin de boucle */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        EXEC SQL\n" \
  "        close crsLectureLiensEtab;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok != iIntRet)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureLiensEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        /* ecriture */\n" \
  "        iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureObjetsGCpt\n" \
  " *\n" \
  " * But : champs des objets pub d'un établissement Grand Compte\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabURLGCpt.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureObjetsGCpt(char* apcEtab, GYBrDOCUMENTEpj* doc, int4 aiIndic)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int4 i, j;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraEtab;\n" \
  "    GYBrIamicT rIamicEtab;\n" \
  "    GYBrIndIamicT rIndIamic;\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraEtab\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pcOraEtab = apcEtab;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLecturePubGCpt\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLecturePubGCpt\n" \
  "    USING: pcOraEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLecturePubGCpt: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    FETCH crsLecturePubGCpt\n" \
  "    INTO\n" \
  "    :rIamicEtab.acLibUrl\n" \
  "    :rIndIamic.sLibUrlI;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        /* URL Grand Compte */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"URL Grand Compte: %s, %s\\n\", apcEtab, rIamicEtab.acLibUrl));\n" \
  "        strcpy(doc->value.objets_pub.libUrlGCpt, rIamicEtab.acLibUrl);\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "        for (i = 0; i < aiIndic; i++)\n" \
  "        {\n" \
  "            for (j = 0; j < (doc + i)->value.objets_pub.nb_micro; j++)\n" \
  "            {\n" \
  "                if (((doc + i)->value.objets_pub.micro[j].type[0] == 'X') && (0 == strcmp((doc + i)->value.objets_pub.micro[j].stype, \" U\")) && ((0 == strcmp((doc + i)->value.objets_pub.micro[j].sstype, \"PV\"))\n" \
  "                        || (0 == strcmp((doc + i)->value.objets_pub.micro[j].sstype, \"FS\"))))\n" \
  "                {\n" \
  "                    /* toujours objet U/PV */\n" \
  "                    strcpy((doc + i)->value.objets_pub.micro[j].sstype, \"PV\");\n" \
  "                    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK != iIntRet)\n" \
  "        {\n" \
  "            /* ajout objet U/PV */\n" \
  "            nb_micro = doc->value.objets_pub.nb_micro;\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].type, \"X\");\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stype, \" U\");\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].sstype, \"PV\");\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].id, \"0001\");\n" \
  "            strcat(doc->value.objets_pub.micro[nb_micro].id, apcEtab);\n" \
  "            strcat(doc->value.objets_pub.micro[nb_micro].id, \"0001\");\n" \
  "            doc->value.objets_pub.micro[nb_micro].iCVI = 0;\n" \
  "            doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\\0';\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stypint, \" U\");\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Objet U/PV : %s\\n\", doc->value.objets_pub.micro[nb_micro].id));\n" \
  "            nb_micro++;\n" \
  "            doc->value.objets_pub.nb_micro = nb_micro;\n" \
  "        }\n" \
  "\n" \
  "        iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "        for (i = 0; i < aiIndic; i++)\n" \
  "        {\n" \
  "            for (j = 0; j < (doc + i)->value.objets_pub.nb_micro; j++)\n" \
  "            {\n" \
  "                if (((doc + i)->value.objets_pub.micro[j].type[0] == 'X') && (0 == strcmp((doc + i)->value.objets_pub.micro[j].stype, \" U\")) && (0 == strcmp((doc + i)->value.objets_pub.micro[j].sstype, \"SR\")))\n" \
  "                    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK != iIntRet)\n" \
  "        {\n" \
  "            /* ajout objet U/SR */\n" \
  "            nb_micro = doc->value.objets_pub.nb_micro;\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].type, \"X\");\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stype, \" U\");\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].sstype, \"SR\");\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].id, \"0001\");\n" \
  "            strcat(doc->value.objets_pub.micro[nb_micro].id, apcEtab);\n" \
  "            strcat(doc->value.objets_pub.micro[nb_micro].id, \"0001\");\n" \
  "            doc->value.objets_pub.micro[nb_micro].iCVI = 0;\n" \
  "            doc->value.objets_pub.micro[nb_micro].stypcvi[0] = '\\0';\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stypint, \" U\");\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Objet U/PV : %s\\n\", doc->value.objets_pub.micro[nb_micro].id));\n" \
  "            nb_micro++;\n" \
  "            doc->value.objets_pub.nb_micro = nb_micro;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLecturePubGCpt;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLecturePubGCpt: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureTypeContEtab\n" \
  " *\n" \
  " * But : champs des types de contenu d'un epj\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabContenusEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureTypeContEtab(char* apcEtab)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int4 i;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraEtab;\n" \
  "    GYBrIamicT rObjEtab;\n" \
  "    GYBrIndIamicT rIndObj;\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraEtab\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pcOraEtab = apcEtab;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureTypContEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureTypContEtab\n" \
  "    USING: pcOraEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureTypContEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    while ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureTypContEtab\n" \
  "        INTO\n" \
  "        :rObjEtab.acTpdsob\n" \
  "        :rIndObj.sTpdsobI,:rObjEtab.acTypobj:rIndObj.sTypobjI;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            if (MAX_LIST_CONT == giviNbContEtab)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Nombre de type de contenus des epj atteint %d\\n\", giviNbContEtab));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            strcpy(givrListContEtab[giviNbContEtab].tcEtab, pcOraEtab);\n" \
  "            strcpy(givrListContEtab[giviNbContEtab].tcType, rObjEtab.acTpdsob);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != rIndObj.sTypobjI)\n" \
  "                strcpy(givrListContEtab[giviNbContEtab].tcThm, \"\");\n" \
  "            else\n" \
  "                strcpy(givrListContEtab[giviNbContEtab].tcThm, rObjEtab.acTypobj);\n" \
  "\n" \
  "            giviNbContEtab++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureTypContEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureTypContEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureContProfEtab\n" \
  " *\n" \
  " * But : liens eta-prof pour les contenus\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabProfEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureContProfEtab(char* apcEtab)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int4 i, j;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraEtab;\n" \
  "    char acCodan8[GYBIaprofLgCodan8 + 1]; /* code AN8 */\n" \
  "    int2 sCodan8I;\n" \
  "    char cIndic;\n" \
  "    char datmaj[GYBIeinscLgDatmod + 1]; /* date fin */\n" \
  "    int2 sIndic;\n" \
  "    char tcType[3]; /* type */\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraEtab\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pcOraEtab = apcEtab;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureContProfEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureContProfEtab\n" \
  "    USING :pcOraEtab,:pcOraEtab,:pcOraEtab,:pcOraEtab,:pcOraEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureContProfEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    while ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureContProfEtab\n" \
  "        INTO\n" \
  "        :cIndic,:tcType,:acCodan8:sCodan8I,:datmaj:sIndic;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            if (MAX_LIST_CONT == giviNbProfEtab)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Nombre de type de contenus des epj atteint %d\\n\", giviNbContEtab));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            strcpy(givrListProfEtab[giviNbProfEtab].tcEtab, pcOraEtab);\n" \
  "\n" \
  "            if (0 == sCodan8I)\n" \
  "            {\n" \
  "                for (i = 0; i < givrListParu.iNbrTot; i++)\n" \
  "                {\n" \
  "                    j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                    if (0 == strcmp(givrListParu.trEltList[j].rubinit, acCodan8))\n" \
  "                        break;\n" \
  "                }\n" \
  "\n" \
  "                if (givrListParu.iNbrTot == i)\n" \
  "                {\n" \
  "                    /* code an8 absent du bloc */\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                strcpy(givrListProfEtab[giviNbProfEtab].tcAn8, acCodan8);\n" \
  "            }\n" \
  "            else\n" \
  "                givrListProfEtab[giviNbProfEtab].tcAn8[0] = '\\0';\n" \
  "\n" \
  "            strcpy(givrListProfEtab[giviNbProfEtab].tcType, tcType);\n" \
  "            givrListProfEtab[giviNbProfEtab].cIndic = cIndic;\n" \
  "            giviNbProfEtab++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureContProfEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureContProfEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givLectureOldEtab\n" \
  " *\n" \
  " * But : champs des anciens établissements.\n" \
  " *\n" \
  " * Description : Lecture\n" \
  " *               dans la table GYTtabLiensEtab.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureOldEtab(char** buf_pos_in, char* apcEtab)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char* pcOraEtab;\n" \
  "    char tcEtab[GYBIeinscLgEtab2]; /* etab */\n" \
  "    char cType; /* type */\n" \
  "    char tcDatLien[GYBIeinscLgDatmod + 1]; /* date */\n" \
  "    EXEC SQL\n" \
  "    VAR pcOraEtab\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    VAR tcEtab\n" \
  "    IS STRING;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    char* buf;\n" \
  "    char tcType[2];\n" \
  "    int4 pipe;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "    pcOraEtab = apcEtab;\n" \
  "    buf = *buf_pos_in;\n" \
  "    pipe = 0;\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureOldEtab\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureOldEtab\n" \
  "    USING: pcOraEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureOldEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    while ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        EXEC SQL\n" \
  "        FETCH crsLectureOldEtab\n" \
  "        INTO\n" \
  "        :tcEtab,:cType,:tcDatLien;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == iIntRet)\n" \
  "        {\n" \
  "            tcType[0] = cType;\n" \
  "            tcType[1] = '\\0';\n" \
  "\n" \
  "            if (0 == pipe)\n" \
  "            {\n" \
  "                pipe = 1;\n" \
  "                strcpy(buf, \"<etab_repris type=\\\"\");\n" \
  "            }\n" \
  "            else\n" \
  "                strcat(buf, \"<etab_repris type=\\\"\");\n" \
  "\n" \
  "            strcat(buf, tcType);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \" date_reprise=\\\"\");\n" \
  "            strcat(buf, tcDatLien);\n" \
  "            strcat(buf, \"\\\">\");\n" \
  "\n" \
  "            if ('I' == cType)\n" \
  "                strcat(buf, apcEtab);\n" \
  "            else\n" \
  "                strcat(buf, tcEtab);\n" \
  "\n" \
  "            strcat(buf, \"</etab_repris>\");\n" \
  "            lg_ecr = strlen(buf);\n" \
  "            *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "            *(buf + lg_ecr + 2) = '\\0';\n" \
  "            buf = buf + lg_ecr + 2;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureOldEtab;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureOldEtab: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_3_obj       ()                                */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie trois par objet                                */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 giv_ecrit_partie_3_obj(char** buf_pos_in, GYBrDOCUMENTEpj* docClone)\n" \
  "{\n" \
  "    int4 lg; /* Logueur du champ à traiter */\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 i, j, k, p, q, l;\n" \
  "    int4 iIntRet = GIV::GWCCodeOK;\n" \
  "    int4 iRgLigne, iObj;\n" \
  "    int4 iRg, iAlpha, iAn9, iNbGeoTri;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    char tcRub[GYBIaprofLgCodan8 + GYBPaprofLgCodan9 + 1];\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    for (i = 0; i < givrListObj.iNbrTri; i++)\n" \
  "    {\n" \
  "        iAlpha = -1;\n" \
  "        pipe = 0;\n" \
  "\n" \
  "        for (j = 0; j < givrListObj.iNbr; j++)\n" \
  "        {\n" \
  "            k = givrListObj.trEltRangListObj[j];\n" \
  "\n" \
  "            if (i != givrListObj.trEltListObj[k].iRangTri)\n" \
  "                continue;\n" \
  "\n" \
  "            iRgLigne = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "            iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "            for (p = 0; p < givrListParu.iNbrTot; p++)\n" \
  "            {\n" \
  "                q = givrListParu.trEltRangList[p];\n" \
  "\n" \
  "                if (iRgLigne != givrListParu.trEltList[q].iRgLigne)\n" \
  "                    continue;\n" \
  "\n" \
  "                if (0 == strcmp((docClone + iRgLigne)->value.objets_pub.micro[iObj].stype, \"DV\"))\n" \
  "                {\n" \
  "                    for (l = 0; l < giviNbProfEtab; l++)\n" \
  "                    {\n" \
  "                        if (('V' == givrListProfEtab[l].cIndic) && (0 == strcmp(givrListProfEtab[l].tcType, \"DV\")) && (0 == strcmp(givrListProfEtab[l].tcAn8, givrListParu.trEltList[q].rubinit)))\n" \
  "                            break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (giviNbProfEtab == l)\n" \
  "                        continue;\n" \
  "                }\n" \
  "\n" \
  "                if (0 == strcmp(givrListParu.trEltList[q].rub, givcR00000000))\n" \
  "                    iAn9 = 1;\n" \
  "                else if (pipe == 0)\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, \"objetrubrique\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    iIntRet = giv_ecrit_objet_pub(&buf_pos, docClone, iRgLigne, iObj, \"objetrub\");\n" \
  "                    strcpy(buf_concat, givrListParu.trEltList[q].rubinit);\n" \
  "                    strcat(buf_concat, givrListParu.trEltList[q].rub);\n" \
  "                    pipe = 1;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    strcpy(tcRub, givrListParu.trEltList[q].rubinit);\n" \
  "                    strcat(tcRub, givrListParu.trEltList[q].rub);\n" \
  "\n" \
  "                    if ((0 == strstr(buf_concat, tcRub)) && ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givcR000000) - (int4)strlen(givcR000000))))\n" \
  "                    {\n" \
  "                        strcat(buf_concat, \"|\");\n" \
  "                        strcat(buf_concat, givrListParu.trEltList[q].rubinit);\n" \
  "                        strcat(buf_concat, givrListParu.trEltList[q].rub);\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (1 == pipe)\n" \
  "        {\n" \
  "            iIntRet = supprimer_doublon(buf_concat, '|');\n" \
  "            pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "            for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "            {\n" \
  "                pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "                if (pt_fin == 0)\n" \
  "                    pt_fin = pt_fin_lst;\n" \
  "\n" \
  "                /* analyse rub */\n" \
  "                memcpy(tcRub, pt_debut, GYBIaprofLgCodan8);\n" \
  "                tcRub[GYBIaprofLgCodan8] = '\\0';\n" \
  "                lg_write = giv_ecrit_element(buf_pos, \"objetan8\", tcRub);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                memcpy(tcRub, pt_debut + GYBIaprofLgCodan8, GYBPaprofLgCodan9);\n" \
  "                tcRub[GYBPaprofLgCodan9] = '\\0';\n" \
  "                lg_write = giv_ecrit_element(buf_pos, \"objetan9\", tcRub);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                pt_debut = pt_fin + 1;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"objetrubrique\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "int4 givInclusionRubrique(char* atcRub, GYBrDOCUMENTEpj* doc, int4 aiRef)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 i, j, k, p, q;\n" \
  "    int4 iIntRet = GIV::GWCCodeOK;\n" \
  "    int4 iRang, iRgLigne;\n" \
  "    iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "    iRang = doc->value.objets_pub.micro[aiRef].iRgObj;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" Rang objet-rub %d-%s\\n\", iRang, atcRub));\n" \
  "\n" \
  "    for (j = 0; j < givrListObj.iNbr; j++)\n" \
  "    {\n" \
  "        k = givrListObj.trEltRangListObj[j];\n" \
  "\n" \
  "        if (iRang != givrListObj.trEltListObj[k].iRangTri)\n" \
  "            continue;\n" \
  "\n" \
  "        iRgLigne = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" Rang ligne %d\\n\", iRgLigne));\n" \
  "\n" \
  "        for (p = 0; p < givrListParu.iNbrTot; p++)\n" \
  "        {\n" \
  "            q = givrListParu.trEltRangList[p];\n" \
  "\n" \
  "            if (iRgLigne != givrListParu.trEltList[q].iRgLigne)\n" \
  "                continue;\n" \
  "\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" Rubrique %s\\n\", givrListParu.trEltList[q].rubinit));\n" \
  "\n" \
  "            if (0 == strcmp(givrListParu.trEltList[q].rubinit, atcRub))\n" \
  "            {\n" \
  "                iCodRet = (int4)GIV::GWCCodeOK;\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" Rubrique trouvée %s\\n\", givrListParu.trEltList[q].rubinit));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_3_ins       ()                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie trois par inscription                                */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 giv_ecrit_partie_3_ins(char** buf_pos_in, GYBrDOCUMENTEpj* docClone, int4 indice)\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iRet; /* Code retour de la fonction */\n" \
  "    int4 m;\n" \
  "    int4 jRef;\n" \
  "    int4 lg_write;\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    if (0 == strcmp(givtcParuInscEpj, \"OUI\"))\n" \
  "    {\n" \
  "        /* parution géographique par inscription */\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"iparution\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        jRef = 0;\n" \
  "        m = 0;\n" \
  "        /* géopgaphie du moyen de communication */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_ARR, \"ipjdeplocarr\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_LOC, \"ipjdeplocarrextra\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_LOC, \"ipjdeploc\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_ZU, \"ipjdeploczoneurbaine\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_DEPT, \"ipjdeplocextraloc\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_DEPT, \"ipjdeplocarrextraloc\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_EXTL, \"ipjdeplocextradep\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_EXTL, \"ipjdeplocarrextradep\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_DEPT, GIV::giv_DEPT, \"ipjdep\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_DEPT, GIV::giv_EXTL, \"ipjdepextra\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_REG, GIV::giv_REG, \"ipjreg\");\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_REG, GIV::giv_EXTL, \"ipjregextra\");\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"iparution\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    /* Fin de l'entité inscription */\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"inscription\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrit partie_3_ins  */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_rubriques ()                                   */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit rubrique avec les codes an9 an8 si ceux ci sont fournis  */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, les differents codes                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_rubriques(char* buf, char* val_codan8, char* val_codan9, char orig, const std::string& thematique = \"\")\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "    GIVBuffInter[0] = '\\0';\n" \
  "\n" \
  "    std::stringstream stream;\n" \
  "\n" \
  "    if (orig != '4' && orig != '6' && orig != '7')\n" \
  "        orig = '1';\n" \
  "\n" \
  "    stream << \"<rubrique\" << \" origine=\\\"\" << orig << \"\\\"\"\n" \
  "                          << \" codan8=\\\"\" << val_codan8 << \"\\\"\"\n" \
  "                          << \" codan9=\\\"\" << val_codan9 << \"\\\"\";\n" \
  "\n" \
  "    if (thematique == \"MEDECIN\")\n" \
  "        stream << \" sante=\\\"1\\\"\";\n" \
  "\n" \
  "    if (!thematique.empty())\n" \
  "        stream << \" thematique=\\\"\" << thematique << \"\\\"\";\n" \
  "\n" \
  "    stream << \">\";\n" \
  "\n" \
  "    if (strcmp(val_codan9, givcR00000000) != 0)\n" \
  "    {\n" \
  "        /* Afficher le texte de la rubrique (uniquement le premier) */\n" \
  "        /* Appel a la fonction de lecture du libelle de rubrique */\n" \
  "        givLectureLibRub(val_codan9);\n" \
  "    }\n" \
  "\n" \
  "    strcat(buf, stream.str().c_str());\n" \
  "    strcat(buf, GIVBuffInter);\n" \
  "    strcat(buf, \"</rubrique>\");\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    lg_ecr = lg_ecr + 2;\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_partenaire ()                                   */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit origine et ref de partenaire                             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, les differents codes                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_partenaire(char** buf_in, char* val, char* blocid, char* etab)\n" \
  "{\n" \
  "    int4 lg_ecr, iIntRet;\n" \
  "    char* buf;\n" \
  "    buf = *buf_in;\n" \
  "\n" \
  "    if (0 == strlen(buf))\n" \
  "        strcpy(buf, \"<\");\n" \
  "    else\n" \
  "        strcat(buf, \"<\");\n" \
  "\n" \
  "    strcat(buf, \"info_part\");\n" \
  "    strcat(buf, \" \");\n" \
  "    strcat(buf, \"source\");\n" \
  "    strcat(buf, \"=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, &val[strlen(val) - 4]);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" \");\n" \
  "    strcat(buf, \"ref\");\n" \
  "    strcat(buf, \"=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    memcpy(&buf[lg_ecr], val, strlen(val) - 4);\n" \
  "    *(buf + lg_ecr + strlen(val) - 4) = '\\0';\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" \");\n" \
  "    strcat(buf, \"id\");\n" \
  "    strcat(buf, \"=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, blocid);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" \");\n" \
  "    strcat(buf, \"etab\");\n" \
  "    strcat(buf, \"=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, etab);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" />\");\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    lg_ecr = lg_ecr + 2;\n" \
  "    buf = buf + lg_ecr;\n" \
  "    iIntRet = givOppositionPart(&buf, val);\n" \
  "    *buf_in = buf;\n" \
  "    iIntRet = GIV::GWCCodeOK;\n" \
  "    return (iIntRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_element_partenaire ()                                */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit origine et ref de partenaire pour mutualisation          */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, les differents codes                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_element_partenaire(char* nom_balise, char* buf, char* val, char* etab, char* parent)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "\n" \
  "    if (0 == strlen(buf))\n" \
  "        strcpy(buf, \"<\");\n" \
  "    else\n" \
  "        strcat(buf, \"<\");\n" \
  "\n" \
  "    if (0 != strcmp(givtcPartInsc, \"OUI\"))\n" \
  "    {\n" \
  "        strcat(buf, nom_balise);\n" \
  "        strcat(buf, \" id=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, val);\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, \" \");\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        strcat(buf, nom_balise);\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"source\");\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, &val[strlen(val) - 4]);\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"id\");\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        memcpy(&buf[lg_ecr], val, strlen(val) - 4);\n" \
  "        *(buf + lg_ecr + strlen(val) - 4) = '\\0';\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, \" \");\n" \
  "\n" \
  "        if ((0 == strcmp(giv_PJDC, &val[strlen(val) - 4])) && (0 != strlen(parent)))\n" \
  "        {\n" \
  "            strcat(buf, \"parentId\");\n" \
  "            strcat(buf, \"=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, parent);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \" \");\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    strcat(buf, \"etab\");\n" \
  "    strcat(buf, \"=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, etab);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \">\");\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    lg_ecr = lg_ecr + 2;\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : GIV_ecrit_element_parent ()                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit parnet de partenaire                                     */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, les differents codes                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 GIV_ecrit_element_parent(char** buf_pos_in, GYBrIapartT* prPart)\n" \
  "{\n" \
  "    int4 iRet;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    char* buf;\n" \
  "    char tcIntl[GYBIeinscLgDenom2 + GYBIeinscLgPrenom2];\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf = *buf_pos_in;\n" \
  "\n" \
  "    if (giv_cPJDC == prPart->acTypeRefPart[0])\n" \
  "    {\n" \
  "        prPart->openElementCabinet(buf);\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf = buf + lg_ecr;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "        prPart->concatDenominationPrenom(tcIntl, givtcInvDenPn);\n" \
  "        lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, \"denom\");\n" \
  "        strcat(buf, \"</cabinet>\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "    }\n" \
  "    else if (giv_prPJDC == prPart->acTypeRefPart[0])\n" \
  "    {\n" \
  "    	prPart->openParentElementMedecin(buf);\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf = buf + lg_ecr;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "        prPart->concatDenominationPrenom(tcIntl, givtcInvDenPn);\n" \
  "        lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, \"denom\");\n" \
  "        iRet = givExtractPartEtab(prPart, &buf, giv_PHO);\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "        strcpy(buf, \"<rubrique\");\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"an9\");\n" \
  "        strcat(buf, \"=\\\"\");\n" \
  "        strcat(buf, prPart->acCodan9);\n" \
  "        strcat(buf, \"\\\">\");\n" \
  "\n" \
  "        if (0 != strlen(prPart->acCodan9))\n" \
  "        {\n" \
  "            /* Afficher le texte de la rubrique (uniquement le premier) */\n" \
  "            /* Appel a la fonction de lecture du libelle de rubrique */\n" \
  "            iRet = givLectureLibRub(prPart->acCodan9);\n" \
  "            strcat(buf, GIVBuffInter);\n" \
  "        }\n" \
  "\n" \
  "        strcat(buf, \"</\");\n" \
  "        strcat(buf, \"rubrique\");\n" \
  "        strcat(buf, \">\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        strcat(buf, \"</medecin>\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie_ISO(&buf, GIVfDescFicBloc);\n" \
  "        lg_ecr = 0;\n" \
  "    }\n" \
  "    else\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"WARNING : type de référence de partenaire erroné : <%c> epj <%s>\\n\", prPart->acTypeRefPart[0], prPart->acEtab));\n" \
  "\n" \
  "    *buf_pos_in = buf;\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "\n" \
  "int4 giv_ecrit_elements_nav(char** buf_pos_in, GYBrIapartT* prPart)\n" \
  "{\n" \
  "    int4 iRet;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    char* buf;\n" \
  "    char tcIntl[GYBIeinscLgDenom2 + GYBIeinscLgPrenom2];\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf = *buf_pos_in;\n" \
  "\n" \
  "    if (giv_prPJDC == prPart->acTypeRefPart[0])\n" \
  "    {\n" \
  "    	prPart->openNavElementMedecin(buf);\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf = buf + lg_ecr;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "        prPart->concatDenominationPrenom(tcIntl, givtcInvDenPn);\n" \
  "        lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, \"denom\");\n" \
  "        prPart->openElementRubrique(buf);\n" \
  "\n" \
  "        if (0 != strlen(prPart->acCodan9))\n" \
  "        {\n" \
  "            /* Afficher le texte de la rubrique (uniquement le premier) */\n" \
  "            /* Appel a la fonction de lecture du libelle de rubrique */\n" \
  "            iRet = givLectureLibRub(prPart->acCodan9);\n" \
  "            strcat(buf, GIVBuffInter);\n" \
  "        }\n" \
  "\n" \
  "        strcat(buf, \"</\");\n" \
  "        strcat(buf, \"rubrique\");\n" \
  "        strcat(buf, \">\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie_ISO(&buf, GIVfDescFicBloc);\n" \
  "        iRet = givExtractPartEtab(prPart, &buf, giv_PHO);\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "        strcpy(buf, \"</medecin>\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie_ISO(&buf, GIVfDescFicBloc);\n" \
  "        lg_ecr = 0;\n" \
  "    }\n" \
  "    else if ((giv_orPJDC == prPart->acTypeRefPart[0]) || (giv_svPJDC == prPart->acTypeRefPart[0]) || (giv_cPJDC == prPart->acTypeRefPart[0]))\n" \
  "    {\n" \
  "        if (0 == strlen(buf))\n" \
  "            strcpy(buf, \"<\");\n" \
  "        else\n" \
  "            strcat(buf, \"<\");\n" \
  "\n" \
  "        if (giv_orPJDC == prPart->acTypeRefPart[0])\n" \
  "            strcat(buf, \"organisation\");\n" \
  "        else if (giv_svPJDC == prPart->acTypeRefPart[0])\n" \
  "        {\n" \
  "            strcat(buf, \"service\");\n" \
  "\n" \
  "            if (0 == strlen(prPart->acParentRefPart))\n" \
  "            {\n" \
  "                strcat(buf, \" \");\n" \
  "                strcat(buf, \"ref\");\n" \
  "                strcat(buf, \"=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, prPart->acRefPart);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "            strcat(buf, \"cabinet\");\n" \
  "\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"epj\");\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, prPart->acEtab);\n" \
  "        strcat(buf, \"\\\">\");\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "        buf = buf + lg_ecr;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "        prPart->concatDenominationPrenom(tcIntl, givtcInvDenPn);\n" \
  "        lg_ecr = giv_ecrit_balise_epj(&buf, tcIntl, \"denom\");\n" \
  "\n" \
  "        if ((giv_svPJDC == prPart->acTypeRefPart[0]) && (0 == strlen(prPart->acParentRefPart)))\n" \
  "        {\n" \
  "            /* calendrier d'un service d'une organisation */\n" \
  "            iRet = givExtractPartEtab(prPart, &buf, giv_CAL);\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iRet = (int4)giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        iRet = givExtractPartEtab(prPart, &buf, giv_PHO);\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie(&buf, GIVfDescFicBloc);\n" \
  "\n" \
  "        if (giv_orPJDC == prPart->acTypeRefPart[0])\n" \
  "            strcpy(buf, \"</organisation>\");\n" \
  "        else if (giv_svPJDC == prPart->acTypeRefPart[0])\n" \
  "            strcpy(buf, \"</service>\");\n" \
  "        else\n" \
  "            strcpy(buf, \"</cabinet>\");\n" \
  "\n" \
  "        lg_ecr = strlen(buf);\n" \
  "        *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf + lg_ecr + 2) = '\\0';\n" \
  "        lg_ecr = lg_ecr + 2;\n" \
  "    }\n" \
  "    else\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"WARNING : type de référence de partenaire erroné : <%c> epj <%s>\\n\", prPart->acTypeRefPart[0], prPart->acEtab));\n" \
  "\n" \
  "    *buf_pos_in = buf;\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "int4 giv_ecrit_navigation(char** buf_pos_in, int4 aiRgParent, int4 aiNbParent, char pcTypeRef, GYBrIapartT* prPart, char* pcCleRef)\n" \
  "{\n" \
  "    int4 iCodRet;\n" \
  "    char* buf_pos;\n" \
  "    int4 lg_write = 0;\n" \
  "    int4 i;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    if (giv_orPJDC == pcTypeRef)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"navOrganisation\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_noeud_attr(buf_pos, \"services\", pcCleRef);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        for (i = aiRgParent; i < (aiRgParent + aiNbParent); i++)\n" \
  "        {\n" \
  "            /* référence de parent inutile : attribut ref de navigation présent */\n" \
  "            givtrPart[i].acParentRefPart[0] = '\\0';\n" \
  "            lg_write = giv_ecrit_elements_nav(&buf_pos, &givtrPart[i]);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"services\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"navOrganisation\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "    else if (giv_svPJDC == pcTypeRef)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"navService\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        for (i = aiRgParent; (i < (aiRgParent + aiNbParent) && giv_orPJDC != givtrPart[i].acTypeRefPart[0]); i++)\n" \
  "            ;\n" \
  "\n" \
  "        if ((aiRgParent + aiNbParent) != i)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_elements_nav(&buf_pos, &givtrPart[i]);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_noeud_attr(buf_pos, \"equipe\", pcCleRef);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        for (i = aiRgParent; i < (aiRgParent + aiNbParent); i++)\n" \
  "        {\n" \
  "            if (giv_prPJDC == givtrPart[i].acTypeRefPart[0])\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_elements_nav(&buf_pos, &givtrPart[i]);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"equipe\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"navService\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "    else if (giv_cPJDC == pcTypeRef)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"navCabinet\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_noeud_attr(buf_pos, \"equipe\", pcCleRef);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        for (i = aiRgParent; i < (aiRgParent + aiNbParent); i++)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_elements_nav(&buf_pos, &givtrPart[i]);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"equipe\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"navCabinet\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "    else if ((giv_prPJDC == pcTypeRef) && (0 != giviNbParentPart))\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"navMedecin\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        for (i = aiRgParent; (i < (aiRgParent + aiNbParent) && giv_cPJDC != givtrPart[i].acTypeRefPart[0]); i++)\n" \
  "            ;\n" \
  "\n" \
  "        if ((aiRgParent + aiNbParent) != i)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_elements_nav(&buf_pos, &givtrPart[i]);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            for (i = aiRgParent; (i < (aiRgParent + aiNbParent) && giv_orPJDC != givtrPart[i].acTypeRefPart[0]); i++)\n" \
  "                ;\n" \
  "\n" \
  "            if ((aiRgParent + aiNbParent) != i)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_elements_nav(&buf_pos, &givtrPart[i]);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            for (i = aiRgParent; (i < (aiRgParent + aiNbParent) && giv_svPJDC != givtrPart[i].acTypeRefPart[0]); i++)\n" \
  "                ;\n" \
  "\n" \
  "            if ((aiRgParent + aiNbParent) != i)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_elements_nav(&buf_pos, &givtrPart[i]);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"navMedecin\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "    else\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"WARNING : type de référence de partenaire erroné : <%c> epj <%s>\\n\", prPart->acTypeRefPart[0], prPart->acEtab));\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : GIV_ecrit_denom_parent ()                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit denomination de parent de partenaire                     */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, les differents codes                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 giv_init_denom_parent(char* buf, char* apcEtab, int4* apiDeb)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "    strcpy(buf, \"<intitulelibpjdc etab=\\\"\");\n" \
  "    strcat(buf, apcEtab);\n" \
  "    strcat(buf, \"\\\">\");\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    lg_ecr = lg_ecr + 2;\n" \
  "    *apiDeb = 0;\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "int4 GIV_ecrit_denom_parent(char* buf, char* aprDenom, char* aprPrenom, int4* apiDeb)\n" \
  "{\n" \
  "    int4 iRet;\n" \
  "    int4 lg_ecr = 0;\n" \
  "\n" \
  "    if (0 == strlen(buf))\n" \
  "        strcpy(buf, \"<\");\n" \
  "    else\n" \
  "        strcat(buf, \"<\");\n" \
  "\n" \
  "    strcat(buf, \"denomlibpjdc\");\n" \
  "    strcat(buf, \">\");\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    iRet = giv_sortie_ISO(&buf, GIVfDescFicBloc);\n" \
  "\n" \
  "    if (0 == strcmp(givtcInvDenPn, \"NON\"))\n" \
  "    {\n" \
  "        strcpy(buf_concat, aprDenom);\n" \
  "\n" \
  "        if (0 != strlen(aprPrenom))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, aprPrenom);\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* inversion de l'ordre de la denomination-prénom */\n" \
  "        if (0 != strlen(aprPrenom))\n" \
  "        {\n" \
  "            strcpy(buf_concat, aprPrenom);\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, aprDenom);\n" \
  "        }\n" \
  "        else\n" \
  "            strcpy(buf_concat, aprDenom);\n" \
  "    }\n" \
  "\n" \
  "    lg_ecr = giv_ecrit_balise_epj(&buf, buf_concat, \"\");\n" \
  "    lg_ecr = giv_ecrit_fin_noeud(&buf, \"denomlibpjdc\");\n" \
  "    buf = buf + lg_ecr;\n" \
  "    return (lg_ecr);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_inscription ()                                 */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit une inscription avec tous les champs                     */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, numero, lo ls grp, seq                              */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                             */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_inscription(char* buf, GYBrDOCUMENTEpj* doc, int4 i)\n" \
  "{\n" \
  "    int4 lg_ecr;\n" \
  "    int4 iCodRet = (int4)GIV::GWCCodeOK;\n" \
  "\n" \
  "    if (strlen(doc->value.inscription[i].val_num) > 0)\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, \"inscription\");\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"num\");\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, doc->value.inscription[i].val_num);\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"lo\");\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        iCodRet = GIVCodeClient(doc->value.inscription[i].val_lols, (int4)strlen(doc->value.inscription[i].val_lols));\n" \
  "        strcat(buf, GIVtcClientDecode);\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"ls\");\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, doc->value.inscription[i].val_lslo);\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "\n" \
  "        if (strlen(doc->value.inscription[i].val_grp) > 0)\n" \
  "        {\n" \
  "            strcat(buf, \" \");\n" \
  "            strcat(buf, \"grp\");\n" \
  "            strcat(buf, \"=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            iCodRet = GIVCodeClient(doc->value.inscription[i].val_grp, (int4)strlen(doc->value.inscription[i].val_grp));\n" \
  "            strcat(buf, GIVtcClientDecode);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            strcat(buf, \" \");\n" \
  "            strcat(buf, \"grp\");\n" \
  "            strcat(buf, \"=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "        }\n" \
  "\n" \
  "        strcat(buf, \" \");\n" \
  "        strcat(buf, \"seq\");\n" \
  "        strcat(buf, \"=\");\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, doc->value.inscription[i].val_seq);\n" \
  "        strcat(buf, \"\\\"\");\n" \
  "        strcat(buf, \">\");\n" \
  "    } /* Fin if ins  */\n" \
  "    else\n" \
  "    {\n" \
  "        strcpy(buf, \"<\");\n" \
  "        strcat(buf, \"inscription\");\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    return (lg_ecr + 2);\n" \
  "} /* Fin noeud inscription */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_objets_pub ()                                  */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les objets pub avec les champs fournis                   */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, id, type, stype                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_objets_pub(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 aindice, char* pcCleTri)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_ecr_noyau = 0;\n" \
  "    int4 lg_ecr_module = 0;\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i, k, kk = 0;\n" \
  "    int4 j, jk, jkk = 0;\n" \
  "    char* buf;\n" \
  "    int4 iRang, iObj;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" No_noyau : ... %d\\n\", nb_noyau));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" No_micro : ... %d\\n\", nb_micro));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" No_module : ... %d\\n\", nb_module));\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf = *buf_pos_in;\n" \
  "    iRang = -1;\n" \
  "\n" \
  "    for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "    {\n" \
  "        k = givrListObj.trEltRangListObj[i];\n" \
  "        kk = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "        iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "        if (iRang != givrListObj.trEltListObj[k].iRangTri)\n" \
  "        {\n" \
  "            iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "\n" \
  "            if (i == 0)\n" \
  "                strcpy(buf, \"<\");\n" \
  "            else\n" \
  "                strcat(buf, \"<\");\n" \
  "\n" \
  "            strcat(buf, \"objet\");\n" \
  "            strcat(buf, \" \");\n" \
  "            strcat(buf, \"id\");\n" \
  "            strcat(buf, \"=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].id);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \" type=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].type);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \" stype=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].stype);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \" sstype=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].sstype);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \" dmaj=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].tcdatact);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, \" onumcli=\");\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "            strcat(buf, (doc + kk)->value.numero_client);\n" \
  "            strcat(buf, \"\\\"\");\n" \
  "\n" \
  "            for (j = 0; j < givrListObj.iNbr; j++)\n" \
  "            {\n" \
  "                jk = givrListObj.trEltRangListObj[j];\n" \
  "                jkk = givrListObj.trEltListObj[jk].iRgLigne;\n" \
  "\n" \
  "                if ((iRang == givrListObj.trEltListObj[jk].iRangTri) && (doc->value.intitule.iRgPrinc == jkk))\n" \
  "                {\n" \
  "                    strcat(buf, \" obpal=\");\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "                    strcat(buf, \"true\");\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "                    break;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            strcat(buf, \"> </objet>\");\n" \
  "\n" \
  "            if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].type, \"M\")) && (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \" T\")))\n" \
  "            {\n" \
  "                /* module PJI trouvé */\n" \
  "                (void)strcpy(pcCleTri, \"0\");\n" \
  "            }\n" \
  "\n" \
  "            lg_ecr = strlen(buf);\n" \
  "            *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "            *(buf + lg_ecr + 2) = '\\0';\n" \
  "            buf = buf + lg_ecr + 2;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrire objets pub */\n" \
  "/*-----------------------------Fin de la fonction---------------*/\n" \
  "static int4 giv_ecrit_objet_pub(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 iDoc, int4 iObj, char* pcBalise)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_ecr = 0;\n" \
  "    char* buf;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf = *buf_pos_in;\n" \
  "    strcpy(buf, \"<\");\n" \
  "    strcat(buf, pcBalise);\n" \
  "    strcat(buf, \" \");\n" \
  "    strcat(buf, \"id\");\n" \
  "    strcat(buf, \"=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, (doc + iDoc)->value.objets_pub.micro[iObj].id);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" type=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, (doc + iDoc)->value.objets_pub.micro[iObj].type);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" stype=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, (doc + iDoc)->value.objets_pub.micro[iObj].stype);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" sstype=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, (doc + iDoc)->value.objets_pub.micro[iObj].sstype);\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, \" onumcli=\");\n" \
  "    strcat(buf, \"\\\"\");\n" \
  "    strcat(buf, (doc + iDoc)->value.numero_client);\n" \
  "    strcat(buf, \"\\\">\");\n" \
  "\n" \
  "    if (!(0 == strcmp(\"objetpub\", pcBalise) && (((0 == strcmp(\"SC\", (doc + iDoc)->value.objets_pub.micro[iObj].stype)) && ((0 == strcmp(\"PV\", (doc + iDoc)->value.objets_pub.micro[iObj].sstype))\n" \
  "            || (0 == strcmp(\"SR\", (doc + iDoc)->value.objets_pub.micro[iObj].sstype)))) || ((0 != strlen((doc + iDoc)->value.objets_pub.micro[iObj].stypcvi))\n" \
  "                    && (0 != strcmp(\"MO\", (doc + iDoc)->value.objets_pub.micro[iObj].stype))))))\n" \
  "    {\n" \
  "        strcat(buf, \" </\");\n" \
  "        strcat(buf, pcBalise);\n" \
  "        strcat(buf, \">\");\n" \
  "    }\n" \
  "\n" \
  "    lg_ecr = strlen(buf);\n" \
  "    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "    *(buf + lg_ecr + 2) = '\\0';\n" \
  "    buf = buf + lg_ecr + 2;\n" \
  "    *buf_pos_in = buf;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrire objet pub */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_objets_pvi ()                                  */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les liens entre PVI et Video                             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, id, type, stype                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_objets_pvi(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 aindice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i, k, j, l = 0;\n" \
  "    char* buf;\n" \
  "    int4 iRang, iObj, iLig;\n" \
  "    int4 iVRang, iVObj, iVLig;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf = *buf_pos_in;\n" \
  "    iRang = -1;\n" \
  "\n" \
  "    for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "    {\n" \
  "        k = givrListObj.trEltRangListObj[i];\n" \
  "        iLig = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "        iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "        if ((0 != strcmp((doc + iLig)->value.objets_pub.micro[iObj].stype, \"SC\")) || (0 != strcmp((doc + iLig)->value.objets_pub.micro[iObj].sstype, \"PV\")))\n" \
  "            continue;\n" \
  "\n" \
  "        for (j = 0; (j < givrListObj.iNbr && iRang != givrListObj.trEltListObj[k].iRangTri); j++)\n" \
  "        {\n" \
  "            if (-1 == givrListObj.trEltListObj[j].iOrdTri)\n" \
  "                givrListObj.trEltListObj[j].iOrdTri = 0;\n" \
  "        }\n" \
  "\n" \
  "        iVRang = -1;\n" \
  "\n" \
  "        for (j = 0; j < givrListObj.iNbr; j++)\n" \
  "        {\n" \
  "            l = givrListObj.trEltRangListObj[j];\n" \
  "            iVLig = givrListObj.trEltListObj[l].iRgLigne;\n" \
  "            iVObj = givrListObj.trEltListObj[l].iRgObj;\n" \
  "\n" \
  "            if ((0 != strcmp((doc + iVLig)->value.objets_pub.micro[iVObj].stype, \"FI\")) && (0 != strcmp((doc + iVLig)->value.objets_pub.micro[iVObj].stype, \"IN\"))\n" \
  "                    && (0 != strcmp((doc + iVLig)->value.objets_pub.micro[iVObj].stype, \"VI\")))\n" \
  "            {\n" \
  "                iVRang = -1;\n" \
  "                continue;\n" \
  "            }\n" \
  "\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" Tri objet : ... %d,%d,%d,%d,%d,%s,%s,%s,%s\\n\", j, l, givrListObj.trEltListObj[l].iRangTri, givrListObj.trEltListObj[l].iOrdTri, iVLig,\n" \
  "                                     (doc + iVLig)->value.objets_pub.micro[iVObj].type, (doc + iVLig)->value.objets_pub.micro[iVObj].stype, (doc + iVLig)->value.objets_pub.micro[iVObj].sstype,\n" \
  "                                     (doc + iVLig)->value.objets_pub.micro[iVObj].id));\n" \
  "\n" \
  "            if ((iLig == iVLig) && (-1 != givrListObj.trEltListObj[givrListObj.trEltRangListObj[j - givrListObj.trEltListObj[l].iOrdTri]].iOrdTri))\n" \
  "            {\n" \
  "                /* association validée */\n" \
  "                iVRang = givrListObj.trEltListObj[l].iRangTri;\n" \
  "                givrListObj.trEltListObj[givrListObj.trEltRangListObj[j - givrListObj.trEltListObj[l].iOrdTri]].iOrdTri = -1;\n" \
  "\n" \
  "                if (buf == *buf_pos_in)\n" \
  "                {\n" \
  "                    lg_ecr = giv_ecrit_noeud_simple(buf, \"lienspvivideo\");\n" \
  "                    buf = buf + lg_ecr;\n" \
  "                }\n" \
  "\n" \
  "                lg_ecr = giv_ecrit_noeud_simple(buf, \"lienpvivideo\");\n" \
  "                buf = buf + lg_ecr;\n" \
  "                strcat(buf, \"<\");\n" \
  "                strcat(buf, \"lienpvi\");\n" \
  "                strcat(buf, \" \");\n" \
  "                strcat(buf, \"id\");\n" \
  "                strcat(buf, \"=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iVLig)->value.objets_pub.micro[iVObj].id);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" type=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iVLig)->value.objets_pub.micro[iVObj].type);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" stype=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iVLig)->value.objets_pub.micro[iVObj].stype);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" sstype=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iVLig)->value.objets_pub.micro[iVObj].sstype);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" dmaj=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iVLig)->value.objets_pub.micro[iVObj].tcdatact);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \"> </lienpvi>\");\n" \
  "                lg_ecr = strlen(buf);\n" \
  "                *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf + lg_ecr + 2) = '\\0';\n" \
  "                buf = buf + lg_ecr + 2;\n" \
  "                strcat(buf, \"<\");\n" \
  "                strcat(buf, \"lienvideo\");\n" \
  "                strcat(buf, \" \");\n" \
  "                strcat(buf, \"id\");\n" \
  "                strcat(buf, \"=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iLig)->value.objets_pub.micro[iObj].id);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" type=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iLig)->value.objets_pub.micro[iObj].type);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" stype=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iLig)->value.objets_pub.micro[iObj].stype);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" sstype=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iLig)->value.objets_pub.micro[iObj].sstype);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" dmaj=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, (doc + iLig)->value.objets_pub.micro[iObj].tcdatact);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \"> </lienvideo>\");\n" \
  "                lg_ecr = strlen(buf);\n" \
  "                *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf + lg_ecr + 2) = '\\0';\n" \
  "                buf = buf + lg_ecr + 2;\n" \
  "                lg_ecr = giv_ecrit_fin_noeud(&buf, \"lienpvivideo\");\n" \
  "                buf = buf + lg_ecr;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                if (iLig == iVLig)\n" \
  "                {\n" \
  "                    /* association déjà traitée */\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" Tri objet déjà traité : ... %d,%d,%s\\n\", j - givrListObj.trEltListObj[l].iOrdTri,\n" \
  "                                             givrListObj.trEltListObj[givrListObj.trEltRangListObj[j - givrListObj.trEltListObj[l].iOrdTri]].iOrdTri,\n" \
  "                                             (doc + givrListObj.trEltListObj[givrListObj.trEltRangListObj[j - givrListObj.trEltListObj[l].iOrdTri]].iRgLigne)->value.objets_pub.micro[givrListObj.trEltListObj[givrListObj.trEltRangListObj[j -\n" \
  "                                                     givrListObj.trEltListObj[l].iOrdTri]].iRgObj].id));\n" \
  "                }\n" \
  "\n" \
  "                iVRang = -1;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "    }\n" \
  "\n" \
  "    if (buf != *buf_pos_in)\n" \
  "    {\n" \
  "        lg_ecr = giv_ecrit_fin_noeud(&buf, \"lienspvivideo\");\n" \
  "        buf = buf + lg_ecr;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrire objets pvi */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_noeud_objets_url ()                                  */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les libellés d'URL                                       */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, id, type, stype                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_noeud_objets_url(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 aindice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 x, i, j, k, kk = 0;\n" \
  "    char* buf;\n" \
  "    int4 iRang, iObj;\n" \
  "    int4 iLg = 0;\n" \
  "    int4 iIntRet;\n" \
  "    GYBrIamicT rIamic;\n" \
  "    GYBrIndIamicT rIndIamic;\n" \
  "    GYBrIapartT rIapart;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf = *buf_pos_in;\n" \
  "    iRang = -1;\n" \
  "    buf_concat[0] = '\\0';\n" \
  "\n" \
  "    for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "    {\n" \
  "        iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "        buf_concat[0] = '\\0';\n" \
  "        k = givrListObj.trEltRangListObj[i];\n" \
  "        kk = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "        iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "        if (iRang != givrListObj.trEltListObj[k].iRangTri)\n" \
  "        {\n" \
  "            iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "\n" \
  "            if (((doc + kk)->value.objets_pub.micro[iObj].type[0] == 'X') && ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \" U\"))\n" \
  "                    || ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"SC\")) && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"PV\")))\n" \
  "                    || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"SO\")) || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LC\"))\n" \
  "                    || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LD\")) || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LP\"))\n" \
  "                    || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LR\")) || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LE\"))\n" \
  "                    || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LF\")) || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LT\"))\n" \
  "                    || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LB\"))))\n" \
  "            {\n" \
  "                (void)strcpy(rIamic.acNumobj, (doc + kk)->value.objets_pub.micro[iObj].id);\n" \
  "                (void)strcpy(rIamic.acTypobj, \"M\");\n" \
  "                /* utilisation du sous-type interne */\n" \
  "                (void)strcpy(rIamic.acTpdsob, (doc + kk)->value.objets_pub.micro[iObj].stypint);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" type_micro : ... %s,%s,%s\\n\", (doc + kk)->value.objets_pub.micro[iObj].type, (doc + kk)->value.objets_pub.micro[iObj].stype,\n" \
  "                                         (doc + kk)->value.objets_pub.micro[iObj].stypint));\n" \
  "\n" \
  "                if ((0 != strlen((doc + kk)->value.objets_pub.libUrlGCpt)) && (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \" U\"))\n" \
  "                        && ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"PV\")) || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"SR\"))))\n" \
  "                {\n" \
  "                    (void)strcpy(buf_concat, (doc + kk)->value.objets_pub.libUrlGCpt);\n" \
  "                    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "                }\n" \
  "                else if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LP\") && 0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"CR\"))\n" \
  "                         || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LR\") && 0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"LG\"))\n" \
  "                         || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LC\") && 0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"CH\")))\n" \
  "                {\n" \
  "                    /* remplacement par l'url EPJ */\n" \
  "                    if (0 != strlen((doc + kk)->value.objets_pub.micro[iObj].valeur))\n" \
  "                    {\n" \
  "                        (void)strcpy(buf_concat, (doc + kk)->value.objets_pub.micro[iObj].valeur);\n" \
  "                        iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "                    }\n" \
  "                }\n" \
  "                else\n" \
  "                    iIntRet = givLectureTypeURL(&rIamic, &rIndIamic);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                {\n" \
  "                    if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"SC\")) && (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"PB\")))\n" \
  "                    {\n" \
  "                        /* pas de remplacement de l'url EPJ par l'url site présence */\n" \
  "                        /* (void)strcpy((doc+kk)->value.objets_pub.libUrlSite,buf_concat); */\n" \
  "                    }\n" \
  "\n" \
  "                    if (*buf_pos_in == buf)\n" \
  "                        strcpy(buf, \"<\");\n" \
  "                    else\n" \
  "                        strcat(buf, \"<\");\n" \
  "\n" \
  "                    strcat(buf, \"lienurl\");\n" \
  "                    strcat(buf, \" \");\n" \
  "                    strcat(buf, \"ct\");\n" \
  "                    strcat(buf, \"=\");\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "                    strcat(buf, buf_concat);\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "                    strcat(buf, \" typ_lienurl=\");\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "\n" \
  "                    /* HAL, OA12 : on prend le sous-type dans l'inscription car il n'est pas toujours connu dans PemicURL */\n" \
  "                    if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"SR\")) && (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \" U\")))\n" \
  "                        strcat(buf, &(doc + kk)->value.objets_pub.micro[iObj].stype[1]);\n" \
  "                    else if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"SR\")) && ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"SC\"))\n" \
  "                             || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"SO\"))))\n" \
  "                        strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].stype);\n" \
  "\n" \
  "                    strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].sstype);\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "                    strcat(buf, \" id=\");\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "                    strcat(buf, (doc + kk)->value.objets_pub.micro[iObj].id);\n" \
  "                    strcat(buf, \"\\\"\");\n" \
  "                    strcat(buf, \"> </lienurl>\");\n" \
  "                    lg_ecr = strlen(buf);\n" \
  "                    *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "                    *(buf + lg_ecr + 2) = '\\0';\n" \
  "                    buf_concat[0] = '\\0';\n" \
  "                    buf = buf + lg_ecr + 2;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < aindice; i++)\n" \
  "    {\n" \
  "        for (j = 0; j < (doc + i)->value.a_classer.iNbPart; j++)\n" \
  "        {\n" \
  "            iLg = strlen((doc + i)->value.a_classer.trpart[j].rpart) - 4;\n" \
  "            (void)strcpy(rIapart.acOriPart, &(doc + i)->value.a_classer.trpart[j].rpart[iLg]);\n" \
  "            memcpy(rIapart.acRefPart, (doc + i)->value.a_classer.trpart[j].rpart, iLg);\n" \
  "            rIapart.acRefPart[iLg] = '\\0';\n" \
  "\n" \
  "            if ((0 == strcmp(rIapart.acOriPart, giv_PJDC)) && (GIV::GIXCodeOK == (doc + i)->value.a_classer.trpart[j].iForPJDC) && (0 != strlen((doc + i)->value.a_classer.etab)))\n" \
  "            {\n" \
  "                /* ajout pour forçage LP-CR pour PJDC */\n" \
  "                strcat(buf, \"<lienurl\");\n" \
  "                strcat(buf, \" \");\n" \
  "                strcat(buf, \"ct\");\n" \
  "                strcat(buf, \"=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                iLg = strlen(rIapart.acRefPart);\n" \
  "\n" \
  "                for (x = 0; (x < iLg && 0 != isdigit(rIapart.acRefPart[x])); x++)\n" \
  "                    ;\n" \
  "\n" \
  "                if (x < iLg)\n" \
  "                    rIapart.acRefPart[x] = '\\0';\n" \
  "\n" \
  "                strcat(buf, rIapart.acRefPart);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" typ_lienurl=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, giv_ssPJDC);\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \" id=\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \"0002\");\n" \
  "                strcat(buf, (doc + i)->value.a_classer.etab);\n" \
  "                strcat(buf, \"0001\");\n" \
  "                strcat(buf, \"\\\"\");\n" \
  "                strcat(buf, \"> </lienurl>\");\n" \
  "                lg_ecr = strlen(buf);\n" \
  "                *(buf + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf + lg_ecr + 1) = LINE_FEED;\n" \
  "                *(buf + lg_ecr + 2) = '\\0';\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrire objets url */\n" \
  "\n" \
  "/* giv_ecrit_tabIeBloc : inserer le resultat dans la table de blocs ou  supprimer une ligne de la table ou enfin mettre à jour plusieurs lignes\n" \
  " --------------------------------------------------------------------------------------------------------------------------------*/\n" \
  "static int4 giv_ecrit_tabIeBloc(GYBrDOCUMENTEpj* doc)\n" \
  "{\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrBlocT BlocLocal;\n" \
  "    int2 indicatrice_acNogrou;\n" \
  "    int2 indicatrice_acNoselo;\n" \
  "    int2 indicatrice_acNosels;\n" \
  "    int2 indicatrice_acEtab;\n" \
  "    char tcEtab[GYBIeinscLgEtab2]; /* etab */\n" \
  "    char tcRequete[800];\n" \
  "    char* pcVersion = NULL;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    int4 iCodRet = (int4)GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = (int4)GIV::GWCCodeOK; /* Code retour des appels internes */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    time_t date;\n" \
  "    date = time(NULL);\n" \
  "    (void)strftime(BlocLocal.acDatemodbloc, sizeof(BlocLocal.acDatemodbloc), \"%Y%m%d\", localtime(&date));\n" \
  "    strcpy(BlocLocal.acDepart, GIXcDepartement);\n" \
  "    /* version du bloc */\n" \
  "    pcVersion = strchr(pcVersionInsFour[0], (char)'.');\n" \
  "    pcVersion++;\n" \
  "\n" \
  "    if (0 == strlen(doc->value.a_classer.etab_dc))\n" \
  "        indicatrice_acEtab = (int2) - 1;\n" \
  "    else\n" \
  "    {\n" \
  "        indicatrice_acEtab = (int2)0;\n" \
  "        strcpy(tcEtab, doc->value.a_classer.etab_dc);\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strcmp(GIVtcGeneIeBloc, \"OUI\"))\n" \
  "    {\n" \
  "        /* Sortie de la fonction */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"TABLE BLOCS DE PARUTIONS ...\\n\"));\n" \
  "    strcpy(BlocLocal.acNumnat, doc->value.inscription[0].val_num);\n" \
  "    strcpy(BlocLocal.acNumlo, doc->value.inscription[0].val_lo);\n" \
  "    strcpy(BlocLocal.acNumls, doc->value.inscription[0].val_ls);\n" \
  "    strcpy(BlocLocal.acNogrou, doc->value.inscription[0].val_grp);\n" \
  "    strcpy(BlocLocal.acNoselo, doc->value.inscription[0].val_seqLO);\n" \
  "    strcpy(BlocLocal.acNosels, doc->value.inscription[0].val_seqLS);\n" \
  "    strcpy(BlocLocal.acBlocid, nom_bloc_ref);\n" \
  "    /* dump des données en cours de traitement */\n" \
  "    /* pour investigation en cas de plantage dur */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Depart=%s,Numnat=%s,Numlo=%s,Numls=%s,Blocid=%s,Nogrou=%s,Noselo=%s,Nosels=%s,Datemodbloc=%s\\n\", BlocLocal.acDepart, BlocLocal.acNumnat, BlocLocal.acNumlo, BlocLocal.acNumls,\n" \
  "                             BlocLocal.acBlocid, BlocLocal.acNogrou, BlocLocal.acNoselo, BlocLocal.acNosels, BlocLocal.acDatemodbloc));\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iDejaPrepare)\n" \
  "    {\n" \
  "        (void)sprintf(tcRequete, GIV_CRE_IS, GIXcNomDest);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtCre\n" \
  "        from: tcRequete;\n" \
  "        (void)sprintf(tcRequete, GIV_CRE_IG, GIXcNomDest);\n" \
  "        EXEC SQL\n" \
  "        prepare rqtCreG\n" \
  "        from: tcRequete;\n" \
  "        iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    if (0 == strlen(BlocLocal.acNogrou))\n" \
  "    {\n" \
  "        indicatrice_acNogrou = (int2) - 1;\n" \
  "        indicatrice_acNoselo = (int2) - 1;\n" \
  "        indicatrice_acNosels = (int2) - 1;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Insert IS GYTtabIeBloc\");\n" \
  "        EXEC SQL\n" \
  "        execute rqtCre\n" \
  "        using\n" \
  "        :BlocLocal.acDepart,\n" \
  "        :BlocLocal.acNumnat,\n" \
  "        :BlocLocal.acNumlo,\n" \
  "        :BlocLocal.acNumls,\n" \
  "        :BlocLocal.acBlocid,\n" \
  "        :tcEtab:indicatrice_acEtab,\n" \
  "        :BlocLocal.acNogrou:indicatrice_acNogrou,\n" \
  "        :BlocLocal.acNoselo:indicatrice_acNoselo,\n" \
  "        :BlocLocal.acNosels:indicatrice_acNosels,\n" \
  "        :BlocLocal.acDatemodbloc,\n" \
  "        :pcVersion;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        indicatrice_acNogrou = (int2)0;\n" \
  "        indicatrice_acNoselo = (int2)0;\n" \
  "        indicatrice_acNosels = (int2)0;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Insert IM GYTtabIeBloc\");\n" \
  "        EXEC SQL\n" \
  "        execute rqtCreG\n" \
  "        using\n" \
  "        :BlocLocal.acDepart,\n" \
  "        :BlocLocal.acNumnat,\n" \
  "        :BlocLocal.acNumlo,\n" \
  "        :BlocLocal.acNumls,\n" \
  "        :BlocLocal.acBlocid,\n" \
  "        :tcEtab:indicatrice_acEtab,\n" \
  "        :BlocLocal.acNogrou:indicatrice_acNogrou,\n" \
  "        :BlocLocal.acNoselo:indicatrice_acNoselo,\n" \
  "        :BlocLocal.acNosels:indicatrice_acNosels,\n" \
  "        :BlocLocal.acDatemodbloc,\n" \
  "        :pcVersion;\n" \
  "        iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acOrdre_sql));\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*-----------------------------Fin de la fonction---------------*/\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givInitConfGXX                                                 */\n" \
  "/*                                                                            */\n" \
  "/* But       : lesture de la configuration externe CG                         */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : néant                                                          */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : néant                                                          */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static void givInitConfGXX()\n" \
  "{\n" \
  "    int4 iIntRet = (int4)GIV::GWCCodeOK;\n" \
  "    char nom_test[50 + 1]; /* Nom du test                */\n" \
  "    char conf[50];\n" \
  "    int4 i;\n" \
  "    /* constitution du nom du fichier Bloc */\n" \
  "    (void)sprintf(conf, \"%s_%s_%s\", \"GIV_PATH_BLOC\", GIXcNomDest, GIXcDepartement);\n" \
  "    iIntRet = GWTLireConf(conf, givcCheminBloc);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givcCheminBloc, \"/DATA/DEPT/CD2G\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de Path des Blocs dans la conf. Valeur par defaut <%s> prise \\n\", givcCheminBloc));\n" \
  "    }\n" \
  "\n" \
  "    (void)sprintf(conf, \"%s_%s_%s\", \"GIV_REPERTOIRE\", GIXcNomDest, GIXcDepartement);\n" \
  "    iIntRet = GWTLireConf(conf, givcRepertoire);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givcRepertoire, GIXcDepartement);\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de répertoire de Blocs dans la conf. Valeur par defaut <%s> prise \\n\", GIXcDepartement));\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : nom du test */\n" \
  "    memset(nom_test, 0, sizeof(nom_test));\n" \
  "    iIntRet = GWTLireConf(\"GIV_NOM_TEST_XML\", nom_test);\n" \
  "    /* Lecture variable d'environnement : caractère remplacement 'espace' du sous-type */\n" \
  "    memset(remplace_espace, 0, sizeof(remplace_espace));\n" \
  "    remplace_espace[0] = ' ';\n" \
  "    iIntRet = GWTLireConf(\"GIV_REMPLACE_ESPACE_SOUS_TYPE\", remplace_espace);\n" \
  "\n" \
  "    /* taille limite du fichier de sortie */\n" \
  "    if ((0 == strcmp(GIXcValUrg, GWZUrgent)) && (0 != strcmp(givRecreerCD, GIXcNomIntf)))\n" \
  "        (void)sprintf(conf, \"%s_%s\", \"GIV_TAILLE_FICHIER_URJ\", GIXcNomDest);\n" \
  "    else\n" \
  "        (void)sprintf(conf, \"%s_%s\", \"GIV_TAILLE_FICHIER_XML\", GIXcNomDest);\n" \
  "\n" \
  "    if (0 != GWTLireConfNum(conf, &giviNbBlocs))\n" \
  "        giviNbBlocs = -1;\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Taille fichier XML en blocs : %8d\\n\", giviNbBlocs));\n" \
  "    /* Lecture variable d'environnement : chemin SGIPRO */\n" \
  "    memset(givtcRepSgiPro, 0, sizeof(givtcRepSgiPro));\n" \
  "    /* constitution du nom du fichier Bloc */\n" \
  "    (void)sprintf(conf, \"%s\", \"GIV_PATHCONTENU\");\n" \
  "    iIntRet = GWTLireConf(conf, givtcRepSgiPro);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcRepSgiPro, \"/fast/SGIPRO\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de Path des fichiers SGIPRO dans la conf. Valeur par defaut <%s> prise \\n\", givtcRepSgiPro));\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : chemin MPG */\n" \
  "    memset(givtcRepMpg, 0, sizeof(givtcRepMpg));\n" \
  "    /* constitution du nom du fichier MPG */\n" \
  "    (void)sprintf(conf, \"%s\", \"GIV_PATH_MPG\");\n" \
  "    iIntRet = GWTLireConf(conf, givtcRepMpg);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcRepMpg, \"/DATA/DEPT/CD2G/888\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de Path des fichiers SGIPRO dans la conf. Valeur par defaut <%s> prise \\n\", givtcRepMpg));\n" \
  "    }\n" \
  "\n" \
  "    iIntRet = GWTLireConf(\"GIV_VERS_DOC_EPJ\", givtcVersDoc);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        givtcVersDoc[0] = '\\0';\n" \
  "\n" \
  "    /* Lecture variable d'environnement : paru loc arr intallation */\n" \
  "    memset(givtcLocArrInst, 0, sizeof(givtcLocArrInst));\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_PARU_ARR_INST\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcLocArrInst);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de paru loc arr intallation dans la conf \\n\"));\n" \
  "    else\n" \
  "    {\n" \
  "        for (i = 0; i < 3; i++)\n" \
  "        {\n" \
  "            /* parution sur arrondissement d'installation */\n" \
  "            strcpy(buf_concat, givtrRefArr[i].dep);\n" \
  "            strcat(buf_concat, givtrRefArr[i].loc);\n" \
  "\n" \
  "            if (NULL != strstr(givtcLocArrInst, buf_concat))\n" \
  "                givtrRefArr[i].iParuInst = (int4)GIV::GIXCodeOK;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : regions CECI */\n" \
  "    memset(givtcRegCECI, 0, sizeof(givtcRegCECI));\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_REGION_CECI\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcRegCECI);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(givtcRegCECI, \"NON\");\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Regions CECI %s \\n\", givtcRegCECI));\n" \
  "    /* Lecture variable d'environnement : liste objets contenu */\n" \
  "    memset(givtcObjCont, 0, sizeof(givtcObjCont));\n" \
  "    /* constitution du nom du fichier Bloc */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_OBJETS_CONTENU\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcObjCont);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcObjCont, \"\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas d'objet contenu dans la conf \\n\"));\n" \
  "    }\n" \
  "\n" \
  "    memset(givtcPrioCont, 0, sizeof(givtcPrioCont));\n" \
  "    /* constitution du nom du fichier Bloc */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_PRIORITE_CONTENU\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcPrioCont);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcPrioCont, \"\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de priorité des contenus dans la conf \\n\"));\n" \
  "    }\n" \
  "\n" \
  "    memset(givtcExceptCont, 0, sizeof(givtcExceptCont));\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_CRC_EXCEPT\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcExceptCont);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcExceptCont, \"\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas d'exception sur les contenus dans la conf \\n\"));\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : liste partenaires à éliminer */\n" \
  "    memset(givtcFourPart, 0, sizeof(givtcFourPart));\n" \
  "    /* constitution du nom de paramètre */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_NON_PARU_PART\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcFourPart);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcFourPart, \"\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de partenaire à éliminer \\n\"));\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : rapprochement ED  */\n" \
  "    memset(givtcRapED, 0, sizeof(givtcRapED));\n" \
  "    /* constitution du nom du fichier Bloc */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_RAP_EDITO\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcRapED);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcRapED, \"NON\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de rapprochement Etab/ED dans la conf. Valeur par defaut <%s> prise \\n\", givtcRapED));\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : contenu à traiter */\n" \
  "    memset(givtcContenu, 0, sizeof(givtcContenu));\n" \
  "    /* constitution du nom du fichier Bloc */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_CONTENU\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcContenu);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcObjCont, \"\");\n" \
  "        (void)strcpy(givtcContenu, \"NON\");\n" \
  "        (void)strcpy(givtcRapED, \"NON\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de contenu dans la conf \\n\"));\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        if (0 == strcmp(\"NON\", givtcContenu))\n" \
  "        {\n" \
  "            (void)strcpy(givtcObjCont, \"\");\n" \
  "            (void)strcpy(givtcRapED, \"NON\");\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Pas de contenu dans la conf \\n\"));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : liste produits 'Annonces Mesurées' */\n" \
  "    memset(givtcAnMes, 0, sizeof(givtcAnMes));\n" \
  "    /* constitution du nom du paramètre */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_AN_MES\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcAnMes);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "    {\n" \
  "        (void)strcpy(givtcAnMes, \"\");\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Pas de produit 'Annonces Mesurées' dans la conf \\n\"));\n" \
  "    }\n" \
  "\n" \
  "    /* Lecture variable d'environnement : suppression qualite dans cpl denom */\n" \
  "    memset(givtcSupCplDen, 0, sizeof(givtcSupCplDen));\n" \
  "    /* constitution du nom du paramètre */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_SUP_QUAL_CPL\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcSupCplDen);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(givtcSupCplDen, \"NON\");\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Suppression qual dans cpldenom <%s> \\n\", givtcSupCplDen));\n" \
  "    /* Lecture variable d'environnement : inversion de la denomination exacte */\n" \
  "    memset(givtcInvDenPn, 0, sizeof(givtcInvDenPn));\n" \
  "    /* constitution du nom du paramètre */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"INV_DNOM_PRE\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcInvDenPn);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(givtcInvDenPn, \"NON\");\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Inversion de la denomination exacte <%s> \\n\", givtcInvDenPn));\n" \
  "    /* paramêtre d'accès à GYTtabIeBlocCRC */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_GENE_IEBLOCEPJ_CRC\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcGeneIeBlocCRC);\n" \
  "\n" \
  "    if ((GIV::GWTok != iIntRet) || ((0 == strcmp(givRecreerCD, GIXcNomIntf)) && (0 == strcmp(GIXcValUrg, GWZUrgent))))\n" \
  "        (void)strcpy(givtcGeneIeBlocCRC, \"NON\");\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Accès GYTtabIeBlocCRC <%s> \\n\", givtcGeneIeBlocCRC));\n" \
  "    /* paramêtre d'affichage AffCRC */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_GENE_AFF_CRC\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcGeneAffCRC);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(givtcGeneAffCRC, \"NON\");\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"AFFCRC <%s> \\n\", givtcGeneAffCRC));\n" \
  "    /* Lecture variable d'environnement : contenu partenaire au niveau inscription */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_CONTENU_PART_INSC\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcPartInsc);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(givtcPartInsc, \"NON\");\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"contenu partenaire au niveau inscription <%s> \\n\", givtcPartInsc));\n" \
  "    /* Lecture variable d'environnement : parution pour inscription par epj */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_PARUTION_INSC_EPJ\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcParuInscEpj);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(givtcParuInscEpj, \"NON\");\n" \
  "\n" \
  "    /* Lecture variable d'environnement : format balise text */\n" \
  "    (void)sprintf(conf, \"%s_%s\", \"GIV_CONTENU_TEXT_EPJ\", GIXcNomDest);\n" \
  "    iIntRet = GWTLireConf(conf, givtcContText);\n" \
  "\n" \
  "    if (GIV::GWTok != iIntRet)\n" \
  "        (void)strcpy(givtcContText, \"NON\");\n" \
  "\n" \
  "    /* pas de fichier ouvert */\n" \
  "    GIVfDescFicMCD = NULL;\n" \
  "    /* pas de bloc de référence */\n" \
  "    memset(nom_bloc_ref, '0', sizeof(nom_bloc));\n" \
  "    giviNumFic = giviNumFicInit;\n" \
  "    /* préparation suppressions dans IeBloc */\n" \
  "    iIntRet = givPreparerRequetesIeBloc();\n" \
  "    return;\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_1 ()                                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie une du bloc de parution simple ou groupe       */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification (Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 giv_ecrit_partie_1(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char type_bloc[2]; /* Type de bloc : 'o' ou 'p'  */\n" \
  "    int4 lg_numlo;\n" \
  "    int4 lg_IG, i;\n" \
  "    int4 iIntRet = (int4)GIV::GWCCodeOK;\n" \
  "    char chaine_id[7 + 1]; /* Numero qui s'incremente    */\n" \
  "    char ch[15 + 1]; /* Date du jour               */\n" \
  "    struct tm* pdh;\n" \
  "    time_t intps;\n" \
  "    int4 nbc;\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char* pcVersion = NULL;\n" \
  "    /* Calcul du numero d'identifiant parution_id */\n" \
  "    num_id = num_id + 1;\n" \
  "    sprintf(chaine_id, \"%07d\", num_id);\n" \
  "\n" \
  "    if (obtention_iden == 0)\n" \
  "    {\n" \
  "        givInitConfGXX();\n" \
  "        /* Pour ne plus recaluler au prochain passage */\n" \
  "        obtention_iden = 1;\n" \
  "    }\n" \
  "\n" \
  "    /* init nom de bloc */\n" \
  "    if (0 == strlen(doc->value.inscription[0].val_grp))\n" \
  "    {\n" \
  "        strcpy(nom_bloc, doc->value.a_classer.etab);\n" \
  "        strcpy(nom_bloc_ref, nom_bloc);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"nom_bloc = %s\\n\", nom_bloc));\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        strcpy(nom_bloc, doc->value.a_classer.etab);\n" \
  "        strcpy(nom_bloc_ref, nom_bloc);\n" \
  "\n" \
  "        if (0 != iMaxBlocEcritAvant)\n" \
  "        {\n" \
  "            sprintf(chaine_id, \"%04d\", iMaxBlocEcritAvant);\n" \
  "            strcat(nom_bloc, chaine_id);\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"nom_bloc = %s\\n\", nom_bloc));\n" \
  "    }\n" \
  "\n" \
  "    /* init numéro de bloc */\n" \
  "    num_bloc = 1;\n" \
  "    sprintf(chaine_id, \"%04d\", num_bloc);\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        sprintf(chaine_id, \"%04d\", 2);\n" \
  "    else\n" \
  "        sprintf(chaine_id, \"%04d\", 1);\n" \
  "\n" \
  "    /* Generation de la chaine pour \"pjparutionid\" */\n" \
  "    strcpy(doc->parution_id, nom_bloc);\n" \
  "    strcpy(doc->parution_id_ref, nom_bloc_ref);\n" \
  "\n" \
  "    for (i = 1; i < indice; i++)\n" \
  "        strcpy((doc + i)->parution_id, (doc)->parution_id);\n" \
  "\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"OPERATION\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, \"addition\", \"TYPE_OPERATION\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->parution_id, \"NAME\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    pcVersion = strchr(pcVersionInsFour[0], (char)'.');\n" \
  "    pcVersion++;\n" \
  "\n" \
  "    if (0 == strlen(doc->value.numero_client))\n" \
  "        (void)sprintf(&cNomFichier[0], \"%s/%c%c/%c%c/%s_v%s.xml\", givcCheminBloc, doc->value.inscription[0].moyen_de_com.numero[0], doc->value.inscription[0].moyen_de_com.numero[1],\n" \
  "                      doc->value.inscription[0].moyen_de_com.numero[2], doc->value.inscription[0].moyen_de_com.numero[3], doc->parution_id, pcVersion);\n" \
  "    else\n" \
  "        (void)sprintf(&cNomFichier[0], \"%s/%c%c/%c%c/%s_v%s.xml\", givcCheminBloc, doc->value.numero_client[0], doc->value.numero_client[1], doc->value.numero_client[2], doc->value.numero_client[3],\n" \
  "                      doc->parution_id, pcVersion);\n" \
  "\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"CONTENT\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_2_1 ()                                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie deux du bloc de parution simple ou groupe      */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_ecrit_partie_2_1(char** buf_pos_in, GYBrDOCUMENTEpj* docEPJ, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos, *buf_pos_ref, *buf_pos_cur;\n" \
  "    int4 iRet, iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_tmp, iDebut, iLg;\n" \
  "    char* pcVersion = NULL;\n" \
  "    char transforme_stype[2 + 1];\n" \
  "    char ref_pub[1 + 2 + 2 + 1];\n" \
  "    char tcRefext[17 + 1];\n" \
  "    char tcNbimag[100];\n" \
  "    char tcImagCat[2];\n" \
  "    char tcMenu[2];\n" \
  "    int4 i, j, x, y, z, zz;\n" \
  "    int4 iLgChaineApvr;\n" \
  "    char* pcDeb;\n" \
  "    char* pcFin;\n" \
  "    int4 pipe;\n" \
  "    int4 iQualite;\n" \
  "    char tcPrecision[2 + 1];\n" \
  "    char tcStat[100 + 1];\n" \
  "    int4 iRang;\n" \
  "    GYBrIeinscT rInscRef;\n" \
  "    GYBrIamicT rIamic;\n" \
  "    GYBrIapartT rIapart;\n" \
  "    GYBstrIeinscNumcliT tcNumcli;\n" \
  "    char tcProduit[GYBIamicLgTypobj + (2 * GYBIamicLgTpdsob) + 1];\n" \
  "    char tcEvt[2], tcPrg[2];\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    int4 iPrenom, iCpl, iMots, iMarq, iQual, iInMq = 0;\n" \
  "    char cInfo, cAvis;\n" \
  "    char tcElmt[29 + 1]; /* partenaire*/\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Calcul du numero d'identifiant parution_id */\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        strcpy((doc + i)->value.numero_bloc_parution, doc->parution_id);\n" \
  "        strcpy((doc + i)->value.numero_bloc_parution_ref, doc->parution_id_ref);\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = (int4)giv_fichier_sortie(&buf_pos, &GIVfDescFicMCD);\n" \
  "    GIVfDescFicBloc = GIVfDescFicMCD;\n" \
  "    lg_tmp = 0;\n" \
  "    strcpy(buf_pos, \"<blocepj>\");\n" \
  "    lg_tmp = strlen(buf_pos);\n" \
  "    *(buf_pos + lg_tmp) = SEPARE_LIGNE;\n" \
  "    *(buf_pos + (lg_tmp + 1)) = LINE_FEED;\n" \
  "    *(buf_pos + (lg_tmp + 2)) = '\\0';\n" \
  "    buf_pos = (buf_pos + lg_tmp + 2);\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.numero_bloc_parution, \"blocepjid\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    pcVersion = strchr(pcVersionInsFour[0], (char)'.');\n" \
  "    pcVersion++;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, pcVersion, \"version\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, cDate, \"datmodblocepj\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, givtcVersDoc, \"vdoc\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    for (i = 0; i < (indice); i++)\n" \
  "    {\n" \
  "        if (giv_cLEUR == (doc + i)->cNature)\n" \
  "        {\n" \
  "            /* indication de bloc leurre */\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"1\", \"leurre\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"epj\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.intitule.denomination, \"denom\");\n" \
  "    lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.intitule.complement_denomination, \"cpldenom\");\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.a_classer.etab, \"etab\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.instal, \"codloc\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.numero_voie, \"numvoie\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.lib_complt_num_voie, \"libcplnumvoie\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.code_voie, \"codvoie\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    if (0 != strlen(docEPJ->value.inscription[0].adresse.lib_code_voie))\n" \
  "        lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.inscription[0].adresse.lib_code_voie, \"libvoie\");\n" \
  "    else\n" \
  "        lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.inscription[0].adresse.libel_voie, \"libvoie\");\n" \
  "\n" \
  "    lg_write = giv_ecrit_balise_epj(&buf_pos, docEPJ->value.inscription[0].adresse.adrnr, \"adrnr\");\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.libinstal, \"libloc\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.geoloc.longitude, \"long\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.inscription[0].adresse.geoloc.latitude, \"lat\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    iQualite = atoi(docEPJ->value.inscription[0].adresse.geoloc.precision);\n" \
  "\n" \
  "    switch (iQualite)\n" \
  "    {\n" \
  "    case 97:\n" \
  "    case 99:\n" \
  "        break;\n" \
  "\n" \
  "    case 96:\n" \
  "    case 98:\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"04\", \"precision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"1\", \"srcprecision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        break;\n" \
  "\n" \
  "    default:\n" \
  "        iQualite = iQualite % 4;\n" \
  "        (void)sprintf(&tcPrecision[0], \"%02d\", iQualite);\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcPrecision, \"precision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        iQualite = atoi(docEPJ->value.inscription[0].adresse.geoloc.precision);\n" \
  "        iQualite = iQualite / 4;\n" \
  "        (void)sprintf(&tcPrecision[0], \"%d\", iQualite);\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcPrecision, \"srcprecision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        break;\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    /* lecture et criture chapms Siret */\n" \
  "    iDebut = 1;\n" \
  "    iCodRet = givEcritureEtab(doc, &buf_pos, &iDebut);\n" \
  "    iDebut = 1;\n" \
  "    giviRefPJDC = -1;\n" \
  "    /* lecture et écriture des denominations secondaires */\n" \
  "    iCodRet = givEcritureDenomEtab(doc, &buf_pos, &iDebut);\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    /* analyse de partenaire PJDC */\n" \
  "    iDebut = 1;\n" \
  "\n" \
  "    for (j = 0; j < doc->value.a_classer.iNbPart; j++)\n" \
  "    {\n" \
  "        iLg = strlen(doc->value.a_classer.trpart[j].rpart) - 4;\n" \
  "        doc->value.a_classer.trpart[j].iRgParent = giviNbParentPart;\n" \
  "        doc->value.a_classer.trpart[j].iNbParent = 0;\n" \
  "\n" \
  "        if (0 == strcmp(giv_PJDC, &doc->value.a_classer.trpart[j].rpart[iLg]))\n" \
  "        {\n" \
  "            giviRefPJDC = j;\n" \
  "            /* lecture et écriture des denominations du partenaire PJDC parent */\n" \
  "            iLg = strlen(doc->value.a_classer.trpart[j].rpart) - 4;\n" \
  "            (void)strcpy(rIapart.acOriPart, &doc->value.a_classer.trpart[j].rpart[iLg]);\n" \
  "            memcpy(rIapart.acRefPart, doc->value.a_classer.trpart[j].rpart, iLg);\n" \
  "            rIapart.acRefPart[iLg] = '\\0';\n" \
  "            strcpy(rIapart.acParentRefPart, doc->value.a_classer.trpart[j].parent);\n" \
  "            strcpy(rIapart.acTypeRefPart, doc->value.a_classer.trpart[j].typepart);\n" \
  "            /* intitule du partenaire pjdc */\n" \
  "            lg_write = giv_init_denom_parent(buf_pos, doc->value.a_classer.etab, &iDebut);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Type à traiter <%s> \\n\", doc->value.a_classer.trpart[j].typepart));\n" \
  "\n" \
  "            if ((giv_orPJDC == rIapart.acTypeRefPart[0]) || (giv_cPJDC == rIapart.acTypeRefPart[0]))\n" \
  "            {\n" \
  "                /* recherche des types giv_svPJDC ou giv_prPJDC */\n" \
  "                iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart, &giviNbParentPart, &iDebut, NULL);\n" \
  "            }\n" \
  "            else if ((giv_prPJDC == rIapart.acTypeRefPart[0]) && (0 != strlen(rIapart.acParentRefPart)))\n" \
  "            {\n" \
  "                /* recherche des types giv_cPJDC ou giv_svPJDC ou/et giv_orPJDC */\n" \
  "                iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart, &giviNbParentPart, &iDebut, NULL);\n" \
  "\n" \
  "                if ((0 != giviNbParentPart) && (giv_svPJDC == givtrPart[giviNbParentPart - 1].acTypeRefPart[0]))\n" \
  "                {\n" \
  "                    if (0 != strlen(givtrPart[giviNbParentPart - 1].acParentRefPart))\n" \
  "                    {\n" \
  "                        if (0 != strcmp(rIapart.acRefPart, givtrPart[giviNbParentPart - 1].acParentRefPart))\n" \
  "                        {\n" \
  "                            rIapart.acTypeRefPart[0] = givtrPart[giviNbParentPart - 1].acTypeRefPart[0];\n" \
  "                            strcpy(rIapart.acParentRefPart, givtrPart[giviNbParentPart - 1].acParentRefPart);\n" \
  "                            iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart, &giviNbParentPart, &iDebut, NULL);\n" \
  "                        }\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "            else if (giv_svPJDC == rIapart.acTypeRefPart[0])\n" \
  "            {\n" \
  "                /* recherche des types giv_orPJDC et giv_prPJDC */\n" \
  "                iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart, &giviNbParentPart, &iDebut, NULL);\n" \
  "\n" \
  "                if (0 != strlen(rIapart.acParentRefPart))\n" \
  "                {\n" \
  "                    rIapart.acParentRefPart[0] = '\\0';\n" \
  "                    iRet = GIVLecturePartEtabNav(&buf_pos, &rIapart, givtrPart, &giviNbParentPart, &iDebut, NULL);\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            doc->value.a_classer.trpart[j].iNbParent = giviNbParentPart - doc->value.a_classer.trpart[j].iRgParent;\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulelibpjdc\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ('1' == doc->value.a_classer.parinsee)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.a_classer.siret, \"siret\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, docEPJ->value.a_classer.naf, \"ape\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"epj\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    iRet = givLectureOldEtab(&buf_pos, doc->value.a_classer.etab);\n" \
  "    /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    /* intitulé principal */\n" \
  "    iRang = givDnomPrincEtab(doc, indice);\n" \
  "    doc->value.intitule.iRgPrinc = iRang;\n" \
  "\n" \
  "    if (-1 != iRang)\n" \
  "    {\n" \
  "        strcpy(buf_concat, \"\");\n" \
  "\n" \
  "        for (x = 0; x < indice; x++)\n" \
  "        {\n" \
  "            for (y = 0; y < (doc + x)->value.a_classer.iNbPart; y++)\n" \
  "            {\n" \
  "                if ((giv_prPJDC == (doc + x)->value.a_classer.trpart[y].typepart[0]) && (0 == strcmp(\"true\", (doc + x)->value.a_classer.trpart[y].isdoc)))\n" \
  "                {\n" \
  "                    /* ajout possible de \"DR\" pour docteur */\n" \
  "                    break;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if ((doc + x)->value.a_classer.iNbPart != y)\n" \
  "            {\n" \
  "                /* ajout possible de \"DR\" pour docteur */\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((indice != x) && (0 == strlen((doc + iRang)->value.intitule.prenom)))\n" \
  "        {\n" \
  "            /* analyse de l'intitulé sans prénom pour PJDC */\n" \
  "            strcpy(rInscRef.acNumnat, (doc + iRang)->value.inscription[0].val_num);\n" \
  "            strcpy(rInscRef.acNumlo, (doc + iRang)->value.inscription[0].val_lo);\n" \
  "            strcpy(rInscRef.acNumls, (doc + iRang)->value.inscription[0].val_ls);\n" \
  "            iRet = GDQLibererCtxt();\n" \
  "            iRet = GDQQualifBlocIntl(&rInscRef);\n" \
  "\n" \
  "            if (GIV::GIXCodeRIEN == iRet)\n" \
  "            {\n" \
  "                /* ajout de \"DR\" pour docteur */\n" \
  "                strcat(buf_concat, givTitreDoc);\n" \
  "            }\n" \
  "        }\n" \
  "        else if ((indice != x) && (0 != strlen((doc + iRang)->value.intitule.prenom)))\n" \
  "        {\n" \
  "            /* ajout de \"DR\" pour docteur avec prénom */\n" \
  "            strcat(buf_concat, givTitreDoc);\n" \
  "        }\n" \
  "\n" \
  "        for (i = 0; i < indice; i++)\n" \
  "        {\n" \
  "            for (j = 0; (j < (doc + i)->value.rubriques.iNban9 && ('0' == (doc + i)->value.rubriques.Tan9[j].dnex)); j++)\n" \
  "                ;\n" \
  "\n" \
  "            if ((doc + i)->value.rubriques.iNban9 != j)\n" \
  "                break;\n" \
  "        }\n" \
  "\n" \
  "        if ((0 == strcmp(givtcInvDenPn, \"NON\")) || (indice == i))\n" \
  "        {\n" \
  "            strcat(buf_concat, (doc + iRang)->value.intitule.denomination);\n" \
  "\n" \
  "            if (0 != strlen((doc + iRang)->value.intitule.prenom))\n" \
  "            {\n" \
  "                strcat(buf_concat, \" \");\n" \
  "                strcat(buf_concat, (doc + iRang)->value.intitule.prenom);\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* inversion de l'ordre le la denomination exacte */\n" \
  "            if (0 != strlen((doc + iRang)->value.intitule.prenom))\n" \
  "            {\n" \
  "                strcat(buf_concat, (doc + iRang)->value.intitule.prenom);\n" \
  "                strcat(buf_concat, \" \");\n" \
  "                strcat(buf_concat, (doc + iRang)->value.intitule.denomination);\n" \
  "            }\n" \
  "            else\n" \
  "                strcat(buf_concat, (doc + iRang)->value.intitule.denomination);\n" \
  "        }\n" \
  "\n" \
  "        if (0 != strlen((doc + iRang)->value.intitule.complement_denomination))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, (doc + iRang)->value.intitule.complement_denomination);\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, \"intlprincipal\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"seo\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if ((0 != strlen(doc->value.a_classer.etab)) && ('0' != doc->cPubPrinc) && (giv_cLEUR != doc->cNature))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Etab SEO... %s\\n\", doc->value.a_classer.etab));\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.a_classer.etab, \"lepj\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.a_classer.etab, \"epj\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"longseo\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        if (0 != strlen(doc->value.a_classer.etab))\n" \
  "        {\n" \
  "            iRet = givServiceEtabSEO(doc, &cInfo, &cAvis);\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iRet && 'o' == cInfo)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Info Etab SEO...\\n\"));\n" \
  "                lg_write = giv_ecrit_balise(buf_pos, \"info\", \"ongseo\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iRet && 'o' == cAvis)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Avis Etab SEO...\\n\"));\n" \
  "                lg_write = giv_ecrit_balise(buf_pos, \"avis\", \"ongseo\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"longseo\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"seo\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"2\", \"typeclient\");\n" \
  "    else\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"1\", \"typeclient\");\n" \
  "\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (0 != strlen(doc->value.a_classer.etab))\n" \
  "    {\n" \
  "        /* établissement */\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"1\", \"petab\");\n" \
  "    }\n" \
  "    else\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"0\", \"petab\");\n" \
  "\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (0 != strlen(doc->value.a_classer.etab))\n" \
  "    {\n" \
  "        iRet = givLectureEvIlo(doc->value.a_classer.etab, &tcEvt[0], &tcPrg[0]);\n" \
  "        tcEvt[1] = '\\0';\n" \
  "        tcPrg[1] = '\\0';\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcPrg, \"iloprg\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcEvt, \"iloevt\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        iRet = givLectureEtabMC(doc->value.a_classer.etab, doc->value.a_classer.parinsee, &buf_pos);\n" \
  "    }\n" \
  "\n" \
  "    if ((0 != strlen(doc->value.a_classer.siret)) && ('1' == doc->value.a_classer.parinsee))\n" \
  "    {\n" \
  "        iRet = givLectureSIRET(doc->value.a_classer.siret);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iRet)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"1\", \"pagespro\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(doc->value.a_classer.etab))\n" \
  "    {\n" \
  "        /* BonPlan autorisé pour les IO et les IS */\n" \
  "        iRet = givEcritureBonPlan(doc->value.a_classer.etab, &buf_pos);\n" \
  "    }\n" \
  "\n" \
  "    pipe = 0;\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        if (pipe == 0)\n" \
  "        {\n" \
  "            strcpy(buf_concat, (doc + x)->value.numero_client);\n" \
  "            pipe = 1;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            strcat(buf_concat, \"|\");\n" \
  "            strcat(buf_concat, (doc + x)->value.numero_client);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (1 == pipe)\n" \
  "    {\n" \
  "        iRet = supprimer_doublon(buf_concat, '|');\n" \
  "        pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "        for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            /* analyse client */\n" \
  "            memcpy(tcNumcli, pt_debut, (pt_fin - pt_debut));\n" \
  "            tcNumcli[(pt_fin - pt_debut)] = '\\0';\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"numclis\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_element(buf_pos, \"numcli\", tcNumcli);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iRet = givLectureStat(tcNumcli, tcStat);\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, tcStat, \"estatan\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iRet = givLectureEmbauche(tcNumcli, tcRefext);\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, tcRefext, \"jobid\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"numclis\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    buf_concat[0] = '\\0';\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        if ((0 != strlen((doc + x)->value.a_classer.etab)) && (0 == strcmp(\"0000\", (doc + x)->value.inscription[0].val_ls)) && ('0' == (doc + x)->cIndPart))\n" \
  "        {\n" \
  "            iRet = givLectureBUC((doc + x)->value.a_classer.etab, \"0001\", \"7999\");\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(buf_concat))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" BUC... %s\\n\", buf_concat));\n" \
  "        iRet = supprimer_doublon(buf_concat, '|');\n" \
  "        pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "        for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            /* analyse client */\n" \
  "            memcpy(tcNumcli, pt_debut, (pt_fin - pt_debut));\n" \
  "            tcNumcli[(pt_fin - pt_debut)] = '\\0';\n" \
  "            lg_write = giv_ecrit_element(buf_pos, \"numclipj\", tcNumcli);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    buf_concat[0] = '\\0';\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        if ((0 != strlen((doc + x)->value.a_classer.etab)) && (0 == strcmp(\"0000\", (doc + x)->value.inscription[0].val_ls)) && ('0' == (doc + x)->cIndPart))\n" \
  "        {\n" \
  "            iRet = givLectureBUC((doc + x)->value.a_classer.etab, \"8000\", \"9999\");\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(buf_concat))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" BUC... %s\\n\", buf_concat));\n" \
  "        iRet = supprimer_doublon(buf_concat, '|');\n" \
  "        pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "        for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            /* analyse client */\n" \
  "            memcpy(tcNumcli, pt_debut, (pt_fin - pt_debut));\n" \
  "            tcNumcli[(pt_fin - pt_debut)] = '\\0';\n" \
  "            lg_write = giv_ecrit_element(buf_pos, \"numclicdh\", tcNumcli);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.intitule.datefinparu, \"finparut\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        if (0 == x)\n" \
  "            y = x;\n" \
  "        else\n" \
  "            y = x - 1;\n" \
  "\n" \
  "        if ((0 == x) || (0 != strcmp((doc + x)->value.intitule.denomination, (doc + y)->value.intitule.denomination)))\n" \
  "        {\n" \
  "            if (0 != x)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"qualites\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"marquess\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"motsdets\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"cpldenoms\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"prenoms\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitule\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"intitule\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (doc + x)->value.intitule.denomination, \"denom\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iRet = givLectureSynonyme(doc, &buf_pos, x, indice);\n" \
  "            iPrenom = 1;\n" \
  "        }\n" \
  "\n" \
  "        if ((1 == iPrenom) || (0 != strcmp((doc + x)->value.intitule.prenom, (doc + y)->value.intitule.prenom)))\n" \
  "        {\n" \
  "            if (1 != iPrenom)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"qualites\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"marquess\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"motsdets\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"cpldenoms\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"prenoms\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"prenoms\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (doc + x)->value.intitule.prenom, \"prenom\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (doc + x)->value.intitule.initiale, \"iprenom\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            for (z = 0; z < indice; z++)\n" \
  "            {\n" \
  "                for (zz = 0; (zz < (doc + z)->value.rubriques.iNban9 && ('0' == (doc + z)->value.rubriques.Tan9[zz].dnex)); zz++)\n" \
  "                    ;\n" \
  "\n" \
  "                if ((doc + z)->value.rubriques.iNban9 != zz)\n" \
  "                    break;\n" \
  "            }\n" \
  "\n" \
  "            if ((0 == strcmp(givtcInvDenPn, \"NON\")) || (indice == z))\n" \
  "            {\n" \
  "                strcpy(buf_concat, (doc + x)->value.intitule.denomination);\n" \
  "\n" \
  "                if (0 != strlen((doc + x)->value.intitule.prenom))\n" \
  "                {\n" \
  "                    strcat(buf_concat, \" \");\n" \
  "                    strcat(buf_concat, (doc + x)->value.intitule.prenom);\n" \
  "                }\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* inversion de l'ordre le la denomination exacte */\n" \
  "                if (0 != strlen((doc + x)->value.intitule.prenom))\n" \
  "                {\n" \
  "                    strcpy(buf_concat, (doc + x)->value.intitule.prenom);\n" \
  "                    strcat(buf_concat, \" \");\n" \
  "                    strcat(buf_concat, (doc + x)->value.intitule.denomination);\n" \
  "                }\n" \
  "                else\n" \
  "                    strcpy(buf_concat, (doc + x)->value.intitule.denomination);\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, \"denomexacte\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iPrenom = 0;\n" \
  "            iCpl = 1;\n" \
  "        }\n" \
  "\n" \
  "        if ((1 == iCpl) || (0 != strcmp((doc + x)->value.inscription[0].moyen_de_com.laqualite, (doc + y)->value.inscription[0].moyen_de_com.laqualite)))\n" \
  "        {\n" \
  "            if (1 != iCpl)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"qualites\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"marquess\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"motsdets\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"cpldenoms\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"cpldenoms\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            memset(buf_concat, 0, strlen(buf_concat));\n" \
  "            strcpy(buf_concat, (doc + x)->value.intitule.complement_denomination);\n" \
  "\n" \
  "            if (0 == strcmp(givtcSupCplDen, \"OUI\"))\n" \
  "            {\n" \
  "                if (0 == strcmp((doc + x)->value.intitule.complement_denomination, (doc + x)->value.inscription[0].moyen_de_com.laqualite))\n" \
  "                    buf_concat[0] = '\\0';\n" \
  "                else if (0 != strlen((doc + x)->value.inscription[0].moyen_de_com.laqualite))\n" \
  "                {\n" \
  "                    pcDeb = strstr(buf_concat, (doc + x)->value.inscription[0].moyen_de_com.laqualite);\n" \
  "\n" \
  "                    if (NULL != pcDeb)\n" \
  "                    {\n" \
  "                        if ((pcDeb == &buf_concat[0]) && (' ' == *(pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.laqualite))))\n" \
  "                            (void)strcpy(pcDeb, pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.laqualite) + 1);\n" \
  "                        else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && (' ' == *(pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.laqualite))))\n" \
  "                            (void)strcpy(pcDeb, pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.laqualite) + 1);\n" \
  "                        else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && ('\\0' == *(pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.laqualite))))\n" \
  "                            *(pcDeb - 1) = '\\0';\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, \"cpldenom\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iCpl = 0;\n" \
  "            iMots = 1;\n" \
  "        }\n" \
  "\n" \
  "        if ((1 == iMots) || (0 != strcmp((doc + x)->value.intitule.mots_determinants, (doc + y)->value.intitule.mots_determinants)))\n" \
  "        {\n" \
  "            if (1 != iMots)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"qualites\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"marquess\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"motsdets\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"motsdets\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (doc + x)->value.intitule.mots_determinants, \"motsdet\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iMots = 0;\n" \
  "            iMarq = 1;\n" \
  "        }\n" \
  "\n" \
  "        if ((1 == iMarq) || (0 != strcmp((doc + x)->value.inscription[0].moyen_de_com.lamarque, (doc + y)->value.inscription[0].moyen_de_com.lamarque)))\n" \
  "        {\n" \
  "            if (1 != iMarq)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"qualites\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"marquess\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"marquess\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (doc + x)->value.inscription[0].moyen_de_com.lamarque, \"marques\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            memset(buf_concat, 0, strlen(buf_concat));\n" \
  "            strcpy(buf_concat, (doc + x)->value.intitule.denomination);\n" \
  "\n" \
  "            if (0 == strcmp((doc + x)->value.intitule.denomination, (doc + x)->value.inscription[0].moyen_de_com.lamarque))\n" \
  "                buf_concat[0] = '\\0';\n" \
  "            else if (0 != strlen((doc + x)->value.inscription[0].moyen_de_com.lamarque))\n" \
  "            {\n" \
  "                pcDeb = strstr(buf_concat, (doc + x)->value.inscription[0].moyen_de_com.lamarque);\n" \
  "\n" \
  "                if (NULL != pcDeb)\n" \
  "                {\n" \
  "                    if ((pcDeb == &buf_concat[0]) && (' ' == *(pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.lamarque))))\n" \
  "                        (void)strcpy(pcDeb, pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.lamarque) + 1);\n" \
  "                    else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && (' ' == *(pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.lamarque))))\n" \
  "                        (void)strcpy(pcDeb, pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.lamarque) + 1);\n" \
  "                    else if ((pcDeb != &buf_concat[0]) && (' ' == *(pcDeb - 1)) && ('\\0' == *(pcDeb + strlen((doc + x)->value.inscription[0].moyen_de_com.lamarque))))\n" \
  "                        *(pcDeb - 1) = '\\0';\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, \"rs\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iMarq = 0;\n" \
  "            iQual = 1;\n" \
  "        }\n" \
  "\n" \
  "        if ((1 == iQual) || (0 != strcmp((doc + x)->value.inscription[0].moyen_de_com.laqualite, (doc + y)->value.inscription[0].moyen_de_com.laqualite)))\n" \
  "        {\n" \
  "            if (1 != iQual)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"qualites\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"qualites\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (doc + x)->value.inscription[0].moyen_de_com.laqualite, \"qualite\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iQual = 0;\n" \
  "            iInMq = 1;\n" \
  "        }\n" \
  "\n" \
  "        if ((1 == iInMq) || (0 != strcmp((doc + x)->value.intitule.tcIntlAnnot, (doc + y)->value.intitule.tcIntlAnnot)))\n" \
  "        {\n" \
  "            if (1 != iInMq)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"intitulemarques\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            if (0 != strlen((doc + x)->value.intitule.tcIntlAnnot))\n" \
  "            {\n" \
  "                /* Ecriture dans le fichier de sortie */\n" \
  "                iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                /* conversion du XMLType */\n" \
  "                (void)strcpy(GIVBuffInter, (doc + x)->value.intitule.tcIntlAnnot);\n" \
  "                (void)givConvClob();\n" \
  "                giviConflitCRC = GIV::GWCCodeKO;\n" \
  "                iRet = givAnalyseObjetXML(\"I1\", doc + x, GIVBuffInter, &buf_pos);\n" \
  "                /* Ecriture dans le fichier de sortie de l'annotation déjà en UTF8 */\n" \
  "                iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            }\n" \
  "\n" \
  "            iInMq = 0;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitulemarques\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"qualites\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"marquess\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"motsdets\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"cpldenoms\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"prenoms\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"intitule\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    /* intitulés de LO présents dans les données additionnelles de source GC-EN */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" GC-EN ... %s,%s\\n\", (doc + x)->value.inscription[0].val_lslo, givtcObjCont));\n" \
  "\n" \
  "    if (0 != strstr(givtcObjCont, giv_GCEN))\n" \
  "    {\n" \
  "        /* lecture en base de DA GC-EN */\n" \
  "        iRet = givLectureEtabDonSupp(doc->value.a_classer.etab, \"\", giv_GCEN, giv_ADG);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" GC-EN ... %s\\n\", GIVBuffInter));\n" \
  "        iLg = strlen(GIVBuffInter);\n" \
  "\n" \
  "        if (0 != iLg)\n" \
  "        {\n" \
  "            pcDeb = GIVBuffInter;\n" \
  "            strcat(buf_pos, \"<listeLibEnseigneEpj>\");\n" \
  "            lg_write = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_write) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + lg_write + 1) = LINE_FEED;\n" \
  "            *(buf_pos + lg_write + 2) = '\\0';\n" \
  "\n" \
  "            while ((GIVBuffInter + iLg) > pcDeb && (NULL != pcDeb))\n" \
  "            {\n" \
  "                pcDeb = strstr(pcDeb, \"<libelleEnseigne>\");\n" \
  "                pcDeb += strlen(\"<libelleEnseigne>\");\n" \
  "                pcFin = strchr(pcDeb, '<');\n" \
  "                *pcFin = '\\0';\n" \
  "                pcFin++;\n" \
  "                strcat(buf_pos, \"<libEnseigneEpj>\");\n" \
  "                strcat(buf_pos, pcDeb);\n" \
  "                strcat(buf_pos, \"</libEnseigneEpj>\");\n" \
  "                lg_write = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_write) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + lg_write + 1) = LINE_FEED;\n" \
  "                *(buf_pos + lg_write + 2) = '\\0';\n" \
  "                pcDeb = strstr(pcFin, \"<libelleEnseigne>\");\n" \
  "            }\n" \
  "\n" \
  "            strcat(buf_pos, \"</listeLibEnseigneEpj>\");\n" \
  "            lg_write = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_write) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + lg_write + 1) = LINE_FEED;\n" \
  "            *(buf_pos + lg_write + 2) = '\\0';\n" \
  "            lg_write = lg_write + 2;\n" \
  "            buf_pos = (buf_pos + lg_write);\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    doc->cPubPrinc = '5';\n" \
  "    strcpy(rIamic.acNumobj, \"\");\n" \
  "    pipe = 0;\n" \
  "\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        /* ajout produits fictifs partenaires */\n" \
  "        for (x = 0; x < doc[i].value.a_classer.iNbPart; x++)\n" \
  "        {\n" \
  "            if (0 == strlen(doc[i].value.a_classer.trpart[x].prod))\n" \
  "                continue;\n" \
  "\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                strcpy(buf_concat, \"X\");\n" \
  "                strcat(buf_concat, doc[i].value.a_classer.trpart[x].prod);\n" \
  "                pipe = 1;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                strcat(buf_concat, \"|X\");\n" \
  "                strcat(buf_concat, doc[i].value.a_classer.trpart[x].prod);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < givrListObj.iNbr; j++)\n" \
  "    {\n" \
  "        i = givrListObj.trEltListObj[givrListObj.trEltRangListObj[j]].iRgLigne;\n" \
  "        x = givrListObj.trEltListObj[givrListObj.trEltRangListObj[j]].iRgObj;\n" \
  "\n" \
  "        if (0 == givrListObj.trEltListObj[givrListObj.trEltRangListObj[j]].iOrdTri)\n" \
  "        {\n" \
  "            strcpy(ref_pub, (doc + i)->value.objets_pub.micro[x].type);\n" \
  "            strcpy(transforme_stype, (doc + i)->value.objets_pub.micro[x].stype);\n" \
  "\n" \
  "            if (transforme_stype[0] == ' ')\n" \
  "                strcat(ref_pub, &transforme_stype[1]);\n" \
  "            else\n" \
  "                strcat(ref_pub, transforme_stype);\n" \
  "\n" \
  "            if ((0 == strcmp((doc + i)->value.objets_pub.micro[x].stype, \"SC\")) && (0 == strcmp((doc + i)->value.objets_pub.micro[x].sstype, \"PB\")))\n" \
  "            {\n" \
  "                /* SC-PB */\n" \
  "                strcat(ref_pub, (doc + i)->value.objets_pub.micro[x].sstype);\n" \
  "            }\n" \
  "\n" \
  "            if (0 == strlen(buf_concat))\n" \
  "                strcpy(buf_concat, ref_pub);\n" \
  "            else if ((0 == strstr(buf_concat, ref_pub)) || (0 == strcmp((doc + i)->value.objets_pub.micro[x].stype, \"SC\")))\n" \
  "            {\n" \
  "                if ((int4)strlen(buf_concat) >= ((int4)sizeof(buf_concat) - (int4)strlen(ref_pub) - (int4)1))\n" \
  "                {\n" \
  "                    /* espace insuffisant */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne produit dépassée epj : %s\\n\", doc->value.a_classer.etab));\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                strcat(buf_concat, \"|\");\n" \
  "                strcat(buf_concat, ref_pub);\n" \
  "            }\n" \
  "\n" \
  "            if ((0 == strcmp((doc + i)->value.objets_pub.micro[x].stype, \"SC\")) && (0 == strcmp((doc + i)->value.objets_pub.micro[x].sstype, \"PV\")) && (0 == strlen(rIamic.acNumobj)))\n" \
  "            {\n" \
  "                /* SC-PB/SR n'est pas un PVI */\n" \
  "                strcpy(rIamic.acNumobj, (doc + i)->value.objets_pub.micro[x].id);\n" \
  "                doc->cPubPrinc = '1';\n" \
  "            }\n" \
  "            else if ((0 == strcmp(transforme_stype, \" T\")) && ('2' < doc->cPubPrinc))\n" \
  "                doc->cPubPrinc = '2';\n" \
  "            else if ((0 == strcmp(transforme_stype, \"NV\")) && ('3' < doc->cPubPrinc))\n" \
  "                doc->cPubPrinc = '3';\n" \
  "            else if ((0 == strcmp(transforme_stype, \"NT\")) && ('4' < doc->cPubPrinc))\n" \
  "                doc->cPubPrinc = '4';\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (i = 1; i < indice; i++)\n" \
  "        (doc + i)->cPubPrinc = doc->cPubPrinc;\n" \
  "\n" \
  "    iCodRet = supprimer_doublon(buf_concat, '|');\n" \
  "    pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "    for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "    {\n" \
  "        pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "        if (pt_fin == 0)\n" \
  "            pt_fin = pt_fin_lst;\n" \
  "\n" \
  "        /* analyse client */\n" \
  "        memcpy(tcProduit, pt_debut, (pt_fin - pt_debut));\n" \
  "        tcProduit[(pt_fin - pt_debut)] = '\\0';\n" \
  "        lg_write = giv_ecrit_element(buf_pos, \"pjproduit\", tcProduit);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        pt_debut = pt_fin + 1;\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(rIamic.acNumobj))\n" \
  "    {\n" \
  "        iRet = givLectureImag(&rIamic, tcNbimag, tcImagCat, &tcMenu[0]);\n" \
  "        tcMenu[1] = '\\0';\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcNbimag, \"nbimag\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcImagCat, \"imagcat\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcMenu, \"imagmenu\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    /* analyse des produits MA pour UAVS */\n" \
  "    if ((NULL != strstr(buf_concat, givtcMaxAud)) && (0 != strlen(buf_concat)))\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_element(buf_pos, \"rank\", \"2\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    /* analyse des Numéros Fréquemment Demandés 95299999 */\n" \
  "    for (x = 0; (x < givrListParu.iNbr && ((0 != strcmp(givcDepFictif, givrListParu.trEltList[x].dep)) || (0 != strcmp(givcLocFictive, givrListParu.trEltList[x].loc)))); x++)\n" \
  "        ;\n" \
  "\n" \
  "    if (givrListParu.iNbr != x)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_element(buf_pos, \"rank\", \"1\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    iRang = -1;\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        if (iRang != (doc + x)->value.intitule.iRgDnom)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (doc + x)->value.intitule.denomination, \"denomination\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iRang = (doc + x)->value.intitule.iRgDnom;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        for (y = 0; y < x; y++)\n" \
  "        {\n" \
  "            if (0 == strcmp((doc + x)->value.rubriques.mogmoi, (doc + y)->value.rubriques.mogmoi))\n" \
  "                break;\n" \
  "        }\n" \
  "\n" \
  "        if (y == x)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, (doc + x)->value.rubriques.mogmoi, \"mogmoi\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        for (y = 0; y < x; y++)\n" \
  "        {\n" \
  "            if (0 == strcmp((doc + x)->value.rubriques.mpg, (doc + y)->value.rubriques.mpg))\n" \
  "                break;\n" \
  "        }\n" \
  "\n" \
  "        if (y == x)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, (doc + x)->value.rubriques.mpg, \"mpg\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (x = 0; x < indice; x++)\n" \
  "    {\n" \
  "        for (y = 0; y < x; y++)\n" \
  "        {\n" \
  "            if (0 == strcmp((doc + x)->value.rubriques.mendom, (doc + y)->value.rubriques.mendom))\n" \
  "                break;\n" \
  "        }\n" \
  "\n" \
  "        if (y == x)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, (doc + x)->value.rubriques.mendom, \"mendom\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrire_partie_2_1 */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_2_2 ()                                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie deux du bloc de parution simple ou groupe      */\n" \
  "/*             possibilite de boucler si cas de Ig ou groupement              */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_ecrit_partie_2_2(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice, GYBrDOCUMENTEpj* docIG, int4 indmax)\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    int4 lg;\n" \
  "    int4 i, j, k, l, q;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char code_instal[10 + 1];\n" \
  "    char tcPrecision[2 + 1];\n" \
  "    char tcBlocid[27 + 1];\n" \
  "    char datfin[GYBIeinscLgDatmod + 1]; /* date fin */\n" \
  "    char tcDeplocarr[GYBIeinscLgDeppar + GYBIeinscLgLocpar + GYBIeinscLgArrond + 1];\n" \
  "    char tcNb[5 + 1]; /* nb de bon plan */\n" \
  "    int4 iQualite;\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 iRet;\n" \
  "    int4 iAn9, iRef;\n" \
  "    char* pt_fin_liste;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_mil_element;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    char tcElmt[29 + 1]; /* partenaire*/\n" \
  "    GYBrIamicT rIamic;\n" \
  "    GYBrIadresT rIadres; /* adresse étendue */\n" \
  "    GYBrIndIadresT rIndIadres;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    lg_write = giv_ecrit_noeud_inscription(buf_pos, doc, 0);\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* numéro standard */\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, \"STD\", \"TypeNum\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (docIG->value.intitule.iRgPrinc == indice)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.numero_bloc_parution_ref, \"ippal\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    iAn9 = 0;\n" \
  "\n" \
  "    for (i = 0; i < (doc->value.rubriques.iNban9); i++)\n" \
  "    {\n" \
  "        if (0 == strcmp(doc->value.rubriques.Tan9[i].val_codan9, givcR00000000))\n" \
  "        {\n" \
  "            iAn9 = 1;\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (1 == iAn9)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"O\", \"ialpha\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    iAn9 = 0;\n" \
  "\n" \
  "    for (i = 0; i < (doc->value.rubriques.iNban9); i++)\n" \
  "    {\n" \
  "        if (0 != strcmp(doc->value.rubriques.Tan9[i].val_codan9, givcR00000000))\n" \
  "        {\n" \
  "            iAn9 = 1;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, doc->value.rubriques.Tan9[i].val_codan9, \"ian9\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    iAn9 = 0;\n" \
  "\n" \
  "    for (i = 0; i < (doc->value.rubriques.iNban9); i++)\n" \
  "    {\n" \
  "        if (0 != strcmp(doc->value.rubriques.Tan9[i].val_codan9, givcR00000000))\n" \
  "        {\n" \
  "            iAn9 = 1;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, doc->value.rubriques.Tan9[i].val_codan8, \"ian8\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "    pipe = 0;\n" \
  "\n" \
  "    for (i = 0; i < (givrListParu.iNbrTot); i++)\n" \
  "    {\n" \
  "        j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "        if (indice == givrListParu.trEltList[j].iRgLigne && 0 != strlen(givrListParu.trEltList[j].rubinit) && 0 != strcmp(givrListParu.trEltList[j].rubinit, givcR000000))\n" \
  "        {\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                strcpy(buf_concat, givrListParu.trEltList[j].nature);\n" \
  "                pipe = 1;\n" \
  "            }\n" \
  "            else if ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givtcNatureAn8Part)))\n" \
  "            {\n" \
  "                strcat(buf_concat, \"|\");\n" \
  "                strcat(buf_concat, givrListParu.trEltList[j].nature);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" ipjb2b... %s\\n\", buf_concat));\n" \
  "    iRet = supprimer_doublon(buf_concat, '|');\n" \
  "\n" \
  "    if (0 != strlen(buf_concat))\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, buf_concat, \"ipjb2b\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.denomination, \"denomination\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.prenom, \"prenom\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.initiale, \"iprenom\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    for (i = 0; i < indmax; i++)\n" \
  "    {\n" \
  "        for (j = 0; (j < (docIG + i)->value.rubriques.iNban9 && ('0' == (docIG + i)->value.rubriques.Tan9[j].dnex)); j++)\n" \
  "            ;\n" \
  "\n" \
  "        if ((docIG + i)->value.rubriques.iNban9 != j)\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    if ((0 == strcmp(givtcInvDenPn, \"NON\")) || (indmax == i))\n" \
  "    {\n" \
  "        strcpy(buf_concat, doc->value.intitule.denomination);\n" \
  "\n" \
  "        if (0 != strlen(doc->value.intitule.prenom))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.intitule.prenom);\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* inversion de l'ordre le la denomination exacte */\n" \
  "        if (0 != strlen(doc->value.intitule.prenom))\n" \
  "        {\n" \
  "            strcpy(buf_concat, doc->value.intitule.prenom);\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.intitule.denomination);\n" \
  "        }\n" \
  "        else\n" \
  "            strcpy(buf_concat, doc->value.intitule.denomination);\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_balise_iso(buf_pos, buf_concat, \"denomexacte\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.complement_denomination, \"icpldenom\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.inscription[0].moyen_de_com.laqualite, \"iqualite\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "    lg_write = giv_ecrit_noeud(buf_pos, doc->value.inscription[0].adresse.parution, \"adresse\", \"parution\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.numero_voie, \"numvoie\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.instal, \"codloc\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lib_complt_num_voie, \"libcplnumvoie\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (0 != strlen(doc->value.inscription[0].adresse.code_voie))\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.code_voie, \"codvoie\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        memset(buf_concat, 0, strlen(buf_concat));\n" \
  "        strcpy(buf_concat, doc->value.inscription[0].adresse.instal);\n" \
  "        strcat(buf_concat, doc->value.inscription[0].adresse.code_voie);\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, buf_concat, \"pjcoddeplocvoie\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(doc->value.inscription[0].adresse.lib_code_voie))\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lib_code_voie, \"libvoie\");\n" \
  "    else\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.libel_voie, \"libvoie\");\n" \
  "\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.adrnr, \"adrnr\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lieue_ae, \"lieueae\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (((0 == strcmp(GIVtcGeneSSAdr, \"OUI\")) && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])) || (givcParuSSAdr != doc->value.inscription[0].adresse.parution[givcIndParuAdr]))\n" \
  "    {\n" \
  "        memset(buf_concat, 0, strlen(buf_concat));\n" \
  "        pipe = 0;\n" \
  "\n" \
  "        if (0 != strlen(doc->value.rubriques.arract))\n" \
  "        {\n" \
  "            strcpy(buf_concat, doc->value.rubriques.arract);\n" \
  "            pipe = 1;\n" \
  "        }\n" \
  "        else if (0 != strlen(doc->value.inscription[0].adresse.arrondissement))\n" \
  "        {\n" \
  "            strcpy(buf_concat, doc->value.inscription[0].adresse.arrondissement);\n" \
  "            pipe = 1;\n" \
  "        }\n" \
  "\n" \
  "        /* suppression des doubles arrondissement */\n" \
  "        iRet = supprimer_doublon(buf_concat, '|');\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, buf_concat, \"arr\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        buf_concat[0] = '\\0';\n" \
  "        memset(buf_concat, 0, strlen(buf_concat));\n" \
  "        pipe = 0;\n" \
  "\n" \
  "        if (0 != strlen(doc->value.rubriques.arract))\n" \
  "        {\n" \
  "            strcpy(buf_concat, doc->value.rubriques.depact);\n" \
  "            strcat(buf_concat, doc->value.rubriques.locact);\n" \
  "            strcat(buf_concat, doc->value.rubriques.arract);\n" \
  "            pipe = 1;\n" \
  "        }\n" \
  "        else if (0 != strlen(doc->value.inscription[0].adresse.arrondissement))\n" \
  "        {\n" \
  "            strcpy(buf_concat, doc->value.inscription[0].adresse.instal);\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.arrondissement);\n" \
  "            pipe = 1;\n" \
  "        }\n" \
  "\n" \
  "        /* suppression des doubles arrondissement */\n" \
  "        iRet = supprimer_doublon(buf_concat, '|');\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, buf_concat, \"arrinst\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    pipe = 0;\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        l = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (((int4)GIV::GIXCodeKO == givrListParu.trEltList[l].iLF) && (99 != givrListParu.trEltList[l].iGeoArr))\n" \
  "        {\n" \
  "            strcpy(tcDeplocarr, givrListParu.trEltList[l].dep);\n" \
  "            strcat(tcDeplocarr, givrListParu.trEltList[l].loc);\n" \
  "            strcat(tcDeplocarr, givrListParu.trEltList[l].arr);\n" \
  "\n" \
  "            if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)))\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                strcpy(buf_concat, tcDeplocarr);\n" \
  "                pipe = 1;\n" \
  "            }\n" \
  "            else if (0 == strstr(buf_concat, tcDeplocarr))\n" \
  "            {\n" \
  "                strcat(buf_concat, \"|\");\n" \
  "                strcat(buf_concat, tcDeplocarr);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* suppression des doubles arrondissement */\n" \
  "    iRet = supprimer_doublon(buf_concat, '|');\n" \
  "\n" \
  "    if (0 != strlen(buf_concat))\n" \
  "    {\n" \
  "        pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "        for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            /* analyse rub */\n" \
  "            memcpy(code_instal, pt_debut, (pt_fin - pt_debut));\n" \
  "            code_instal[(pt_fin - pt_debut)] = '\\0';\n" \
  "            lg_write = giv_ecrit_element(buf_pos, \"arrpar\", code_instal);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.libinstal, \"libloc\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.libinstact, \"liblocact\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    iRet = givLectureLibLocAtt(&buf_pos, doc->value.inscription[0].adresse.instal, doc->value.a_classer.etab);\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.code_postal, \"cp\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.code_cedex, \"cedex\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.lib_cedex, \"libcedex\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.boite, \"bp\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.ipays, \"ipays\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.ensemble_batiment, \"bat\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    i = 0;\n" \
  "\n" \
  "    if ((givcParuSSAdr != doc->value.intitule.parution[givcIndParuAdr]) || ((0 == strcmp(GIVtcGeneSSAdr, \"OUI\")) && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])))\n" \
  "    {\n" \
  "        /* Adresse étendue */\n" \
  "        (void)strcpy(rIadres.acNumnat, doc->value.inscription[0].val_num);\n" \
  "        (void)strcpy(rIadres.acNumlo, doc->value.inscription[0].val_lo);\n" \
  "        (void)strcpy(rIadres.acNumls, doc->value.inscription[0].val_ls);\n" \
  "        iRet = GIVLectureLectureIADRES(&rIadres, &rIndIadres);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iRet)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acCodReg, \"coderegion\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acLibDep, \"libdep\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acLibReg, \"libregion\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acTypVoiEtendu, \"typevoieetendu\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acLibVoiEtendu, \"libvoietendu\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acLigne2Etendu, \"ligne2Etendu\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acLigne3Etendu, \"ligne3Etendu\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, rIadres.acLigne5Etendu, \"ligne5Etendu\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        strcat(buf_concat, doc->value.inscription[0].adresse.ensemble_batiment);\n" \
  "\n" \
  "        if (givcParuSSNoParu != doc->value.intitule.parution[givcIndParuNoParu])\n" \
  "        {\n" \
  "            if (0 != strlen(doc->value.inscription[0].adresse.numero_voie))\n" \
  "            {\n" \
  "                strcat(buf_concat, \" \");\n" \
  "                strcat(buf_concat, doc->value.inscription[0].adresse.numero_voie);\n" \
  "            }\n" \
  "\n" \
  "            if (0 != strlen(doc->value.inscription[0].adresse.lib_complt_num_voie))\n" \
  "            {\n" \
  "                strcat(buf_concat, \" \");\n" \
  "                strcat(buf_concat, doc->value.inscription[0].adresse.lib_complt_num_voie);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 != strlen(doc->value.inscription[0].adresse.lib_code_voie))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.lib_code_voie);\n" \
  "        }\n" \
  "        else if (0 != strlen(doc->value.inscription[0].adresse.libel_voie))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.libel_voie);\n" \
  "        }\n" \
  "        else if (0 != strlen(doc->value.inscription[0].adresse.adrnr))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.adrnr);\n" \
  "        }\n" \
  "\n" \
  "        if (0 != strlen(doc->value.inscription[0].adresse.lieue_ae))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.lieue_ae);\n" \
  "        }\n" \
  "\n" \
  "        if (0 != strlen(doc->value.inscription[0].adresse.boite))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" BP \");\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.boite);\n" \
  "        }\n" \
  "\n" \
  "        if (0 != strlen(doc->value.inscription[0].adresse.code_cedex))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.code_cedex);\n" \
  "        }\n" \
  "        else if (0 != strlen(doc->value.inscription[0].adresse.code_postal))\n" \
  "        {\n" \
  "            if ((0 == strcmp(doc->value.inscription[0].val_ls, \"0000\")) || ((0 == strcmp(GIVtcGeneCP, \"OUI\")) && (0 != strcmp(doc->value.inscription[0].val_ls, \"0000\"))))\n" \
  "            {\n" \
  "                strcat(buf_concat, \" \");\n" \
  "                strcat(buf_concat, doc->value.inscription[0].adresse.code_postal);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 == strcmp(doc->value.inscription[0].val_ls, \"0000\"))\n" \
  "        {\n" \
  "            if (0 != strlen(doc->value.inscription[0].adresse.lib_cedex))\n" \
  "            {\n" \
  "                strcat(buf_concat, \" \");\n" \
  "                strcat(buf_concat, doc->value.inscription[0].adresse.lib_cedex);\n" \
  "            }\n" \
  "            else if (0 != strlen(doc->value.inscription[0].adresse.libinstal))\n" \
  "            {\n" \
  "                strcat(buf_concat, \" \");\n" \
  "                strcat(buf_concat, doc->value.inscription[0].adresse.libinstal);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (((0 != strlen(doc->value.inscription[0].adresse.lib_code_voie)) || (0 != strlen(doc->value.inscription[0].adresse.libel_voie))) && (0 != strlen(doc->value.inscription[0].adresse.adrnr))\n" \
  "                && (0 != strcmp(doc->value.inscription[0].val_ls, \"0000\")))\n" \
  "        {\n" \
  "            strcat(buf_concat, \" \");\n" \
  "            strcat(buf_concat, doc->value.inscription[0].adresse.adrnr);\n" \
  "        }\n" \
  "\n" \
  "        for (i = 0; (i < strlen(buf_concat) && ' ' == buf_concat[i]); i++)\n" \
  "            ;\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, &buf_concat[i], \"adressekm\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"geoloc\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (((0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision, \"00\")) || (0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision, \"04\"))\n" \
  "            || (0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision, \"99\")) || (0 == strcmp(doc->value.inscription[0].adresse.geoloc.precision, \"97\")\n" \
  "                    && givcParuAdr == doc->value.intitule.parution[givcIndParuAdr])) && (0 == strcmp(doc->value.inscription[0].adresse.centreloc.precision, \"0\")))\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[0].adresse.geoloc.precision, \"00\");\n" \
  "        strcpy(doc->value.inscription[0].adresse.geoloc.longitude, doc->value.inscription[0].adresse.centreloc.longitude);\n" \
  "        strcpy(doc->value.inscription[0].adresse.geoloc.latitude, doc->value.inscription[0].adresse.centreloc.latitude);\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.longitude, \"long\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.latitude, \"lat\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.centreloc.precision, \"prcnt\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.centreloc.longitude, \"longcnt\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.centreloc.latitude, \"latcnt\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    iQualite = atoi(doc->value.inscription[0].adresse.geoloc.precision);\n" \
  "\n" \
  "    if (50 == iQualite)\n" \
  "    {\n" \
  "        /* précision forçée au centre de la localité */\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"1\", \"forccnt\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        iQualite = 0;\n" \
  "        strcpy(doc->value.inscription[0].adresse.geoloc.precision, \"00\");\n" \
  "    }\n" \
  "    else if (51 == iQualite)\n" \
  "    {\n" \
  "        /* précision indiquant une inversion longitude et latitude */\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"1\", \"forccnt\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        iQualite = 3;\n" \
  "        strcpy(doc->value.inscription[0].adresse.geoloc.precision, \"03\");\n" \
  "    }\n" \
  "\n" \
  "    doc->iDblGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "    if (GIV::giv_LOC == doc->iGeoLoc)\n" \
  "    {\n" \
  "        /* inscription locale ou avec un double local */\n" \
  "        doc->iDblGeoLoc = GIV::giv_LOC;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"test extraloc doc : %d\\n\", doc->iDblGeoLoc));\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        for (j = 0; j < givrListParu.iNbrTot; j++)\n" \
  "        {\n" \
  "            q = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "            if (GIV::giv_LOC == givrListParu.trEltList[q].iGeoLoc)\n" \
  "            {\n" \
  "                /* inscription locale via les autres parutions */\n" \
  "                doc->iDblGeoLoc = GIV::giv_LOC;\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"test extraloc dbl : %d\\n\", doc->iDblGeoLoc));\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"test extraloc: %d,%d\\n\", doc->iDblGeoLoc, iAn9));\n" \
  "\n" \
  "    switch (iQualite)\n" \
  "    {\n" \
  "    case 97:\n" \
  "    case 99:\n" \
  "        break;\n" \
  "\n" \
  "    case 96:\n" \
  "    case 98:\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"04\", \"precision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"1\", \"srcprecision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        break;\n" \
  "\n" \
  "    default:\n" \
  "        iQualite = iQualite % 4;\n" \
  "        (void)sprintf(&tcPrecision[0], \"%02d\", iQualite);\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcPrecision, \"precision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        if (GIV::giv_LOC == doc->iDblGeoLoc)\n" \
  "        {\n" \
  "            if ((0 != strlen(doc->value.a_classer.etab)) && (0 == strcmp(doc->value.inscription[0].val_ls, \"0000\")) && (0 != iAn9))\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Extra Loc IO %s,%s,%s,%s\\n\", doc->value.a_classer.etab, doc->value.inscription[0].val_num, doc->value.inscription[0].val_lo, doc->value.inscription[0].val_ls));\n" \
  "                iRet = givExtraLocIO(doc);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iRet)\n" \
  "                {\n" \
  "                    /* existence d'autre locale pour IO locale */\n" \
  "                    lg_write = giv_ecrit_balise(buf_pos, tcPrecision, \"prloc\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_balise(buf_pos, tcPrecision, \"prloc\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != strlen(doc->value.a_classer.etab)) && (GIV::giv_LOC != doc->iDblGeoLoc) && (0 != iAn9))\n" \
  "        {\n" \
  "            buf_concat[0] = '\\0';\n" \
  "\n" \
  "            for (i = 0; i < (givrListParu.iNbrTot); i++)\n" \
  "            {\n" \
  "                j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                if (indice == givrListParu.trEltList[j].iRgLigne && 0 != strlen(givrListParu.trEltList[j].rubinit) &&\n" \
  "                        NULL == strstr(buf_concat, givrListParu.trEltList[j].rubinit))\n" \
  "                {\n" \
  "                    iRet = givExtraLocIS(doc->value.a_classer.etab, givrListParu.trEltList[j].rubinit);\n" \
  "\n" \
  "                    if ((int4)GIV::GIXCodeOK != iRet)\n" \
  "                    {\n" \
  "                        /* absence de locale pour IS/IO non locale */\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Extra Loc IS %s,%s\\n\", doc->value.a_classer.etab, givrListParu.trEltList[j].rubinit));\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (0 == strlen(buf_concat))\n" \
  "                        strcpy(buf_concat, givrListParu.trEltList[j].rubinit);\n" \
  "                    else\n" \
  "                    {\n" \
  "                        strcat(buf_concat, \"|\");\n" \
  "                        strcat(buf_concat, givrListParu.trEltList[j].rubinit);\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if (i != givrListParu.iNbrTot)\n" \
  "            {\n" \
  "                /* absence de locale pour un an8 */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Prloc IS... %s\\n\", givrListParu.trEltList[j].rubinit));\n" \
  "                lg_write = giv_ecrit_balise(buf_pos, tcPrecision, \"prloc\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        iQualite = atoi(doc->value.inscription[0].adresse.geoloc.precision);\n" \
  "        iQualite = iQualite / 4;\n" \
  "        (void)sprintf(&tcPrecision[0], \"%d\", iQualite);\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, tcPrecision, \"srcprecision\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        break;\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.precMappy, \"precisionMappy\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (0 != strlen(doc->value.inscription[0].adresse.geoloc.longitude))\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"carte\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.numero_bloc_parution, \"ctebloc\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "        lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.intitule.denomination, \"ctedenom\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.longitude, \"ctelong\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].adresse.geoloc.latitude, \"ctelat\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"carte\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"geoloc\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* Fin de l'entité adresse */\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"adresse\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    /* Entête pour moyen de communication */\n" \
  "    if (('0' != doc->cIndPart) && (0 == strlen(doc->value.inscription[0].moyen_de_com.numero_parution)))\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"moycom/\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"moycom\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "        lg_write = giv_ecrit_balise_iso(buf_pos, doc->value.inscription[0].moyen_de_com.designation_ligne, \"desligne\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        if ('\\0' != GIVBuffXML[0])\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero, \"num\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        switch (doc->value.intitule.protection[0])\n" \
  "        {\n" \
  "        case '1':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"rouge\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case '2':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"orange\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case '3':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"rouge|orange\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case '4':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"safran\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case '5':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"rouge|safran\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case '6':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"orange|safran\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case '7':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"rouge|orange|safran\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case 'A':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"noninverse\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case 'B':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"orange|noninverse\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case 'C':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"safran|noninverse\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        case 'D':\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"orange|safran|noninverse\", \"protection\");\n" \
  "            break;\n" \
  "\n" \
  "        default:\n" \
  "            lg_write = 0;\n" \
  "            break;\n" \
  "        }\n" \
  "\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        switch (doc->value.intitule.support[0])\n" \
  "        {\n" \
  "        case givcSuppCham:\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"chamois\", \"support\");\n" \
  "            break;\n" \
  "\n" \
  "        default:\n" \
  "            lg_write = 0;\n" \
  "            break;\n" \
  "        }\n" \
  "\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution, \"numpar\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        j = 0;\n" \
  "        iRef = -1;\n" \
  "\n" \
  "        if (0 != strlen(doc->value.inscription[0].moyen_de_com.numero_parution))\n" \
  "        {\n" \
  "            for (i = 0; i < strlen(doc->value.inscription[0].moyen_de_com.numero_parution); i++)\n" \
  "            {\n" \
  "                if (' ' == doc->value.inscription[0].moyen_de_com.numero_parution[i])\n" \
  "                    iRef = i;\n" \
  "                else if ((iRef + 1 == i) && (-1 != iRef) && (0 == isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[i])) && (0 != isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[0])))\n" \
  "                {\n" \
  "                    doc->value.inscription[0].moyen_de_com.numero_parution[iRef] = '\\0';\n" \
  "                    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution, \"numpartel\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    doc->value.inscription[0].moyen_de_com.numero_parution[iRef] = ' ';\n" \
  "                    lg_write = giv_ecrit_balise(buf_pos, &doc->value.inscription[0].moyen_de_com.numero_parution[iRef + 1], \"numparmagique\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    break;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if (strlen(doc->value.inscription[0].moyen_de_com.numero_parution) == i)\n" \
  "            {\n" \
  "                if (0 != isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[0]))\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution, \"numpartel\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.numero_parution, \"numparmagique\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        j = 0;\n" \
  "\n" \
  "        if (0 != strlen(doc->value.inscription[0].moyen_de_com.numero_parution))\n" \
  "        {\n" \
  "            for (i = 0; i < strlen(doc->value.inscription[0].moyen_de_com.numero_parution); i++)\n" \
  "            {\n" \
  "                if (0 != isdigit(doc->value.inscription[0].moyen_de_com.numero_parution[i]))\n" \
  "                {\n" \
  "                    buf_concat[j] = doc->value.inscription[0].moyen_de_com.numero_parution[i];\n" \
  "                    j++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            for (i = 0; i < strlen(doc->value.inscription[0].moyen_de_com.numero); i++)\n" \
  "            {\n" \
  "                if (0 != isdigit(doc->value.inscription[0].moyen_de_com.numero[i]))\n" \
  "                {\n" \
  "                    buf_concat[j] = doc->value.inscription[0].moyen_de_com.numero[i];\n" \
  "                    j++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        buf_concat[j] = '\\0';\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, buf_concat, \"numinverse\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.code_produit, \"codpro\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.code_produit_etd, \"codproetendu\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.catnum, \"catnumero\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        if ((NULL != strstr(doc->value.inscription[0].moyen_de_com.code_produit, givtcAnMes)) && (0 != strlen(doc->value.inscription[0].moyen_de_com.code_produit)))\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"AM\", \"indic\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.equiptel, \"equiptel\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.servtel, \"servtel\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.tarifart, \"tarifart\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.operateur, \"operateur\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.email, \"email\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.mnemonique, \"mnemonique\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "        /* conversion spécifique euro pour mention tarifaire */\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.tarif_exact, \"tarif\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Conversion du buffer avant écriture dans le fichier */\n" \
  "        givTradChar(&lg_write);\n" \
  "        /* Conversion euro */\n" \
  "        memcpy(GIVBuffInter, GIVBuffXML, strlen(GIVBuffXML));\n" \
  "        gwtRemplaceChaine(GIVBuffInter, GXW_cg_Euro, GXW_utf8_Euro, GIVBuffXML);\n" \
  "        /* écriture dans le fichier */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        /* Fin de l'entité moyen_de_communication */\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"moycom\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(doc->value.inscription[0].moyen_de_com.cteutil))\n" \
  "    {\n" \
  "        /* Entête pour cu */\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"cu\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.cteutil, \"idutil\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.datcu, \"cudate\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.nomsupplement, \"nomsf\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.msknum, \"indmasknum\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, doc->value.inscription[0].moyen_de_com.mskmel, \"indmaskemail\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Fin de l'entité compte utilisateur */\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"cu\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrire_partie_2_2 */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_2_3 ()                                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie deux du bloc de parution simple ou groupe      */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_ecrit_partie_2_3(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos, *buf_pos_ref, *buf_pos_cur;\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_tp, i, k, kk;\n" \
  "    int4 iDebut, iCVI;\n" \
  "    int4 iRang, iObj;\n" \
  "    int4 iRgLigne, iRgObj;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Entree partie 2_3 nb MICRO : ... %d\\n\", nb_micro));\n" \
  "    /* Fin de l'entité inscriptions */\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"inscriptions\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    (void)strcpy(givcTriPub, \"1\");\n" \
  "    iIntRet = giv_ecrit_noeud_objets_pub(&buf_pos, doc, indice, givcTriPub);\n" \
  "    iIntRet = giv_ecrit_noeud_objets_pvi(&buf_pos, doc, indice);\n" \
  "    iDebut = 1;\n" \
  "    /* lecture et ecriture des liens vers les produits à l'epj */\n" \
  "    iCodRet = givLectureLiensEtab(doc, &buf_pos, &iDebut, indice);\n" \
  "\n" \
  "    if (0 == iDebut)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"elementsproduits\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"contenus\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        buf_pos_ref = buf_pos;\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"urls\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        buf_pos_cur = buf_pos;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, (doc + i)->value.inscription[0].moyen_de_com.indrg, \"indrg\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, (doc + i)->value.inscription[0].moyen_de_com.numrg, \"numrg\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, (doc + i)->value.inscription[0].moyen_de_com.url, \"url\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "        if (0 != strlen((doc + i)->value.inscription[0].moyen_de_com.url))\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"lvs\", \"typ_url\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        if (buf_pos_cur != buf_pos)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"urls\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            buf_pos = buf_pos_ref;\n" \
  "            *buf_pos = '\\0';\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* analyse video d'un PVI */\n" \
  "    iRang = -1;\n" \
  "    iRgLigne = -1;\n" \
  "\n" \
  "    for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "    {\n" \
  "        k = givrListObj.trEltRangListObj[i];\n" \
  "        kk = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "        iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "        if (iRang != givrListObj.trEltListObj[k].iRangTri)\n" \
  "        {\n" \
  "            iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "\n" \
  "            if (((doc + kk)->value.objets_pub.micro[iObj].type[0] == 'X') && (0 != strlen((doc + kk)->value.objets_pub.micro[iObj].tcdatact))\n" \
  "                    && ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"VI\")) || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"FI\"))\n" \
  "                        || (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"IN\"))))\n" \
  "            {\n" \
  "                if (-1 == iRgLigne)\n" \
  "                {\n" \
  "                    iRgLigne = kk;\n" \
  "                    iRgObj = iObj;\n" \
  "                }\n" \
  "                else if (0 < strcmp((doc + kk)->value.objets_pub.micro[iObj].tcdatact, (doc + iRgLigne)->value.objets_pub.micro[iRgObj].tcdatact))\n" \
  "                {\n" \
  "                    iRgLigne = kk;\n" \
  "                    iRgObj = iObj;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (-1 != iRgLigne)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, (doc + iRgLigne)->value.objets_pub.micro[iRgObj].tcdatact, \"dmajvideo\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    iIntRet = giv_ecrit_noeud_objets_url(&buf_pos, doc, indice);\n" \
  "\n" \
  "    if (0 != strlen(doc->value.objets_pub.libUrlSite))\n" \
  "    {\n" \
  "        for (i = 1; i < indice; i++)\n" \
  "            strcpy((doc + i)->value.objets_pub.libUrlSite, doc->value.objets_pub.libUrlSite);\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "        iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"contenus\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie partie 2_3 nb MICRO : ... %d\\n\", nb_micro));\n" \
  "\n" \
  "    if (0 == strcmp(\"OUI\", givtcContenu))\n" \
  "    {\n" \
  "        if (0 == strcmp(givtcRapED, \"ETAB\"))\n" \
  "            iCodRet = givAnalyseContenu(&buf_pos, doc, indice);\n" \
  "        else if (0 == strcmp(givtcRapED, \"OUI\"))\n" \
  "        {\n" \
  "            /* table des contenus prioritaires inutilisée */\n" \
  "            giviConflitCRC = GIV::GWCCodeKO;\n" \
  "            iCVI = GIV::GIXCodeKO;\n" \
  "            iCodRet = givEcritContenu(\"\", &buf_pos, doc, indice, &iCVI);\n" \
  "            iCodRet = givEcritContenuED(&buf_pos, doc, indice);\n" \
  "        }\n" \
  "\n" \
  "        /* enrichissements par le partenaire */\n" \
  "        iCodRet = givEcritPart(&buf_pos, doc, indice);\n" \
  "        /* données \"réseaux-relais-colis\" */\n" \
  "        iCodRet = givEcritDonRelais(&buf_pos, doc, 0, indice);\n" \
  "        /* données enrichies */\n" \
  "        iCodRet = givEcritDonEnr(&buf_pos, doc, indice);\n" \
  "        /* données additionnelles */\n" \
  "        iCodRet = givEcritDonAdd(\"DA\", &buf_pos, doc, indice);\n" \
  "        /* mutualisation des données des partenaires */\n" \
  "        iCodRet = givMutualiserDonPartenaires(&buf_pos, doc, indice);\n" \
  "        /* données horaires payantes et gratuites */\n" \
  "        iCodRet = givEcritDonHoraires(&buf_pos, doc, indice);\n" \
  "        /* lecture et ecriture des Photos de l'epj */\n" \
  "        iDebut = 1;\n" \
  "        iCodRet = givLecturePhotosEtab(doc, &buf_pos, &iDebut);\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"affugc\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        iDebut = 1;\n" \
  "        /* lecture et ecriture des liens vzers site issus de SEO */\n" \
  "        iCodRet = givLectureLvsSeoEtab(doc, &buf_pos, &iDebut);\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"lvsparts\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        /* analyse des CRC (balises <normale>) par epj */\n" \
  "        iCodRet = givAffCRCEtab(&buf_pos);\n" \
  "    }\n" \
  "    else if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrit partie_2_3  */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_30       ()                                   */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie trois spécifique du tri                        */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 giv_ecrit_partie_30(char** buf_pos_in, int4 iRg, int4 iTri)\n" \
  "{\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 i, j, k, l, jj, ll;\n" \
  "    int4 z, zz;\n" \
  "    int4 jRef, jRefObj;\n" \
  "    int4 iNbGeoRub;\n" \
  "    int4 iAlpha, iPV;\n" \
  "    int4 iDoc, iObj;\n" \
  "    char tcElemt[19];\n" \
  "    char tcStype[3], tcStypcvi[3];\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    j = 0;\n" \
  "    jRef = -1;\n" \
  "    jRefObj = -1;\n" \
  "    iAlpha = -1;\n" \
  "    l = givrListParu.trEltRangList[j];\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"RgTriDbl: %d\\n\", iRg));\n" \
  "\n" \
  "    while (j < givrListParu.iNbr)\n" \
  "    {\n" \
  "        if (iRg == givrListParu.trEltList[l].iRgTriDbl)\n" \
  "        {\n" \
  "            if (-1 == jRef)\n" \
  "            {\n" \
  "                if (GIV::giv_RUB == iTri)\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, \"parutionrubriques\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "                    pipe = 0;\n" \
  "                }\n" \
  "                else if (GIV::giv_DNOM == iTri)\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, \"parutiondenoms\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, \"parutionobjets\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            jRef = j;\n" \
  "\n" \
  "            if (GIV::giv_DNOM == iTri)\n" \
  "            {\n" \
  "                lg_write = 0;\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeKO != givrListParu.trEltList[l].iRgLigne)\n" \
  "                    lg_write = giv_ecrit_balise_iso(buf_pos, (doc2 + givrListParu.trEltList[l].iRgLigne)->value.intitule.denomination, \"denom\");\n" \
  "            }\n" \
  "            else if (GIV::giv_OBJ == iTri)\n" \
  "            {\n" \
  "                iDoc = givrListParu.trEltList[l].iRgLigne;\n" \
  "                iObj = givrListParu.trEltList[l].iRgObj;\n" \
  "                giv_ecrit_objet_pub(&buf_pos, doc2, iDoc, iObj, \"objetpub\");\n" \
  "\n" \
  "                if (((0 == strcmp(\"SC\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype)) && (0 != strcmp(\"PB\", (doc2 + iDoc)->value.objets_pub.micro[iObj].sstype)))\n" \
  "                        || ((0 != strlen((doc2 + iDoc)->value.objets_pub.micro[iObj].stypcvi)) && (0 != strcmp(\"MO\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype))))\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"iDoc,iObj : %d, %d, %s\\n\", iDoc, iObj, (doc2 + iDoc)->value.objets_pub.micro[iObj].id));\n" \
  "                    pipe = 0;\n" \
  "                    iPV = -1;\n" \
  "                    jRefObj = 0;\n" \
  "                    /* sous-sous-type pour lien PV ou SR */\n" \
  "                    strcpy(tcStype, (doc2 + iDoc)->value.objets_pub.micro[iObj].sstype);\n" \
  "                    strcpy(tcStypcvi, (doc2 + iDoc)->value.objets_pub.micro[iObj].stypcvi);\n" \
  "\n" \
  "                    while (jRefObj < givrListParu.iNbrTot)\n" \
  "                    {\n" \
  "                        if (givrListParu.trEltList[l].iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[jRefObj]].iRangTri)\n" \
  "                        {\n" \
  "                            jRefObj++;\n" \
  "                            continue;\n" \
  "                        }\n" \
  "\n" \
  "                        jj = 0;\n" \
  "\n" \
  "                        while (jj < givrListParu.iNbrTot)\n" \
  "                        {\n" \
  "                            ll = givrListParu.trEltRangList[jj];\n" \
  "\n" \
  "                            if (givrListParu.trEltList[ll].iRgLigne == givrListParu.trEltList[givrListParu.trEltRangList[jRefObj]].iRgLigne)\n" \
  "                            {\n" \
  "                                iDoc = givrListParu.trEltList[ll].iRgLigne;\n" \
  "                                iObj = givrListParu.trEltList[ll].iRgObj;\n" \
  "                                GWTTrace(GWT_NIV_FONCT, (\"iDoc,iObj : %d, %d, %s, %s, %s\\n\", iDoc, iObj, (doc2 + iDoc)->value.objets_pub.micro[iObj].stype, (doc2 + iDoc)->value.objets_pub.micro[iObj].sstype,\n" \
  "                                                         (doc2 + iDoc)->value.objets_pub.micro[iObj].id));\n" \
  "\n" \
  "                                if (((0 == strcmp(tcStype, (doc2 + iDoc)->value.objets_pub.micro[iObj].sstype)) && ((0 == strcmp(\"FI\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype))\n" \
  "                                        || (0 == strcmp(\"VI\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype)) || (0 == strcmp(\"IN\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype))\n" \
  "                                        || (0 == strcmp(\"OB\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype)) || (0 == strcmp(\"CP\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype))))\n" \
  "                                        || ((0 == strcmp(tcStypcvi, (doc2 + iDoc)->value.objets_pub.micro[iObj].stypcvi)) && (0 == strcmp(\"MO\", (doc2 + iDoc)->value.objets_pub.micro[iObj].stype))))\n" \
  "                                {\n" \
  "                                    GWTTrace(GWT_NIV_FONCT, (\"objet lié/pub : %d\\n\", iPV));\n" \
  "\n" \
  "                                    if (-1 == iPV)\n" \
  "                                    {\n" \
  "                                        iPV = 0;\n" \
  "                                        lg_write = giv_ecrit_noeud_simple(buf_pos, \"objetsLies\");\n" \
  "                                        buf_pos = buf_pos + lg_write;\n" \
  "                                    }\n" \
  "\n" \
  "                                    strcpy(tcElemt, (doc2 + iDoc)->value.objets_pub.micro[iObj].stype);\n" \
  "                                    strcat(tcElemt, (doc2 + iDoc)->value.objets_pub.micro[iObj].id);\n" \
  "\n" \
  "                                    if (pipe == 0)\n" \
  "                                    {\n" \
  "                                        giv_ecrit_objet_pub(&buf_pos, doc2, iDoc, iObj, \"objetpub\");\n" \
  "                                        strcpy(buf_concat, tcElemt);\n" \
  "                                        pipe = 1;\n" \
  "                                    }\n" \
  "                                    else if (0 == strstr(buf_concat, tcElemt))\n" \
  "                                    {\n" \
  "                                        giv_ecrit_objet_pub(&buf_pos, doc2, iDoc, iObj, \"objetpub\");\n" \
  "                                        strcat(buf_concat, \"|\");\n" \
  "                                        strcat(buf_concat, tcElemt);\n" \
  "                                    }\n" \
  "                                }\n" \
  "                            }\n" \
  "\n" \
  "                            jj++;\n" \
  "                        }\n" \
  "\n" \
  "                        jRefObj++;\n" \
  "                    }\n" \
  "\n" \
  "                    if (0 == iPV)\n" \
  "                    {\n" \
  "                        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"objetsLies\");\n" \
  "                        buf_pos = buf_pos + lg_write;\n" \
  "                    }\n" \
  "\n" \
  "                    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"objetpub\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "\n" \
  "                lg_write = 0;\n" \
  "            }\n" \
  "            else if (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000))\n" \
  "            {\n" \
  "                /* recherche en priorité d'une rubrique d'origine autre que complémentaire */\n" \
  "                for (k = 0; (k < givrListParu.trEltList[l].iNbGeoTri && (('4' == givrListParu.trEltList[givrListParu.trEltRangList[j + k]].orig)\n" \
  "                             || ('6' == givrListParu.trEltList[givrListParu.trEltRangList[j + k]].orig) || ('7' == givrListParu.trEltList[givrListParu.trEltRangList[j + k]].orig))); k++)\n" \
  "                    ;\n" \
  "\n" \
  "                if (givrListParu.trEltList[l].iNbGeoTri == k)\n" \
  "                {\n" \
  "                    if (pipe == 0)\n" \
  "                    {\n" \
  "                        strcpy(buf_concat, givrListParu.trEltList[l].nature);\n" \
  "                        pipe = 1;\n" \
  "                    }\n" \
  "                    else if ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givrListParu.trEltList[l].nature) - (int4)1))\n" \
  "                    {\n" \
  "                        strcat(buf_concat, \"|\");\n" \
  "                        strcat(buf_concat, givrListParu.trEltList[l].nature);\n" \
  "                    }\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    if (pipe == 0)\n" \
  "                    {\n" \
  "                        strcpy(buf_concat, givrListParu.trEltList[l].nature);\n" \
  "                        pipe = 1;\n" \
  "                    }\n" \
  "                    else if ((int4)strlen(buf_concat) < ((int4)sizeof(buf_concat) - (int4)strlen(givrListParu.trEltList[l].nature) - (int4)1))\n" \
  "                    {\n" \
  "                        strcat(buf_concat, \"|\");\n" \
  "                        strcat(buf_concat, givrListParu.trEltList[l].nature);\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                lg_write = 0;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                lg_write = 0;\n" \
  "                iAlpha = j;\n" \
  "            }\n" \
  "\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        iNbGeoRub = givrListParu.trEltList[l].iNbGeoTri;\n" \
  "        j = j + iNbGeoRub;\n" \
  "\n" \
  "        if (j < givrListParu.iNbr)\n" \
  "            l = givrListParu.trEltRangList[j];\n" \
  "    }\n" \
  "\n" \
  "    if ((GIV::giv_RUB == iTri) && (-1 != jRef))\n" \
  "    {\n" \
  "        iIntRet = supprimer_doublon(buf_concat, '|');\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, buf_concat, \"pjb2b\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        j = 0;\n" \
  "        jRef = -1;\n" \
  "        iAlpha = -1;\n" \
  "        l = givrListParu.trEltRangList[j];\n" \
  "        memset(buf_concat, 0, strlen(buf_concat));\n" \
  "        pipe = 0;\n" \
  "\n" \
  "        while (j < givrListParu.iNbr)\n" \
  "        {\n" \
  "            if (iRg == givrListParu.trEltList[l].iRgTriDbl)\n" \
  "            {\n" \
  "                jRef = j;\n" \
  "\n" \
  "                if (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000))\n" \
  "                {\n" \
  "                    /* recherche de la parution santé */\n" \
  "                    z = givrListParu.trEltList[l].iRgLigne;\n" \
  "\n" \
  "                    for (zz = 0; (zz < (doc2 + z)->value.rubriques.iNban9 && (0 != strcmp(givrListParu.trEltList[l].rub, (doc2 + z)->value.rubriques.Tan9[zz].val_codan9))); zz++)\n" \
  "                        ;\n" \
  "\n" \
  "                    /* recherche en priorité d'une rubrique d'origine autre que complémentaire */\n" \
  "                    for (k = 0; (k < givrListParu.trEltList[l].iNbGeoTri && (('4' == givrListParu.trEltList[givrListParu.trEltRangList[j + k]].orig)\n" \
  "                                 || ('6' == givrListParu.trEltList[givrListParu.trEltRangList[j + k]].orig) || ('7' == givrListParu.trEltList[givrListParu.trEltRangList[j + k]].orig))); k++)\n" \
  "                        ;\n" \
  "\n" \
  "                    if (givrListParu.trEltList[l].iNbGeoTri == k)\n" \
  "                        lg_write = giv_ecrit_noeud_rubriques(buf_pos, givrListParu.trEltList[l].rubinit, givrListParu.trEltList[l].rub, givrListParu.trEltList[l].orig, std::string((doc2 + z)->value.rubriques.Tan9[zz].thematique));\n" \
  "                    else\n" \
  "                        lg_write = giv_ecrit_noeud_rubriques(buf_pos, givrListParu.trEltList[l].rubinit, givrListParu.trEltList[l].rub, givrListParu.trEltList[givrListParu.trEltRangList[j + k]].orig, std::string((doc2 + z)->value.rubriques.Tan9[zz].thematique));\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    lg_write = 0;\n" \
  "                    iAlpha = j;\n" \
  "                }\n" \
  "\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            iNbGeoRub = givrListParu.trEltList[l].iNbGeoTri;\n" \
  "            j = j + iNbGeoRub;\n" \
  "\n" \
  "            if (j < givrListParu.iNbr)\n" \
  "                l = givrListParu.trEltRangList[j];\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    j = jRef;\n" \
  "\n" \
  "    if (-1 != iAlpha)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"O\", \"alpha\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (j);\n" \
  "} /* Fin ecrit partie_30  */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_3_geo   ()                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie trois par géographie selon le tri              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 giv_ecrit_partie_3_geo(char** buf_pos_in, GYBrDOCUMENTEpj* docClone, int4 iInit, int4 iRangTri, int4 iTypeLoc, int4 iValLoc, char* pcBalise)\n" \
  "{\n" \
  "    int4 lg; /* Logueur du champ à traiter */\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iIntRet; /* Code retour de la fonction */\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 i, j, k, l, q, jj, ll;\n" \
  "    int4 iRang, iRgLigne, iObj;\n" \
  "    char tcRang[4 + 1];\n" \
  "    char tcDeplocarr[GYBIeinscLgDeppar + GYBIeinscLgLocpar + GYBIeinscLgArrond + 1];\n" \
  "    char tcBalises[50 + 1];\n" \
  "    int4 iGeo, iParuInst;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* balise encadrante */\n" \
  "    strcpy(tcBalises, pcBalise);\n" \
  "    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "    pipe = 0;\n" \
  "    j = iInit;\n" \
  "\n" \
  "    while (j < givrListParu.iNbrTot)\n" \
  "    {\n" \
  "        if ((iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[j]].iRangTri) && (GIV::giv_ARR == iValLoc))\n" \
  "        {\n" \
  "            j++;\n" \
  "            continue;\n" \
  "        }\n" \
  "        else if (iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[j]].iRangTri)\n" \
  "        {\n" \
  "            j++;\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        l = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (GIV::giv_ARR == iTypeLoc)\n" \
  "            iGeo = givrListParu.trEltList[l].iGeoArr;\n" \
  "        else if (GIV::giv_LOC == iTypeLoc)\n" \
  "            iGeo = givrListParu.trEltList[l].iGeoLoc;\n" \
  "        else if (GIV::giv_DEPT == iTypeLoc)\n" \
  "            iGeo = givrListParu.trEltList[l].iGeoDept;\n" \
  "        else if (GIV::giv_REG == iTypeLoc)\n" \
  "            iGeo = givrListParu.trEltList[l].iGeoReg;\n" \
  "\n" \
  "        iParuInst = (int4)GIV::GIXCodeOK;\n" \
  "        iRgLigne = givrListParu.trEltList[l].iRgLigne;\n" \
  "\n" \
  "        for (q = 0; (q < 3 && GIV::giv_ARR == iValLoc && iValLoc == iGeo && 0 != strcmp(\"0000\", (docClone + iRgLigne)->value.inscription[0].val_ls)); q++)\n" \
  "        {\n" \
  "            /* parution sur arrondissement d'installation */\n" \
  "            if ((0 == strcmp(givtrRefArr[q].dep, givrListParu.trEltList[l].dep)) && (0 == strcmp(givtrRefArr[q].loc, givrListParu.trEltList[l].loc)))\n" \
  "            {\n" \
  "                iParuInst = givtrRefArr[q].iParuInst;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (GIV::giv_ZU == iValLoc)\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ZU Ins : %d, %d, %s, %s\\n\", iGeo, givrListParu.trEltList[l].iZU, givrListParu.trEltList[l].dep, givrListParu.trEltList[l].loc));\n" \
  "\n" \
  "        if ((0 == strcmp(\"999\", givrListParu.trEltList[l].dep)) && (GIV::giv_REG != iTypeLoc))\n" \
  "        {\n" \
  "            /* ancienne région : seule la parution sur région est validée */\n" \
  "        }\n" \
  "        else if (((GIV::giv_ARR == iValLoc) && ((int4)GIV::GIXCodeOK != iParuInst)) || ((GIV::giv_ARR != iValLoc) && (GIV::giv_ZU != iValLoc) && (GIV::giv_ZV != iValLoc) && (GIV::giv_UV != iValLoc)\n" \
  "                 && (iValLoc == iGeo)) || ((GIV::giv_ZU == iValLoc) && (GIV::giv_DEPT == iGeo) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[l].iZU)) || ((GIV::giv_ZU == iValLoc) && (GIV::giv_EXTL == iGeo)\n" \
  "                         && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[l].iZU)) || ((GIV::giv_ZV == iValLoc) && (iTypeLoc == iGeo)) || ((GIV::giv_UV == iValLoc) && ('1' == givrListParu.trEltList[l].cParuloc)\n" \
  "                                 && (GIV::giv_ARR != iTypeLoc)) || ((GIV::giv_UV == iValLoc) && ('1' == givrListParu.trEltList[l].cParuloc) && (GIV::giv_ARR == iTypeLoc) && (0 != strcmp(\"99\", givrListParu.trEltList[l].arr))\n" \
  "                                         && (0 != strcmp(\"00\", givrListParu.trEltList[l].arr)) && (GIV::giv_INIT_ARR != iGeo)))\n" \
  "        {\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                if (0 == strcmp(\"pjdeploc\", pcBalise))\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_element(buf_pos, \"pjlocal\", \"1\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if (GIV::giv_ZV == iValLoc)\n" \
  "            {\n" \
  "                jj = iInit;\n" \
  "\n" \
  "                while (jj < givrListParu.iNbrTot)\n" \
  "                {\n" \
  "                    if (iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[jj]].iRangTri)\n" \
  "                    {\n" \
  "                        jj++;\n" \
  "                        continue;\n" \
  "                    }\n" \
  "\n" \
  "                    ll = givrListParu.trEltRangList[jj];\n" \
  "\n" \
  "                    if (((int4)GIV::GIXCodeOK == givrListParu.trEltList[ll].iZU) && (0 != strcmp(\"999\", givrListParu.trEltList[ll].dep)) && (givrListParu.trEltList[l].iRgLigne == givrListParu.trEltList[ll].iRgLigne))\n" \
  "                    {\n" \
  "                        strcpy(tcDeplocarr, givrListParu.trEltList[ll].dep);\n" \
  "                        strcat(tcDeplocarr, givrListParu.trEltList[ll].loc);\n" \
  "\n" \
  "                        if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)))\n" \
  "                        {\n" \
  "                            /* Trop d'entrées internes */\n" \
  "                            GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                            break;\n" \
  "                        }\n" \
  "\n" \
  "                        if (pipe == 0)\n" \
  "                        {\n" \
  "                            strcpy(buf_concat, tcDeplocarr);\n" \
  "                            pipe = 1;\n" \
  "                        }\n" \
  "                        else if (0 == strstr(buf_concat, tcDeplocarr))\n" \
  "                        {\n" \
  "                            strcat(buf_concat, \"|\");\n" \
  "                            strcat(buf_concat, tcDeplocarr);\n" \
  "                        }\n" \
  "                    }\n" \
  "\n" \
  "                    jj++;\n" \
  "                }\n" \
  "\n" \
  "                j++;\n" \
  "                continue;\n" \
  "            }\n" \
  "            else if (GIV::giv_UV == iValLoc)\n" \
  "            {\n" \
  "                if (0 == strcmp(givrListParu.trEltList[l].loc, givcLocFictive))\n" \
  "                {\n" \
  "                    /* ajout de toutes les localités du département pour LF */\n" \
  "                    iIntRet = givLectureLocDep(givrListParu.trEltList[l].dep, &pipe);\n" \
  "                    j++;\n" \
  "                    continue;\n" \
  "                }\n" \
  "                else if (GIV::giv_ARR == iTypeLoc)\n" \
  "                {\n" \
  "                    strcpy(tcDeplocarr, givrListParu.trEltList[l].dep);\n" \
  "                    strcat(tcDeplocarr, givrListParu.trEltList[l].loc);\n" \
  "                    strcat(tcDeplocarr, givrListParu.trEltList[l].arr);\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    strcpy(tcDeplocarr, givrListParu.trEltList[l].dep);\n" \
  "                    strcat(tcDeplocarr, givrListParu.trEltList[l].loc);\n" \
  "                }\n" \
  "            }\n" \
  "            else if (GIV::giv_ARR == iTypeLoc)\n" \
  "            {\n" \
  "                strcpy(tcDeplocarr, givrListParu.trEltList[l].dep);\n" \
  "                strcat(tcDeplocarr, givrListParu.trEltList[l].loc);\n" \
  "                strcat(tcDeplocarr, givrListParu.trEltList[l].arr);\n" \
  "            }\n" \
  "            else if (GIV::giv_LOC == iTypeLoc)\n" \
  "            {\n" \
  "                strcpy(tcDeplocarr, givrListParu.trEltList[l].dep);\n" \
  "                strcat(tcDeplocarr, givrListParu.trEltList[l].loc);\n" \
  "            }\n" \
  "            else if (GIV::giv_DEPT == iTypeLoc)\n" \
  "                strcpy(tcDeplocarr, givrListParu.trEltList[l].dep);\n" \
  "            else if (GIV::giv_REG == iTypeLoc)\n" \
  "                strcpy(tcDeplocarr, givrListParu.trEltList[l].reg);\n" \
  "\n" \
  "            if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)))\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                strcpy(buf_concat, tcDeplocarr);\n" \
  "                pipe = 1;\n" \
  "            }\n" \
  "            else if (0 == strstr(buf_concat, tcDeplocarr))\n" \
  "            {\n" \
  "                strcat(buf_concat, \"|\");\n" \
  "                strcat(buf_concat, tcDeplocarr);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        j++;\n" \
  "    }\n" \
  "\n" \
  "    j = iInit;\n" \
  "\n" \
  "    while ((j < givrListInst.iNbrTot) && (GIV::giv_ARR == iTypeLoc) && (GIV::giv_ARR == iValLoc))\n" \
  "    {\n" \
  "        if (iRangTri != givrListInst.trEltList[givrListInst.trEltRangList[j]].iRangTri)\n" \
  "        {\n" \
  "            j++;\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        l = givrListInst.trEltRangList[j];\n" \
  "        iGeo = givrListInst.trEltList[l].iGeoArr;\n" \
  "        iRgLigne = givrListInst.trEltList[l].iRgLigne;\n" \
  "\n" \
  "        for (q = 0; q < 3; q++)\n" \
  "        {\n" \
  "            /* parution sur arrondissement d'installation */\n" \
  "            if ((0 == strcmp(givtrRefArr[q].dep, givrListInst.trEltList[l].dep)) && (0 == strcmp(givtrRefArr[q].loc, givrListInst.trEltList[l].loc)))\n" \
  "            {\n" \
  "                iParuInst = givtrRefArr[q].iParuInst;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 == strcmp(\"0000\", (docClone + iRgLigne)->value.inscription[0].val_ls))\n" \
  "            iParuInst = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "        if (((int4)GIV::GIXCodeOK == iParuInst) && (iValLoc == iGeo))\n" \
  "        {\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                if (0 == strcmp(\"pjdeploc\", pcBalise))\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_element(buf_pos, \"pjlocal\", \"1\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            strcpy(tcDeplocarr, givrListInst.trEltList[l].dep);\n" \
  "            strcat(tcDeplocarr, givrListInst.trEltList[l].loc);\n" \
  "            strcat(tcDeplocarr, givrListInst.trEltList[l].arr);\n" \
  "\n" \
  "            if (sizeof(buf_concat) < (strlen(buf_concat) + strlen(tcDeplocarr)))\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                strcpy(buf_concat, tcDeplocarr);\n" \
  "                pipe = 1;\n" \
  "            }\n" \
  "            else if (0 == strstr(buf_concat, tcDeplocarr))\n" \
  "            {\n" \
  "                strcat(buf_concat, \"|\");\n" \
  "                strcat(buf_concat, tcDeplocarr);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        j++;\n" \
  "    }\n" \
  "\n" \
  "    if (GIV::giv_ZU == iValLoc)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ZU Ins Buf: %s\\n\", buf_concat));\n" \
  "\n" \
  "    if (1 == pipe)\n" \
  "    {\n" \
  "        iIntRet = supprimer_doublon(buf_concat, '|');\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Taille liste geo : '%d'\\n\", strlen(buf_concat)));\n" \
  "        pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "        for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            /* analyse geo */\n" \
  "            memcpy(tcDeplocarr, pt_debut, (pt_fin - pt_debut));\n" \
  "            tcDeplocarr[(pt_fin - pt_debut)] = '\\0';\n" \
  "            lg_write = giv_ecrit_element(buf_pos, pcBalise, tcDeplocarr);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "        iCodRet = GIV::GWCCodeKO;\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrit partie_3_geo  */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_3_an9   ()                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie trois du tri rubrique                          */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 giv_ecrit_partie_3_an9(char** buf_pos_in, GYBrDOCUMENTEpj* docClone, int4 iRangTri, int4 iTypeLoc, int4 iValLoc, char* pcBalise)\n" \
  "{\n" \
  "    int4 lg; /* Logueur du champ à traiter */\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iIntRet; /* Code retour de la fonction */\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 i, j, k, l, q, jj, ll;\n" \
  "    int4 iRang, iRgLigne, iObj;\n" \
  "    char tcRang[4 + 1];\n" \
  "    char tcDeploc[GYBIeinscLgDeppar + GYBIeinscLgLocpar + 1];\n" \
  "    int4 iGeo, iParuInst;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    char tcBalise[50 + 1];\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    pipe = 0;\n" \
  "\n" \
  "    for (j = 0; j < givrListParu.iNbrTot; j++)\n" \
  "    {\n" \
  "        l = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (iRangTri == givrListParu.trEltList[l].iRgTriDbl)\n" \
  "        {\n" \
  "            if (GIV::giv_ARR == iTypeLoc)\n" \
  "                iGeo = givrListParu.trEltList[l].iGeoArr;\n" \
  "            else if (GIV::giv_LOC == iTypeLoc)\n" \
  "                iGeo = givrListParu.trEltList[l].iGeoLoc;\n" \
  "            else if (GIV::giv_DEPT == iTypeLoc)\n" \
  "                iGeo = givrListParu.trEltList[l].iGeoDept;\n" \
  "            else if (GIV::giv_REG == iTypeLoc)\n" \
  "                iGeo = givrListParu.trEltList[l].iGeoReg;\n" \
  "\n" \
  "            iParuInst = (int4)GIV::GIXCodeOK;\n" \
  "            iRgLigne = givrListParu.trEltList[l].iRgLigne;\n" \
  "\n" \
  "            for (q = 0; (q < 3 && GIV::giv_ARR == iValLoc && iValLoc == iGeo && 0 != strcmp(\"0000\", (docClone + iRgLigne)->value.inscription[0].val_ls)); q++)\n" \
  "            {\n" \
  "                /* parution sur arrondissement d'installation */\n" \
  "                if ((0 == strcmp(givtrRefArr[q].dep, givrListParu.trEltList[l].dep)) && (0 == strcmp(givtrRefArr[q].loc, givrListParu.trEltList[l].loc)))\n" \
  "                {\n" \
  "                    iParuInst = givtrRefArr[q].iParuInst;\n" \
  "                    break;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if ((0 == strcmp(\"999\", givrListParu.trEltList[l].dep)) && (GIV::giv_REG != iTypeLoc))\n" \
  "            {\n" \
  "                /* ancienne région : seule la parution sur région est validée */\n" \
  "            }\n" \
  "            else if ((GIV::giv_ZV == iValLoc) && (iTypeLoc == iGeo))\n" \
  "            {\n" \
  "                jj = 0;\n" \
  "\n" \
  "                while (jj < givrListParu.iNbrTot)\n" \
  "                {\n" \
  "                    if (iRangTri != givrListParu.trEltList[givrListParu.trEltRangList[jj]].iRangTri)\n" \
  "                    {\n" \
  "                        jj++;\n" \
  "                        continue;\n" \
  "                    }\n" \
  "\n" \
  "                    ll = givrListParu.trEltRangList[jj];\n" \
  "\n" \
  "                    if (((int4)GIV::GIXCodeOK == givrListParu.trEltList[ll].iZU) && (0 != strcmp(\"999\", givrListParu.trEltList[ll].dep)) && (givrListParu.trEltList[l].iRgLigne == givrListParu.trEltList[ll].iRgLigne))\n" \
  "                    {\n" \
  "                        i = givrListParu.trEltList[ll].iRgLigne;\n" \
  "\n" \
  "                        if ((int4)10000 < (strlen(buf_concat) + strlen(givrListParu.trEltList[ll].tcRgDnom)))\n" \
  "                        {\n" \
  "                            /* Trop d'entrées internes */\n" \
  "                            GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                            break;\n" \
  "                        }\n" \
  "\n" \
  "                        if (pipe == 0)\n" \
  "                        {\n" \
  "                            strcpy(buf_concat, givrListParu.trEltList[ll].tcRgDnom);\n" \
  "                            buf_concat[10000] = '\\0';\n" \
  "                            pipe = 1;\n" \
  "                        }\n" \
  "                        else if (0 == strstr(buf_concat, givrListParu.trEltList[ll].tcRgDnom))\n" \
  "                        {\n" \
  "                            strcat(buf_concat, \"|\");\n" \
  "                            strcat(buf_concat, givrListParu.trEltList[ll].tcRgDnom);\n" \
  "                        }\n" \
  "\n" \
  "                        /* Analyse des objets */\n" \
  "                        for (q = 0; q < givrListObj.iNbr; q++)\n" \
  "                        {\n" \
  "                            if (i == givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgLigne)\n" \
  "                            {\n" \
  "                                k = givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgObj;\n" \
  "\n" \
  "                                if ((int4)40000 < (strlen(&buf_concat[10000]) + strlen((docClone + i)->value.objets_pub.micro[k].tcRgObj)))\n" \
  "                                {\n" \
  "                                    /* Trop d'entrées internes */\n" \
  "                                    GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                                    break;\n" \
  "                                }\n" \
  "\n" \
  "                                if ('\\0' == buf_concat[10000])\n" \
  "                                    strcpy(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj);\n" \
  "                                else if (0 == strstr(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj))\n" \
  "                                {\n" \
  "                                    strcat(&buf_concat[10000], \"|\");\n" \
  "                                    strcat(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj);\n" \
  "                                }\n" \
  "                            }\n" \
  "                        }\n" \
  "                    }\n" \
  "\n" \
  "                    jj++;\n" \
  "                }\n" \
  "            }\n" \
  "            else if (((GIV::giv_ARR == iValLoc) && ((int4)GIV::GIXCodeOK != iParuInst)) || ((GIV::giv_ARR != iValLoc) && (GIV::giv_ZU != iValLoc) && (GIV::giv_UV != iValLoc) && (iValLoc == iGeo))\n" \
  "                     || ((GIV::giv_ZU == iValLoc) && (GIV::giv_DEPT == iGeo) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[l].iZU)) || ((GIV::giv_ZU == iValLoc) && (GIV::giv_EXTL == iGeo)\n" \
  "                             && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[l].iZU)) || ((GIV::giv_UV == iValLoc) && ('1' == givrListParu.trEltList[l].cParuloc) && (GIV::giv_DFT != iGeo) && (GIV::giv_INIT_ARR != iGeo)))\n" \
  "            {\n" \
  "                i = givrListParu.trEltList[l].iRgLigne;\n" \
  "\n" \
  "                if ((int4)10000 < (strlen(buf_concat) + strlen(givrListParu.trEltList[l].tcRgDnom)))\n" \
  "                {\n" \
  "                    /* Trop d'entrées internes */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                if (pipe == 0)\n" \
  "                {\n" \
  "                    strcpy(buf_concat, givrListParu.trEltList[l].tcRgDnom);\n" \
  "                    buf_concat[10000] = '\\0';\n" \
  "                    pipe = 1;\n" \
  "                }\n" \
  "                else if (0 == strstr(buf_concat, givrListParu.trEltList[l].tcRgDnom))\n" \
  "                {\n" \
  "                    strcat(buf_concat, \"|\");\n" \
  "                    strcat(buf_concat, givrListParu.trEltList[l].tcRgDnom);\n" \
  "                }\n" \
  "\n" \
  "                for (q = 0; q < givrListObj.iNbr; q++)\n" \
  "                {\n" \
  "                    if (i == givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgLigne)\n" \
  "                    {\n" \
  "                        k = givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgObj;\n" \
  "\n" \
  "                        if ((int4)40000 < (strlen(&buf_concat[10000]) + strlen((docClone + i)->value.objets_pub.micro[k].tcRgObj)))\n" \
  "                        {\n" \
  "                            /* Trop d'entrées internes */\n" \
  "                            GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                            break;\n" \
  "                        }\n" \
  "\n" \
  "                        if ('\\0' == buf_concat[10000])\n" \
  "                            strcpy(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj);\n" \
  "                        else if (0 == strstr(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj))\n" \
  "                        {\n" \
  "                            strcat(&buf_concat[10000], \"|\");\n" \
  "                            strcat(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj);\n" \
  "                        }\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Ref Pub geo pour An9 : ... %d,%d,%d,%d,%s,%s\\n\", iRangTri, givrListParu.trEltList[l].iRgTriDbl, givrListParu.trEltList[l].iRangTri, givrListParu.trEltList[l].iRgLigne,\n" \
  "                                 buf_concat, &buf_concat[10000]));\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Ref Pub geo pour An9 : ... %s,%s\\n\", buf_concat, &buf_concat[10000]));\n" \
  "\n" \
  "    for (j = 0; (j < givrListInst.iNbrTot && GIV::giv_ARR == iTypeLoc && GIV::giv_ARR == iValLoc); j++)\n" \
  "    {\n" \
  "        l = givrListInst.trEltRangList[j];\n" \
  "        iGeo = givrListInst.trEltList[l].iGeoArr;\n" \
  "\n" \
  "        if ((iRangTri == givrListInst.trEltList[l].iRgTriDbl) && (iValLoc == iGeo))\n" \
  "        {\n" \
  "            iRgLigne = givrListInst.trEltList[l].iRgLigne;\n" \
  "\n" \
  "            for (q = 0; q < 3; q++)\n" \
  "            {\n" \
  "                /* parution sur arrondissement d'installation */\n" \
  "                if ((0 == strcmp(givtrRefArr[q].dep, givrListInst.trEltList[l].dep)) && (0 == strcmp(givtrRefArr[q].loc, givrListInst.trEltList[l].loc)))\n" \
  "                {\n" \
  "                    iParuInst = givtrRefArr[q].iParuInst;\n" \
  "                    break;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if (0 == strcmp(\"0000\", (docClone + iRgLigne)->value.inscription[0].val_ls))\n" \
  "                iParuInst = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iParuInst)\n" \
  "            {\n" \
  "                i = givrListInst.trEltList[l].iRgLigne;\n" \
  "\n" \
  "                if ((int4)10000 < (strlen(buf_concat) + strlen(givrListParu.trEltList[l].tcRgDnom)))\n" \
  "                {\n" \
  "                    /* Trop d'entrées internes */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                if (pipe == 0)\n" \
  "                {\n" \
  "                    strcpy(buf_concat, givrListInst.trEltList[l].tcRgDnom);\n" \
  "                    buf_concat[10000] = '\\0';\n" \
  "                    pipe = 1;\n" \
  "                }\n" \
  "                else if (0 == strstr(buf_concat, givrListInst.trEltList[l].tcRgDnom))\n" \
  "                {\n" \
  "                    strcat(buf_concat, \"|\");\n" \
  "                    strcat(buf_concat, givrListInst.trEltList[l].tcRgDnom);\n" \
  "                }\n" \
  "\n" \
  "                for (q = 0; q < givrListObj.iNbr; q++)\n" \
  "                {\n" \
  "                    if (i == givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgLigne)\n" \
  "                    {\n" \
  "                        k = givrListObj.trEltListObj[givrListObj.trEltRangListObj[q]].iRgObj;\n" \
  "\n" \
  "                        if ((int4)40000 < (strlen(&buf_concat[10000]) + strlen((docClone + i)->value.objets_pub.micro[k].tcRgObj)))\n" \
  "                        {\n" \
  "                            /* Trop d'entrées internes */\n" \
  "                            GWTTrace(GWT_NIV_GRAVE, (\"Taille buffer interne dépassée\\n\"));\n" \
  "                            break;\n" \
  "                        }\n" \
  "\n" \
  "                        if ('\\0' == buf_concat[10000])\n" \
  "                            strcpy(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj);\n" \
  "                        else if (0 == strstr(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj))\n" \
  "                        {\n" \
  "                            strcat(&buf_concat[10000], \"|\");\n" \
  "                            strcat(&buf_concat[10000], (docClone + i)->value.objets_pub.micro[k].tcRgObj);\n" \
  "                        }\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (1 == pipe)\n" \
  "    {\n" \
  "        iIntRet = supprimer_doublon(buf_concat, '|');\n" \
  "        strcpy(tcBalise, \"pjdenom\");\n" \
  "        strcat(tcBalise, pcBalise);\n" \
  "        pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "        for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            /* analyse rang */\n" \
  "            memcpy(tcRang, pt_debut, (pt_fin - pt_debut));\n" \
  "            tcRang[(pt_fin - pt_debut)] = '\\0';\n" \
  "            iRang = atoi(tcRang);\n" \
  "            lg_write = giv_ecrit_balise_iso(buf_pos, (docClone + iRang)->value.intitule.denomination, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != buf_concat[10000])\n" \
  "    {\n" \
  "        iIntRet = supprimer_doublon(&buf_concat[10000], '|');\n" \
  "        strcpy(tcBalise, \"pjobjet\");\n" \
  "        strcat(tcBalise, pcBalise);\n" \
  "        pt_fin_lst = &buf_concat[10000] + strlen(&buf_concat[10000]);\n" \
  "\n" \
  "        for (pt_debut = &buf_concat[10000]; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            /* analyse rang */\n" \
  "            memcpy(tcRang, pt_debut, (pt_fin - pt_debut));\n" \
  "            tcRang[(pt_fin - pt_debut)] = '\\0';\n" \
  "            iRang = atoi(tcRang);\n" \
  "\n" \
  "            for (i = 0; (i < givrListObj.iNbr && iRang != givrListObj.trEltListObj[i].iRangTri); i++)\n" \
  "                ;\n" \
  "\n" \
  "            iRang = givrListObj.trEltListObj[i].iRgLigne;\n" \
  "            iObj = givrListObj.trEltListObj[i].iRgObj;\n" \
  "            iIntRet = giv_ecrit_objet_pub(&buf_pos, docClone, iRang, iObj, tcBalise);\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrit partie_3_an9  */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : giv_ecrit_partie_3       ()                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit la partie trois du clone                                 */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 giv_ecrit_partie_3(char** buf_pos_in, GYBrDOCUMENTEpj* docClone, int4 indice, int4 iTri)\n" \
  "{\n" \
  "    int4 lg; /* Logueur du champ à traiter */\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iRet; /* Code retour de la fonction */\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 i, j, k, l, m, mm, n, p, q;\n" \
  "    int4 iRef;\n" \
  "    int4 jRef, jInit;\n" \
  "    int4 iTrouve;\n" \
  "    int4 iIntRet = GIV::GWCCodeOK;\n" \
  "    int4 iNbrRangRub;\n" \
  "    int4 iRgRubDbl, iRang, iObj;\n" \
  "    char tcRang[4 + 1];\n" \
  "    char tcDeploc[GYBIeinscLgDeppar + GYBIeinscLgLocpar + 1];\n" \
  "    int4 iNbGeoRub;\n" \
  "    int4 iNbRub;\n" \
  "    int4 iParuInst;\n" \
  "    int4 iCountMC;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* boucle sur rubrique */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Partie 3 Nombre de tris [%d]\\n\", givrListParu.iNbrTri));\n" \
  "    pipe = 0;\n" \
  "    buf_concat[0] = '\\0';\n" \
  "    docClone->iSource = 1;\n" \
  "\n" \
  "    for (i = 1; i < indice; i++)\n" \
  "        (docClone + i)->iSource = docClone->iSource;\n" \
  "\n" \
  "    i = 0;\n" \
  "    j = 0;\n" \
  "    pipe = 0;\n" \
  "\n" \
  "    for (n = 0; n < givrListParu.iNbrTri; n++)\n" \
  "    {\n" \
  "        if ((GIV::giv_RUB == iTri) && ('\\0' != GIVBuffXML[0]))\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        jRef = giv_ecrit_partie_30(&buf_pos, n, iTri);\n" \
  "\n" \
  "        if ((GIV::giv_RUB == iTri) && ('\\0' != GIVBuffXML[0]))\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie  en UTF8 */\n" \
  "            iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        if (-1 == jRef)\n" \
  "            continue;\n" \
  "\n" \
  "        j = jRef;\n" \
  "        l = givrListParu.trEltRangList[j];\n" \
  "        m = givrListParu.trEltList[l].iRangTri;\n" \
  "        mm = givrListParu.trEltList[l].iRgTriDbl;\n" \
  "        /* analyse des données géographiques des doubles */\n" \
  "        memset(buf_concat, 0, strlen(buf_concat));\n" \
  "        pipe = 0;\n" \
  "        i = 0;\n" \
  "        /* Pour deplocarr */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, 0, m, GIV::giv_ARR, GIV::giv_ARR, \"pjdeplocarr\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_ARR, GIV::giv_ARR, \"deplocarr\");\n" \
  "\n" \
  "        /* deplocarrextra */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_LOC, \"pjdeplocarrextra\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_ARR, GIV::giv_LOC, \"deplocarrextra\");\n" \
  "\n" \
  "        /* Pour deploc */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_LOC, \"pjdeploc\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_LOC, GIV::giv_LOC, \"deploc\");\n" \
  "\n" \
  "        /* Pour deploczoneurbaine */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_ZU, \"pjdeploczoneurbaine\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_LOC, GIV::giv_ZU, \"deploczoneurbaine\");\n" \
  "\n" \
  "        /* Pour deplocZuv */\n" \
  "        iIntRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_ZV, \"pjdeplocZuv\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_LOC, GIV::giv_ZV, \"deplocZuv\");\n" \
  "\n" \
  "        /* Pour deplocextraloc */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_DEPT, \"pjdeplocextraloc\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_LOC, GIV::giv_DEPT, \"deplocextraloc\");\n" \
  "\n" \
  "        /* deplocarrextraloc */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_DEPT, \"pjdeplocarrextraloc\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_ARR, GIV::giv_DEPT, \"deplocarrextraloc\");\n" \
  "\n" \
  "        /* deplocuv */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_UV, \"pjdeplocuv\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_LOC, GIV::giv_UV, \"pjdeplocuv\");\n" \
  "\n" \
  "        /* deplocarruv */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_UV, \"pjdeplocarruv\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_ARR, GIV::giv_UV, \"pjdeplocarruv\");\n" \
  "\n" \
  "        /* Pour deplocextradep */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_LOC, GIV::giv_EXTL, \"pjdeplocextradep\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_LOC, GIV::giv_EXTL, \"deplocextradep\");\n" \
  "\n" \
  "        /* deplocarrextradep */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_ARR, GIV::giv_EXTL, \"pjdeplocarrextradep\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_ARR, GIV::giv_EXTL, \"deplocarrextradep\");\n" \
  "\n" \
  "        /* Pour dep */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_DEPT, GIV::giv_DEPT, \"pjdep\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_DEPT, GIV::giv_DEPT, \"dep\");\n" \
  "\n" \
  "        /* Pour depextra */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_DEPT, GIV::giv_EXTL, \"pjdepextra\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_DEPT, GIV::giv_EXTL, \"depextra\");\n" \
  "\n" \
  "        /* Pour reg */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_REG, GIV::giv_REG, \"pjreg\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_REG, GIV::giv_REG, \"reg\");\n" \
  "\n" \
  "        /* Pour regextra */\n" \
  "        iRet = giv_ecrit_partie_3_geo(&buf_pos, docClone, jRef, m, GIV::giv_REG, GIV::giv_EXTL, \"pjregextra\");\n" \
  "\n" \
  "        if ((GIV::GWCCodeOK == iRet) && (GIV::giv_RUB == iTri))\n" \
  "            iRet = giv_ecrit_partie_3_an9(&buf_pos, docClone, mm, GIV::giv_REG, GIV::giv_EXTL, \"regextra\");\n" \
  "\n" \
  "        if (GIV::giv_RUB == iTri)\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"parutionrubriques\");\n" \
  "        else if (GIV::giv_DNOM == iTri)\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"parutiondenoms\");\n" \
  "        else if (GIV::giv_OBJ == iTri)\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"parutionobjets\");\n" \
  "\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* tri suivant */\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin ecrit partie_3  */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  :giv_sortie_ISO ()                                               */\n" \
  "/*                                                                            */\n" \
  "/* But       : écriture ISO du fichier de sortie                              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_sortie_ISO(char** buf_pos_in, FILE* afDescFic)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 lg_a_ecrire = 0;\n" \
  "    char* buf_pos;\n" \
  "    /* Calcul de la longueur a ecrire */\n" \
  "    lg_a_ecrire = strlen(GIVBuffXML);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Enrichissement %d,%d \\n\", giviEnrich, giviCodRetEcr));\n" \
  "\n" \
  "    if ((NULL != afDescFic) && (0 != lg_a_ecrire) && ((int4)GIV::GIXCodeOK == giviCodRetEcr))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"On passe dans l'ecriture du fichier de sortie ISO \\n\"));\n" \
  "        /* ecriture de l'enregistrement dans le fichier de sortie */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Taille du buff a ecrire dans le fic XML : %d\\n\", lg_a_ecrire));\n" \
  "        /* Conversion du buffer avant écriture dans le fichier */\n" \
  "        givTradChar(&lg_a_ecrire);\n" \
  "        /* ecriture de l'enregistrement dans le fichier de sortie */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Taille du buff UTF8 a ecrire dans le fic XML : %d,%d\\n\", strlen(GIVBuffTest), lg_a_ecrire));\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK != giviEnrich)\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iIntRet = (int4)fwrite(GIVBuffXML, lg_a_ecrire, 1, afDescFic);\n" \
  "        }\n" \
  "        /* utilisation du buffer de cas de test */\n" \
  "        else if ((strlen(GIVBuffTest) + strlen(GIVBuffXML)) > giv_LG_BUFFTEST)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : taille du bloc %d supérieure à %d octets\\n\", (strlen(GIVBuffTest) + strlen(GIVBuffXML)), giv_LG_BUFFTEST));\n" \
  "            giviCodRetEcr = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            strcat(GIVBuffTest, GIVBuffXML);\n" \
  "            iIntRet = 1;\n" \
  "        }\n" \
  "\n" \
  "        if (1 != iIntRet)\n" \
  "        {\n" \
  "            /*  Erreur d'ecriture mouvement CD */\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD : [ERR=%02Xh]\\n\", errno));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD, code retour fwrite : %d\\n\", iIntRet));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((GIVfDescFicBloc == afDescFic) && (GIVfDescFicMCD != GIVfDescFicBloc) && (0 != lg_a_ecrire))\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iIntRet = (int4)fwrite(GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);\n" \
  "\n" \
  "        if (1 != iIntRet)\n" \
  "        {\n" \
  "            /*  Erreur d'ecriture mouvement CD */\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD : [ERR=%02Xh]\\n\", errno));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD, code retour fwrite : %d\\n\", iIntRet));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Effacement du buffer */\n" \
  "    GIVBuffXML[0] = '\\0';\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = GIVBuffXML;\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  :giv_sortie_ ()                                               */\n" \
  "/*                                                                            */\n" \
  "/* But       : écriture du fichier de sortie format inchangé                  */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_sortie(char** buf_pos_in, FILE* afDescFic)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 lg_a_ecrire = 0;\n" \
  "    char* buf_pos;\n" \
  "    /* Calcul de la longueur a ecrire */\n" \
  "    lg_a_ecrire = strlen(GIVBuffXML);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Enrichissement %d,%d \\n\", giviEnrich, giviCodRetEcr));\n" \
  "\n" \
  "    if ((NULL != afDescFic) && (0 != lg_a_ecrire) && ((int4)GIV::GIXCodeOK == giviCodRetEcr))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"On passe dans l'ecriture du fichier de sortie UTF8 \\n\"));\n" \
  "        /* ecriture de l'enregistrement dans le fichier de sortie */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Taille du buff a ecrire dans le fic XML : %d\\n\", lg_a_ecrire));\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK != giviEnrich)\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iIntRet = (int4)fwrite(GIVBuffXML, lg_a_ecrire, 1, afDescFic);\n" \
  "        }\n" \
  "        /* utilisation du buffer de cas de test */\n" \
  "        else if ((strlen(GIVBuffTest) + strlen(GIVBuffXML)) > giv_LG_BUFFTEST)\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur : taille du bloc %d supérieure à %d octets\\n\", (strlen(GIVBuffTest) + strlen(GIVBuffXML)), giv_LG_BUFFTEST));\n" \
  "            giviCodRetEcr = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            strcat(GIVBuffTest, GIVBuffXML);\n" \
  "            iIntRet = 1;\n" \
  "        }\n" \
  "\n" \
  "        if (1 != iIntRet)\n" \
  "        {\n" \
  "            /*  Erreur d'ecriture mouvement CD */\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD : [ERR=%02Xh]\\n\", errno));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD, code retour fwrite : %d\\n\", iIntRet));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((GIVfDescFicBloc == afDescFic) && (GIVfDescFicMCD != GIVfDescFicBloc) && (0 != lg_a_ecrire))\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iIntRet = (int4)fwrite(GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);\n" \
  "\n" \
  "        if (1 != iIntRet)\n" \
  "        {\n" \
  "            /*  Erreur d'ecriture mouvement CD */\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD : [ERR=%02Xh]\\n\", errno));\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Erreur ecriture sur fichier MCD, code retour fwrite : %d\\n\", iIntRet));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Effacement du buffer */\n" \
  "    GIVBuffXML[0] = '\\0';\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = GIVBuffXML;\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givFin ()                                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : Fin de tous les blocs                                          */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : la structure XML d'un bloc                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givFin(char** buf_pos_in, char* blocid)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iIntRet = GIV::GWCCodeOK;\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fin ECRITURE PARTIE_3 ..debut Fin.\\n\"));\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        if (0 == strcmp(\"OUI\", givtcContenu))\n" \
  "            iIntRet = (int4)giv_sortie_ISO(&buf_pos, GIVfDescFicMCD);\n" \
  "        else\n" \
  "            iIntRet = giv_fichier_sortie(&buf_pos, &GIVfDescFicMCD);\n" \
  "    }\n" \
  "\n" \
  "    /* fermeture du fichier */\n" \
  "    iIntRet = (int4)giv_fermeture_fichier_sortie(&buf_pos, blocid);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"pas de fichier de sortie\\n\"));\n" \
  "        iCodRet = GIV::GWCCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin Documents */\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  :giv_fichier_sortie ()                                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : Creation du fichier de sortie pr chaque bloc de parution       */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_fichier_sortie(char** buf_pos_in, FILE** apfDescFic)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    char cChemin[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cNomFichier1[256] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cNomFichier3[256] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    int4 lg_a_ecrire; /* Longueur du contenu de buffer : a ecrire */\n" \
  "    int4 lg_ecrit_entete = 0;\n" \
  "    char cEntete_xml[100] = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\" ?>\";\n" \
  "    char cEntete_xml0[] = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\";\n" \
  "    char cEntete_xml1[] = \"<!DOCTYPE sgipro [\";\n" \
  "    char cEntete_xml2[] = \"<!ENTITY euro   \\\"&#8364;\\\" >\";\n" \
  "    char cEntete_xml3[] = \"<!ENTITY laquo   \\\"&#171;\\\" >\";\n" \
  "    char cEntete_xml4[] = \"<!ENTITY raquo   \\\"&#187;\\\" >\";\n" \
  "    char cEntete_xml5[] = \"<!ENTITY quot   \\\"&#34;\\\" >\";\n" \
  "    char cEntete_xml6[] = \"]>\";\n" \
  "    char* buf_pos;\n" \
  "    char tcNumMvt[GXWLgIdDonnees];\n" \
  "    char* pcVersion = NULL;\n" \
  "    char conf[50];\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"On passe dans l'ecriture du fichier de sortie %d,%d,%d\\n\", num_id, giviNbBlocs, giviClose));\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    if ((0 != num_id) && (0 == (num_id % giviNbBlocs)) && (-1 != giviNbBlocs) && ((int4)GIV::GIXCodeKO == giviClose))\n" \
  "    {\n" \
  "        giviClose = (int4)GIV::GIXCodeOK;\n" \
  "        giviNumFic = giviNumFicInit + (num_id / giviNbBlocs);\n" \
  "    }\n" \
  "\n" \
  "    if ((NULL == *apfDescFic) && (('\\0' != GIVBuffXML[0]) || ((int4)GIV::GIXCodeKO == giviClose)))\n" \
  "    {\n" \
  "        /* nouveau fichier */\n" \
  "        /* Initialisation des variables locales */\n" \
  "        (void)memset((void*)cChemin, 0x00, (size_t)sizeof(cChemin));\n" \
  "        (void)memset((void*)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));\n" \
  "        /* ouverture du fichier des mouvements CD2G */\n" \
  "        /* constitution du nom du fichier */\n" \
  "        /* constitution du nom du fichier Bloc */\n" \
  "        (void)sprintf(conf, \"%s_%s\", \"GXXPathCd2g\", GIXcNomDest);\n" \
  "        iIntRet = GWTLireConf(conf, cChemin);\n" \
  "\n" \
  "        if (GIV::GWTok != iIntRet)\n" \
  "        {\n" \
  "            (void)strcpy(cChemin, \"/DATA/DEPT/CD2G\");\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Pas de Path des mvts interne dans la conf. Valeur par defaut <%s> prise \\n\", cChemin));\n" \
  "        }\n" \
  "\n" \
  "        if (-1 == giviNbBlocs)\n" \
  "        {\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%s.%s.%s.xml\", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire);\n" \
  "            (void)sprintf(&cNomFichier1[0], \"%s/%s/CFLT.%s.%s.%s.xml\", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire);\n" \
  "            (void)sprintf(&cNomFichier3[0], \"%s/%s/ETB.%s.%s.%s\", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%s.%s.%s.%d.xml\", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire, giviNumFic);\n" \
  "            (void)sprintf(&cNomFichier1[0], \"%s/%s/CFLT.%s.%s.%s.%d.xml\", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire, giviNumFic);\n" \
  "            (void)sprintf(&cNomFichier3[0], \"%s/%s/ETB.%s.%s.%s.%d\", cChemin, givcRepertoire, GIXtcNomFichier, GIXcNomDest, givcRepertoire, giviNumFic);\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Nom fichier mouvements CD2G <%s>\\n\", cNomFichier));\n" \
  "        /* Ouverture fichier des mouvements CD2G */\n" \
  "        *apfDescFic = fopen64(cNomFichier,\n" \
  "                              GIV_FCREAT);\n" \
  "\n" \
  "        if (NULL == *apfDescFic)\n" \
  "        {\n" \
  "            /* Echec ouverture fichier mouvements => erreur */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur FOPEN fichier mouvements CD : [ERR=%02Xh, PTH=%s]\\n\", errno, cNomFichier));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        GIVfDescFicCFLT = NULL;\n" \
  "        GIVfDescFicETB = NULL;\n" \
  "        /* Preparation du header XML dans le fichier de sortie */\n" \
  "        strcpy(buf_concat, cEntete_xml0);\n" \
  "        lg_ecrit_entete = strlen(cEntete_xml0);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        strcpy(&buf_concat[lg_ecrit_entete], cEntete_xml1);\n" \
  "        lg_ecrit_entete += strlen(cEntete_xml1);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        strcpy(&buf_concat[lg_ecrit_entete], cEntete_xml2);\n" \
  "        lg_ecrit_entete += strlen(cEntete_xml2);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        strcpy(&buf_concat[lg_ecrit_entete], cEntete_xml3);\n" \
  "        lg_ecrit_entete += strlen(cEntete_xml3);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        strcpy(&buf_concat[lg_ecrit_entete], cEntete_xml4);\n" \
  "        lg_ecrit_entete += strlen(cEntete_xml3);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        strcpy(&buf_concat[lg_ecrit_entete], cEntete_xml5);\n" \
  "        lg_ecrit_entete += strlen(cEntete_xml5);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        strcpy(&buf_concat[lg_ecrit_entete], cEntete_xml6);\n" \
  "        lg_ecrit_entete += strlen(cEntete_xml6);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        /* Ajout de la ligne <operations> */\n" \
  "        strcpy(&buf_concat[lg_ecrit_entete], \"<OPERATIONS>\");\n" \
  "        lg_ecrit_entete = strlen(buf_concat);\n" \
  "        *(buf_concat + lg_ecrit_entete) = SEPARE_LIGNE;\n" \
  "        *(buf_concat + lg_ecrit_entete + 1) = LINE_FEED;\n" \
  "        *(buf_concat + lg_ecrit_entete + 2) = '\\0';\n" \
  "        lg_ecrit_entete = lg_ecrit_entete + 2;\n" \
  "        /* ecriture du contenu du header dans le fichier de sortie */\n" \
  "        iIntRet = (int4)fwrite(buf_concat, lg_ecrit_entete, 1, *apfDescFic);\n" \
  "\n" \
  "        if (1 != iIntRet)\n" \
  "        {\n" \
  "            /* probleme d'ecriture de l'entete */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Probleme d'ecriture de l'entete pour le dept [%s]\\n\", GIXcDepartement));\n" \
  "            iCodRet = GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        /* Init buffer de cas de test */\n" \
  "        GIVBuffTest[0] = '\\0';\n" \
  "    }\n" \
  "\n" \
  "    if (((int4)GIV::GWCCodeOK == iCodRet) && ('\\0' != GIVBuffXML[0]))\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iIntRet = (int4)giv_sortie_ISO(&buf_pos, *apfDescFic);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  :giv_fichier_sortie_cflt ()                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : Creation du fichier de sortie de conflit                       */\n" \
  "/*             de balise de contenu selon priorité                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_fichier_sortie_cflt(int4 aiRg, GYBrDOCUMENTEpj* doc, GYBrPrioCRCT* prPrioCRC)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    char buf[200];\n" \
  "    int4 lg_ecrit = 0;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"On passe dans l'ecriture du fichier de conflit \\n\"));\n" \
  "    strcpy(&buf[0], \"SCG\");\n" \
  "    strcat(buf, \"|\");\n" \
  "    strcat(buf, doc->parution_id);\n" \
  "    strcat(buf, \"|\");\n" \
  "    strcat(buf, doc->value.numero_client);\n" \
  "    strcat(buf, \"|\");\n" \
  "    /* source prioritaire pour le bloc */\n" \
  "    strcat(buf, givrListCRC.trEltList[aiRg].acTpdsob);\n" \
  "    strcat(buf, \"|\");\n" \
  "    strcat(buf, givrListCRC.trEltList[aiRg].acEtab);\n" \
  "    prPrioCRC->concatNotPriorityCriteria(buf);\n" \
  "    lg_ecrit = strlen(buf);\n" \
  "    buf[lg_ecrit] = SEPARE_LIGNE;\n" \
  "    buf[lg_ecrit + 1] = LINE_FEED;\n" \
  "    buf[lg_ecrit + 2] = '\\0';\n" \
  "    lg_ecrit += 2;\n" \
  "    /* ecriture du contenu dans le fichier de sortie */\n" \
  "    iIntRet = (int4)fwrite(buf, lg_ecrit, 1, GIVfDescFicCFLT);\n" \
  "\n" \
  "    if (1 != iIntRet)\n" \
  "    {\n" \
  "        /* probleme d'ecriture */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Probleme d'ecriture de conflit [%s]\\n\", doc->parution_id));\n" \
  "        iCodRet = GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givTriGeoIns\n" \
  " *\n" \
  " * But : Tri des codes géographiques par inscription\n" \
  " *\n" \
  " * Description :\n" \
  " * Fonction de tri des réponses en fonction d'un critère qui précise l'ordre\n" \
  " * de priorité des tris\n" \
  " *\n" \
  " * Portabilité : sûrement portable\n" \
  " *\n" \
  " * Interface :\n" \
  " *\n" \
  " *  Paramètres :\n" \
  " *\n" \
  " *  Valeurs retournées :\n" \
  " *\n" \
  " *  Erreurs :\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Jan/29/2008  (mb)\n" \
  " *\n" \
  " * Modification   (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givTriGeoIns(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour interne */\n" \
  "    int4 iGeoArr, iGeoArrInst, iGeoLoc, iGeoDept, iGeoReg;\n" \
  "    int4 i, j, k, q;\n" \
  "    int4 pipe;\n" \
  "    char tcCoddep[3 + 1];\n" \
  "    char tcCodloc[5 + 1];\n" \
  "    char tcLocfus[5 + 1];\n" \
  "    /* Initialisation des variables locales */\n" \
  "    iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    /* une seule installation traitée avec éventuellement plusieurs arr */\n" \
  "\n" \
  "    if ((0 != strlen(doc->value.rubriques.depact)) && (0 != strlen(doc->value.rubriques.locact)))\n" \
  "    {\n" \
  "        /* utilisation des données d'activité */\n" \
  "        strcpy(doc->value.inscription[0].cCoddep, doc->value.rubriques.depact);\n" \
  "        strcpy(doc->value.inscription[0].cCodloc, doc->value.rubriques.locact);\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(doc->value.inscription[0].cCoddep))\n" \
  "    {\n" \
  "        (void)strcpy(tcCoddep, doc->value.inscription[0].cCoddep);\n" \
  "\n" \
  "        if (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc))\n" \
  "            (void)strcpy(tcCodloc, doc->value.inscription[0].cCodloc);\n" \
  "        else\n" \
  "            (void)strcpy(tcCodloc, givcLocIndf);\n" \
  "    }\n" \
  "    else if ((0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp(givcDepFictif, doc->value.inscription[0].cDeppar)))\n" \
  "    {\n" \
  "        (void)strcpy(tcCoddep, doc->value.inscription[0].cDeppar);\n" \
  "\n" \
  "        if (0 != strcmp(givcLocFictive, doc->value.inscription[0].cLocpar))\n" \
  "            (void)strcpy(tcCodloc, doc->value.inscription[0].cLocpar);\n" \
  "        else\n" \
  "            (void)strcpy(tcCodloc, givcLocIndf);\n" \
  "    }\n" \
  "\n" \
  "    (void)strcpy(tcLocfus, doc->value.inscription[0].cLocFus);\n" \
  "    givrListInst.iNbr = 1;\n" \
  "    givrListInst.trEltRangList[0] = 0;\n" \
  "    strcpy(givrListInst.trEltList[0].dep, tcCoddep);\n" \
  "    strcpy(givrListInst.trEltList[0].loc, tcCodloc);\n" \
  "    strcpy(givrListInst.trEltList[0].arr, \"99\");\n" \
  "    givrListInst.trEltList[0].iGeoReg = 99;\n" \
  "    givrListInst.trEltList[0].iGeoDept = 99;\n" \
  "    givrListInst.trEltList[0].iGeoLoc = 99;\n" \
  "    givrListInst.trEltList[0].iGeoArr = 99;\n" \
  "    givrListInst.trEltList[0].iRangTri = (int4)0;\n" \
  "\n" \
  "    if (0 != strlen(doc->value.rubriques.arract))\n" \
  "        strcpy(givrListInst.trEltList[0].arr, doc->value.rubriques.arract);\n" \
  "    else if (0 != strlen(doc->value.inscription[0].adresse.arrondissement))\n" \
  "        strcpy(givrListInst.trEltList[0].arr, doc->value.inscription[0].adresse.arrondissement);\n" \
  "\n" \
  "    if (0 != strlen(doc->value.inscription[0].cLocFus))\n" \
  "    {\n" \
  "        memcpy(&givrListInst.trEltList[givrListInst.iNbr], &givrListInst.trEltList[0], sizeof(GivrEltListTEpj));\n" \
  "        (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].loc, doc->value.inscription[0].cLocFus);\n" \
  "        givrListInst.trEltRangList[givrListInst.iNbr] = givrListInst.iNbr;\n" \
  "        givrListInst.iNbr++;\n" \
  "    }\n" \
  "\n" \
  "    givrListInst.iNbrTot = givrListInst.iNbr;\n" \
  "    iGeoArrInst = GIV::giv_INIT_ARR;\n" \
  "\n" \
  "    for (i = 0; i < givrListParu.iNbr; i++)\n" \
  "    {\n" \
  "        /* comparaison Parution/Installation */\n" \
  "        iGeoReg = 99;\n" \
  "        iGeoDept = 99;\n" \
  "        iGeoLoc = 99;\n" \
  "        iGeoArr = 99;\n" \
  "        k = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "        if ((0 == strcmp(doc->value.inscription[0].cReg, givrListParu.trEltList[k].reg)) || (0 == strcmp(doc->value.inscription[0].cAncReg, givrListParu.trEltList[k].reg)))\n" \
  "        {\n" \
  "            /* même région */\n" \
  "            iGeoReg = GIV::giv_REG;\n" \
  "\n" \
  "            if (0 == strcmp(tcCoddep, givrListParu.trEltList[k].dep))\n" \
  "            {\n" \
  "                iGeoDept = GIV::giv_DEPT;\n" \
  "\n" \
  "                if ((0 == strcmp(tcCodloc, givrListParu.trEltList[k].loc)) || (0 == strcmp(tcLocfus, givrListParu.trEltList[k].loc)))\n" \
  "                {\n" \
  "                    /* inscription locale */\n" \
  "                    iGeoLoc = GIV::giv_LOC;\n" \
  "                    /* inscription locale : arr */\n" \
  "\n" \
  "                    for (j = 0; ((j < givrListInst.iNbr) && (0 == strcmp(tcCodloc, givrListParu.trEltList[k].loc))); j++)\n" \
  "                    {\n" \
  "                        if ((0 != strcmp(\"99\", givrListInst.trEltList[j].arr)) && ((int4)GIV::GIXCodeOK != givrListParu.trEltList[k].iZU))\n" \
  "                            iGeoArrInst = GIV::giv_ARR;\n" \
  "\n" \
  "                        if (0 == strcmp(givrListInst.trEltList[j].arr, givrListParu.trEltList[k].arr))\n" \
  "                            break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (givrListInst.iNbr != j)\n" \
  "                    {\n" \
  "                        /* même arrondissement */\n" \
  "                        /* inscription locale : arr */\n" \
  "                        if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                            iGeoArr = GIV::giv_ARR;\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        /* arr inst != arr paru */\n" \
  "                        /* différents arrondissements */\n" \
  "                        if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                            iGeoArr = GIV::giv_LOC;\n" \
  "\n" \
  "                        /* inscription locale : arr extra */\n" \
  "                    }\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    /* inscription départementale */\n" \
  "                    /* loc inst != loc paru */\n" \
  "                    /* différentes localités */\n" \
  "                    iGeoLoc = GIV::giv_DEPT;\n" \
  "\n" \
  "                    if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                        iGeoArr = GIV::giv_DEPT;\n" \
  "\n" \
  "                    /* inscription dept : loc extra */\n" \
  "                }\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* inscription extra départementale */\n" \
  "                iGeoDept = GIV::giv_EXTL;\n" \
  "                iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "                if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                    iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "                /* inscription régionale */\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* différentes régions */\n" \
  "            /* inscription extra départementale */\n" \
  "            iGeoDept = GIV::giv_EXTL;\n" \
  "            iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (0 != strcmp(\"99\", givrListParu.trEltList[k].arr))\n" \
  "                iGeoArr = GIV::giv_EXTL;\n" \
  "\n" \
  "            /* inscription extra-régionale */\n" \
  "            iGeoReg = GIV::giv_EXTL;\n" \
  "        }\n" \
  "\n" \
  "        /* pas d'arrondissement pour le pôle de zone urbaine */\n" \
  "        if (0 == strcmp(\"00\", givrListParu.trEltList[k].arr))\n" \
  "            iGeoArr = 99;\n" \
  "\n" \
  "        if (0 == strcmp(\"999\", givrListParu.trEltList[k].dep))\n" \
  "        {\n" \
  "            /* ancienne région : seule la parution sur région est validée */\n" \
  "            iGeoDept = GIV::giv_DFT;\n" \
  "            iGeoLoc = GIV::giv_DFT;\n" \
  "            iGeoArr = GIV::giv_DFT;\n" \
  "        }\n" \
  "\n" \
  "        /* Validation iGeo */\n" \
  "        /* changement de reg */\n" \
  "        givrListParu.trEltList[k].iGeoReg = iGeoReg;\n" \
  "        /* changement de dept */\n" \
  "        givrListParu.trEltList[k].iGeoDept = iGeoDept;\n" \
  "        /* changement de loc */\n" \
  "        givrListParu.trEltList[k].iGeoLoc = iGeoLoc;\n" \
  "        /* changement d'arr */\n" \
  "        givrListParu.trEltList[k].iGeoArr = iGeoArr;\n" \
  "    }\n" \
  "\n" \
  "    /* changement d'arr instal */\n" \
  "    for (j = 0; j < givrListInst.iNbr; j++)\n" \
  "    {\n" \
  "        if (0 != strcmp(\"99\", givrListInst.trEltList[j].arr))\n" \
  "            givrListInst.trEltList[j].iGeoArr = iGeoArrInst;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" Inscription [%s],[%s],[%s],[%s]\\n\", doc->value.inscription[0].cReg, doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc,\n" \
  "                             doc->value.inscription[0].cArrond));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Parution-Installation Inscription [%d],[%d]\\n\", givrListParu.iNbr, givrListInst.iNbr));\n" \
  "    /* Retourner sans erreur */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  :giv_close_fichier_sortie ()                                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : Fermeture du fichier de sortie                                 */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 giv_fermeture_fichier_sortie(char** buf_pos_in, char* blocid)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    char* buf_pos;\n" \
  "    int4 lg_a_ecrire;\n" \
  "    char tcNumMvt[GXWLgIdDonnees];\n" \
  "    char* pcVersion = NULL;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"On passe dans l'ecriture du fichier de sortie \\n\"));\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    lg_a_ecrire = strlen(GIVBuffTest);\n" \
  "\n" \
  "    if ((0 != lg_a_ecrire) && (NULL != GIVfDescFicMCD) && ((int4)GIV::GIXCodeOK != giviCodRetEcr) && ((int4)GIV::GIXCodeOK == giviEnrich))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur : bloc %s\\n\", blocid));\n" \
  "        /* Pas d'écriture buffer de cas de test : débordement */\n" \
  "        GIVBuffTest[0] = '\\0';\n" \
  "    }\n" \
  "    else if ((0 != lg_a_ecrire) && (NULL != GIVfDescFicMCD) && ((int4)GIV::GIXCodeOK == giviEnrich))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Ecriture de BuffTest %d\\n\", lg_a_ecrire));\n" \
  "        /* Ecriture buffer de cas de test */\n" \
  "        iIntRet = (int4)fwrite(GIVBuffTest, lg_a_ecrire, 1, GIVfDescFicMCD);\n" \
  "        GIVBuffTest[0] = '\\0';\n" \
  "    }\n" \
  "\n" \
  "    if (((int4)GIV::GIXCodeOK == giviClose) && (NULL != GIVfDescFicMCD))\n" \
  "    {\n" \
  "        /* Initialisation pointeur */\n" \
  "        buf_pos = GIVBuffXML;\n" \
  "        /* Calcul de la longueur a ecrire */\n" \
  "        lg_a_ecrire = giv_ecrit_fin_noeud(&buf_pos, \"documents\");\n" \
  "        /* ecriture de l'enregistrement dans le fichier de sortie */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Taille du buff a ecrire dans le fic XML : %d\\n\", lg_a_ecrire));\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iIntRet = (int4)fwrite(GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);\n" \
  "        /* fichier rempli */\n" \
  "        iIntRet = fclose(GIVfDescFicMCD);\n" \
  "\n" \
  "        if (iIntRet != (int4)GIV::GWCCodeOK)\n" \
  "        {\n" \
  "            /* probleme de fermeture de fichier */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Probleme de fermeture de fichier \\n\"));\n" \
  "            iCodRet = GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        GIVfDescFicMCD = NULL;\n" \
  "\n" \
  "        if (NULL != GIVfDescFicCFLT)\n" \
  "        {\n" \
  "            iIntRet = fclose(GIVfDescFicCFLT);\n" \
  "\n" \
  "            if (iIntRet != (int4)GIV::GWCCodeOK)\n" \
  "            {\n" \
  "                /* probleme de fermeture de fichier */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Probleme de fermeture de fichier \\n\"));\n" \
  "                iCodRet = GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GIVfDescFicCFLT = NULL;\n" \
  "\n" \
  "        if (NULL != GIVfDescFicETB)\n" \
  "        {\n" \
  "            iIntRet = fclose(GIVfDescFicETB);\n" \
  "\n" \
  "            if (iIntRet != (int4)GIV::GWCCodeOK)\n" \
  "            {\n" \
  "                /* probleme de fermeture de fichier */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Probleme de fermeture de fichier \\n\"));\n" \
  "                iCodRet = GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GIVfDescFicETB = NULL;\n" \
  "        GIViCommit = (int4)GIV::GIXCodeOK;\n" \
  "        giviClose = (int4)GIV::GIXCodeKO;\n" \
  "        /* Effacement du buffer */\n" \
  "        GIVBuffXML[0] = '\\0';\n" \
  "\n" \
  "        if ((0 == strcmp(givRecreerCD, GIXcNomIntf)) && (0 != strcmp(GIXcValUrg, GWZUrgent)))\n" \
  "        {\n" \
  "            /* Construction chaine de marquage reprise */\n" \
  "            (void)sprintf(tcNumMvt, \"%d-%s\", giviNumFic, nom_bloc_ref);\n" \
  "            pcVersion = strchr(pcVersionInsFour[0], (char)'.');\n" \
  "            pcVersion++;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Bloc reprise [%s]\\n\", tcNumMvt));\n" \
  "            /* Sauvegarde chaine de version dans referentiel */\n" \
  "            iIntRet = GHHModiVersionIeinscDest(GIXcDepartement, GIXcNomIntf, pcVersion, (char*)NULL, tcNumMvt, GIXcNomDest);\n" \
  "\n" \
  "            if ((int4)GIV::GWZKo == iIntRet)\n" \
  "            {\n" \
  "                /* Erreur mise a jour donnees de version */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Erreur GHHModiVersionIeinsc ...\\n\"));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givInitBlocParution ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Initialisation de la structure d'un bloc                       */\n" \
  "/*             XML a vide, avant réut                                         */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : la structure XML d'un bloc                                     */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givInitBlocParution(GYBrDOCUMENTEpj* doc)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    /* Effacement de la zone de donnees */\n" \
  "    memset(doc, 0, sizeof(*doc));\n" \
  "    giviNbParentPart = 0;\n" \
  "    return (iCodRet);\n" \
  "} /* Fin IniBloc de parution */\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction :  givMefPnom\n" \
  " *\n" \
  " * But : Mise en forme du champ prénom\n" \
  " *\n" \
  " * Description :\n" \
  " * Cette fonction récupère les initilaes du champ prénom de l'inscription\n" \
  " *\n" \
  " *---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Fev/07/2007  (mb)\n" \
  " *\n" \
  " * Modification (MMM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "static int4 givMefPnom(char* aprPrenom, char* aprInit)\n" \
  "{\n" \
  "    /* code retour des fonctions appelées */\n" \
  "    int4 iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Prénom obtenu dans l'inscription */\n" \
  "    char* pcPrenom;\n" \
  "    /* Mot courant du prénom ( spécifique au traitement des initiales ) */\n" \
  "    char tcMotCrt[128];\n" \
  "    int4 iLgPrenom, iBoucle;\n" \
  "    /* Récupération du prénom complet */\n" \
  "    pcPrenom = aprPrenom;\n" \
  "    iLgPrenom = 0;\n" \
  "\n" \
  "    /* Parcours de la liste des prénoms */\n" \
  "    while (1 == sscanf(pcPrenom, \"%s\", tcMotCrt))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Mot : %s\\n\", tcMotCrt));\n" \
  "\n" \
  "        /* A la recherche du mot de liaison 'et'  qui doit figurer dans la réponse */\n" \
  "        /* Le blanc séparateur est systématiquement placé avant le mot de liaison */\n" \
  "        if ((0 == strcmp(\"ET\", tcMotCrt)) || (0 == strcmp(\"et\", tcMotCrt)) || (0 == strcmp(\"Et\", tcMotCrt)))\n" \
  "        {\n" \
  "            aprInit[iLgPrenom++] = ' ';\n" \
  "            memcpy(&aprInit[iLgPrenom], tcMotCrt, strlen(tcMotCrt));\n" \
  "            iLgPrenom += strlen(tcMotCrt);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Ou à la recherche de l'initiale qui peut être double dans le cas */\n" \
  "            /* des prénoms composés ( séparés par un tiret )                    */\n" \
  "            /* Le blanc séparateur est rajouté devant l'initiale sauf s'il      */\n" \
  "            /* s'agit du premier prénom de la liste traîté                      */\n" \
  "            /* Par contre les initiales d'un prénom composé sont collées        */\n" \
  "            iLgPrenom = strlen(aprInit);\n" \
  "\n" \
  "            if (0 != iLgPrenom)\n" \
  "            {\n" \
  "                aprInit[iLgPrenom] = ' ';\n" \
  "                iLgPrenom++;\n" \
  "            }\n" \
  "\n" \
  "            aprInit[iLgPrenom] = tcMotCrt[0];\n" \
  "            iLgPrenom++;\n" \
  "\n" \
  "            for (iBoucle = 0; iBoucle < strlen(tcMotCrt); iBoucle++)\n" \
  "            {\n" \
  "                if ('-' == tcMotCrt[iBoucle])\n" \
  "                {\n" \
  "                    aprInit[iLgPrenom] = tcMotCrt[iBoucle + 1];\n" \
  "                    iLgPrenom++;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            aprInit[iLgPrenom] = 0;\n" \
  "        }\n" \
  "\n" \
  "        /* Passage au prénom suivant dans la liste */\n" \
  "        if (0 != strcmp(pcPrenom, tcMotCrt))\n" \
  "            pcPrenom += strlen(tcMotCrt) + 1;\n" \
  "        else\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    /* Retourner sans erreur */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefDonneesGestion ()                                        */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble \"donnees de gestion\"               */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefDonneesGestion(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    char* pcFour = NULL;\n" \
  "    char cBufSeq[sizeof(GIVvInscrip.acNoselo) + 1 + sizeof(GIVvInscrip.acNosels)] = \"\";\n" \
  "    int4 i;\n" \
  "    /* initialisation données locales */\n" \
  "    (void)memset(&cBufSeq[0], 0x00, sizeof(cBufSeq));\n" \
  "    /* on a qu'une inscription dans doc */\n" \
  "    indice = 0;\n" \
  "    /* Encodage du numero national */\n" \
  "    /* le numéro de téléphone est transmis en clair */\n" \
  "    (void)strcpy(givcNumnat, cNumnat);\n" \
  "    strcpy(doc->value.inscription[indice].val_num, givcNumnat);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"No nat : %s\\n\", doc->value.inscription[indice].val_num));\n" \
  "    /* Encodage du numero de LO */\n" \
  "    usLgchamp = strlen(cNumlo);\n" \
  "    /* cas des numlo d'authentification = fournisseur, passer en numérique */\n" \
  "    pcFour = strstr(GIVcListeFour, cNumlo);\n" \
  "\n" \
  "    if (NULL != pcFour)\n" \
  "    {\n" \
  "        /* c'est une inscription d'authentification */\n" \
  "        (void)sprintf(cNumlo, \"%04d\", ((pcFour - &GIVcListeFour[0]) / (GYBIeinscLgNumlo + 1)) + 1);\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du No Lo  */\n" \
  "    strcpy(doc->value.inscription[indice].val_lo, cNumlo);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"No Lo : %s\\n\", doc->value.inscription[indice].val_lo));\n" \
  "    /* Encodage du numero de LS */\n" \
  "    strcpy(doc->value.inscription[indice].val_ls, cNumls);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"No Ls : %s\\n\", doc->value.inscription[indice].val_ls));\n" \
  "    /* nature de l'inscription */\n" \
  "    doc->cNature = GIVvInscrip.acNature;\n" \
  "\n" \
  "    if (giv_cLEUR == doc->value.inscription[indice].val_num[0])\n" \
  "    {\n" \
  "        /* partenaire leurre (origine PJ) */\n" \
  "        doc->cNature = doc->value.inscription[indice].val_num[0];\n" \
  "    }\n" \
  "\n" \
  "    /* partenaire */\n" \
  "    doc->cIndPart = GIVvInscrip.acIndPart[0];\n" \
  "\n" \
  "    /* Encodage du numero de bloc précédent */\n" \
  "    if (0 == strcmp(cBlocidPrec, \"C0001\"))\n" \
  "    {\n" \
  "        /* chgmt 888 vers 999 */\n" \
  "        strcpy(doc->value.inscription[indice].trace_bloc, \"888-999\");\n" \
  "    }\n" \
  "    else if (0 == strcmp(cBlocidPrec, \"C0002\"))\n" \
  "    {\n" \
  "        /* chgmt 999 vers 888 */\n" \
  "        strcpy(doc->value.inscription[indice].trace_bloc, \"999-888\");\n" \
  "    }\n" \
  "    else\n" \
  "        strcpy(doc->value.inscription[indice].trace_bloc, cBlocidPrec);\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"No Bloc trace : %s\\n\", doc->value.inscription[indice].trace_bloc));\n" \
  "    /* Encodage de la clé de tri */\n" \
  "    strcpy(doc->value.inscription[indice].val_tri1, &GIVvInscrip.acCleTri1[1]);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Cle tri : %s\\n\", doc->value.inscription[indice].val_tri1));\n" \
  "    strcpy(doc->value.inscription[indice].val_tri2, &GIVvInscrip.acCleTri2[1]);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Cle tri : %s\\n\", doc->value.inscription[indice].val_tri2));\n" \
  "\n" \
  "    /* Encodage du numero de regroupement */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sNogrouI && (boolen != 2))\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].val_grp, GIVvInscrip.acNogrou);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"No grp : %s\\n\", doc->value.inscription[indice].val_grp));\n" \
  "    }\n" \
  "    else if (boolen == 2)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].val_grp, nogrou_sav);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"No grp 2eme choix: %s\\n\", doc->value.inscription[indice].val_grp));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du numero de sequence LO/LS les deux concatenes */\n" \
  "    if (0 == strcmp(GIVvInscrip.acNumls, \"0000\"))\n" \
  "        strcpy(doc->value.inscription[indice].val_seq, GIVvInscrip.acNoselo);\n" \
  "    else\n" \
  "    {\n" \
  "        strcpy(&doc->value.inscription[indice].val_seq[1], GIVvInscrip.acNosels);\n" \
  "        doc->value.inscription[indice].val_seq[0] = '0';\n" \
  "    }\n" \
  "\n" \
  "    strcpy(doc->value.inscription[indice].val_seqLO, GIVvInscrip.acNoselo);\n" \
  "    strcpy(doc->value.inscription[indice].val_seqLS, GIVvInscrip.acNosels);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"No seq : %s\\n\", doc->value.inscription[indice].val_seq));\n" \
  "    strcpy(doc->value.inscription[indice].val_lols, cNumlo);\n" \
  "    strcpy(doc->value.inscription[indice].val_lslo, cNumls);\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Sortie de la fonction givMefDonneesGestion*/\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefDonneesParution ()                                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble \"donnees de parution\"              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Dec/03/2002 mb) : ajout de mention tarifaire                 */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefDonneesParution(GYBrDOCUMENTEpj* doc, int4 aIndice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    /* numéro de client */\n" \
  "    char givcNumcli[8];\n" \
  "    int4 i, j, k, lg;\n" \
  "    int4 iDept, iArrond;\n" \
  "    int4 iRes, iAcc;\n" \
  "    int4 indice;\n" \
  "    GYBrIapartT rPart;\n" \
  "    /* on a qu'une inscription dans doc */\n" \
  "    indice = 0;\n" \
  "    /* indicateur de protection */\n" \
  "    strcpy(doc->value.intitule.protection, GIVvInscrip.acInprot);\n" \
  "    /* indicateur de support */\n" \
  "    strcpy(doc->value.intitule.support, GIVvInscrip.acInsupp);\n" \
  "\n" \
  "    /* Encodage de la designation de ligne  */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sDesignI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.designation_ligne, GIVvInscrip.acDesign);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"DESIGNATION DE LIGNE : %s\\n\", doc->value.inscription[indice].moyen_de_com.designation_ligne));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du numero de client  */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sNumcliI)\n" \
  "    {\n" \
  "        memcpy(&givcNumcli[0], &GIVvInscrip.acNumcli[4], 8);\n" \
  "        givcNumcli[8] = '\\0';\n" \
  "        strcpy(doc->value.numero_client, givcNumcli);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"No_CLIENT : %s\\n\", doc->value.numero_client));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du numero du code etablissement */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sEtabI)\n" \
  "    {\n" \
  "        strcpy(doc->value.a_classer.etab_dc, GIVvInscrip.acEtab);\n" \
  "        strcpy(doc->value.a_classer.etab, GIVvInscrip.acEtab);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ETAB : %s\\n\", doc->value.a_classer.etab));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du numero de code SIRET */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sSiretI)\n" \
  "    {\n" \
  "        strcpy(doc->value.a_classer.siret, GIVvInscrip.acSiret);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"SIRET : %s\\n\", doc->value.a_classer.siret));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du numero du code NAF */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sNafI)\n" \
  "    {\n" \
  "        for (i = 0; i < (strlen(GIVvInscrip.acNaf) - 1); i++)\n" \
  "        {\n" \
  "            if (0 == isdigit(GIVvInscrip.acNaf[i]))\n" \
  "                break;\n" \
  "        }\n" \
  "\n" \
  "        if ((i != (strlen(GIVvInscrip.acNaf) - 1)) || ('A' > GIVvInscrip.acNaf[strlen(GIVvInscrip.acNaf) - 1]) || ('Z' < GIVvInscrip.acNaf[strlen(GIVvInscrip.acNaf) - 1]))\n" \
  "            strcpy(doc->value.a_classer.naf, \"\");\n" \
  "        else\n" \
  "            strcpy(doc->value.a_classer.naf, GIVvInscrip.acNaf);\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"NAF : %s\\n\", doc->value.a_classer.naf));\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nb IaPart : %d\\n\", GIViNbTupleIapart));\n" \
  "\n" \
  "    if (0 != GIViNbTupleIapart)\n" \
  "    {\n" \
  "        iRes = 0;\n" \
  "        iAcc = 0;\n" \
  "\n" \
  "        for (i = 0; i < GIViNbTupleIapart; i++)\n" \
  "        {\n" \
  "            if ((0 == strcmp(GIVtrPart[i].acOriPart, giv_RESA)) && (NULL == strstr(givtcFourPart, GIVtrPart[i].acOriPart)))\n" \
  "                iRes = 1;\n" \
  "            else if ((0 == strcmp(GIVtrPart[i].acOriPart, giv_ACCO)) && (NULL == strstr(givtcFourPart, GIVtrPart[i].acOriPart)))\n" \
  "            {\n" \
  "                iAcc = 1;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        j = 0;\n" \
  "\n" \
  "        for (i = 0; i < GIViNbTupleIapart; i++)\n" \
  "        {\n" \
  "            if ((NULL == strstr(givtcFourPart, GIVtrPart[i].acOriPart)) || ('0' != GIVvInscrip.acIndPart[0]))\n" \
  "            {\n" \
  "                if ((1 == iAcc) && GIVtrPart[i].isOriginePartenaires(giv_RESA, giv_EXPD))\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Part resa/expd non prioritaire : %s, %s\\n\", GIVtrPart[i].acRefPart, doc->value.a_classer.etab));\n" \
  "                    continue;\n" \
  "                }\n" \
  "                else if ((1 == iRes) && (0 == strcmp(GIVtrPart[i].acOriPart, giv_EXPD)))\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Part expd non prioritaire : %s, %s\\n\", GIVtrPart[i].acRefPart, doc->value.a_classer.etab));\n" \
  "                    continue;\n" \
  "                }\n" \
  "                else if (0 == strcmp(GIVtrPart[i].acOriPart, rPart.acOriPart))\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Part expd double non prioritaire : %s, %s\\n\", GIVtrPart[i].acRefPart, doc->value.a_classer.etab));\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                strcpy(rPart.acOriPart, GIVtrPart[i].acOriPart);\n" \
  "                doc->value.a_classer.trpart[j].iForPJDC = GIV::GIXCodeKO;\n" \
  "                strcpy(doc->value.a_classer.trpart[j].rpart, GIVtrPart[i].acRefPart);\n" \
  "                strcat(doc->value.a_classer.trpart[j].rpart, GIVtrPart[i].acOriPart);\n" \
  "                strcpy(doc->value.a_classer.trpart[j].parent, GIVtrPart[i].acParentRefPart);\n" \
  "\n" \
  "                for (k = 0; (k < givNbPart && (0 != strcmp(GIVtrPart[i].acOriPart, givTabPart[k].tcPart))); k++)\n" \
  "                    ;\n" \
  "\n" \
  "                if (givNbPart == k)\n" \
  "                    doc->value.a_classer.trpart[j].prod[0] = '\\0';\n" \
  "                else\n" \
  "                    strcpy(doc->value.a_classer.trpart[j].prod, givTabPart[k].tcProd);\n" \
  "\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Part : %s,%s\\n\", doc->value.a_classer.trpart[j].rpart, doc->value.a_classer.trpart[j].prod));\n" \
  "                j++;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GIViNbTupleIapart = j;\n" \
  "    }\n" \
  "\n" \
  "    doc->value.a_classer.iNbPart = GIViNbTupleIapart;\n" \
  "\n" \
  "    /* Encodage du titre de civilite */\n" \
  "    if ((int4)GIV::GYBok != GIVvIndInscrip.sCivilI)\n" \
  "    {\n" \
  "        /* valeur par defaut : pas de titre de civilité */\n" \
  "        (void)strcpy(GIVvInscrip.acCivil, \" \");\n" \
  "    }\n" \
  "\n" \
  "    (void)strcpy(doc->value.intitule.civilite, GIVvInscrip.acCivil);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"CIVILITE : %s\\n\", doc->value.intitule.civilite));\n" \
  "\n" \
  "    /* Encodage de la denomination */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sDenomI)\n" \
  "    {\n" \
  "        strcpy(doc->value.intitule.denomination, GIVvInscrip.acDenom);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"DENOMINATION : %s\\n\", doc->value.intitule.denomination));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du complement de denomination */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sComplnI)\n" \
  "    {\n" \
  "        strcpy(doc->value.intitule.complement_denomination, GIVvInscrip.acCompln);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"COMP_DENOMINATION : %s\\n\", doc->value.intitule.complement_denomination));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du sigle */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sSigleI)\n" \
  "    {\n" \
  "        strcpy(doc->value.intitule.sigle, GIVvInscrip.acSigle);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"SIGLE : %s\\n\", doc->value.intitule.sigle));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage des mots determinants */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMotdetI)\n" \
  "    {\n" \
  "        strcpy(doc->value.intitule.mots_determinants, GIVvInscrip.acMotdet);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MOTDET : %s\\n\", doc->value.intitule.mots_determinants));\n" \
  "    }\n" \
  "\n" \
  "    /* Obtention de la longueur du champ \"mots_determinants\" */\n" \
  "    lg = strlen(doc->value.intitule.mots_determinants);\n" \
  "\n" \
  "    /* Dans le cas où il y a un contenu, il faut retirer les caractères \"<\" éventuellement présents à la fin */\n" \
  "    /* Il s'agit de la règle : Reg_Sel_3 */\n" \
  "    if (lg > 0)\n" \
  "    {\n" \
  "        for (i = lg - 1; i >= 0; i--)\n" \
  "        {\n" \
  "            if (doc->value.intitule.mots_determinants[i] == '<')\n" \
  "                doc->value.intitule.mots_determinants[i] = 0x00;\n" \
  "            else\n" \
  "                break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Fin de règle : Reg_Sel_3 */\n" \
  "\n" \
  "    /* Encodage du prenom */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sPrenomI)\n" \
  "    {\n" \
  "        memset(buf_concat, 0, sizeof(buf_concat));\n" \
  "        iIntRet = givMefPnom(GIVvInscrip.acPrenom, buf_concat);\n" \
  "\n" \
  "        if (givcParuIPre != GIVvInscrip.acInparu[givcIndInitPre])\n" \
  "            strcpy(doc->value.intitule.prenom, GIVvInscrip.acPrenom);\n" \
  "        else\n" \
  "            strcpy(doc->value.intitule.prenom, buf_concat);\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"PRENOM : %s\\n\", doc->value.intitule.prenom));\n" \
  "        strcpy(doc->value.intitule.initiale, buf_concat);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"INITIALE : %s\\n\", doc->value.intitule.initiale));\n" \
  "    }\n" \
  "\n" \
  "    /* Date de fin de parution */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sDateFinParutI)\n" \
  "    {\n" \
  "        memcpy(&doc->value.intitule.datefinparu[0], &GIVvInscrip.acDateFinParut[0], 2);\n" \
  "        doc->value.intitule.datefinparu[2] = '/';\n" \
  "        memcpy(&doc->value.intitule.datefinparu[3], &GIVvInscrip.acDateFinParut[2], 2);\n" \
  "        doc->value.intitule.datefinparu[5] = '/';\n" \
  "        memcpy(&doc->value.intitule.datefinparu[6], &GIVvInscrip.acDateFinParut[4], 4);\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMenDomI)\n" \
  "    {\n" \
  "        strcpy(doc->value.rubriques.mendom, GIVvInscrip.acMenDom);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MenDom  : ... %s\\n\", doc->value.rubriques.mendom));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMentionI)\n" \
  "    {\n" \
  "        strcpy(doc->value.intitule.mention, GIVvInscrip.acMention);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Mention  : ... %s\\n\", doc->value.intitule.mention));\n" \
  "    }\n" \
  "\n" \
  "    if (((int4)GIV::GYBok == GIVvIndInscrip.sDepActI) && ((int4)GIV::GYBok == GIVvIndInscrip.sLocActI))\n" \
  "    {\n" \
  "        strcpy(doc->value.rubriques.depact, GIVvInscrip.acDepAct);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"DepAct  : ... %s\\n\", doc->value.rubriques.depact));\n" \
  "        strcpy(doc->value.rubriques.locact, GIVvInscrip.acLocAct);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LocAct  : ... %s\\n\", doc->value.rubriques.locact));\n" \
  "        strcpy(doc->value.rubriques.arract, \"\");\n" \
  "        iDept = atoi(GIVvInscrip.acDepAct);\n" \
  "\n" \
  "        switch (iDept)\n" \
  "        {\n" \
  "        case (int4)75:\n" \
  "        {\n" \
  "            if (0 == memcmp(&GIVvInscrip.acLocAct[0], \"056\", (int4)3))\n" \
  "            {\n" \
  "                /* Paris */\n" \
  "                iArrond = atoi(&GIVvInscrip.acLocAct[3]);\n" \
  "\n" \
  "                if (((int4)1 <= iArrond) && ((int4)20 >= iArrond))\n" \
  "                {\n" \
  "                    strcpy(doc->value.rubriques.arract, &GIVvInscrip.acLocAct[3]);\n" \
  "                    strcpy(&doc->value.rubriques.locact[3], \"00\");\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            break;\n" \
  "        }\n" \
  "\n" \
  "        case (int4)69:\n" \
  "        {\n" \
  "            if (0 == memcmp(&GIVvInscrip.acLocAct[0], \"123\", (int4)3))\n" \
  "            {\n" \
  "                /* Lyon */\n" \
  "                iArrond = atoi(&GIVvInscrip.acLocAct[3]);\n" \
  "\n" \
  "                if (((int4)1 <= iArrond) && ((int4)9 >= iArrond))\n" \
  "                {\n" \
  "                    strcpy(doc->value.rubriques.arract, &GIVvInscrip.acLocAct[3]);\n" \
  "                    strcpy(&doc->value.rubriques.locact[3], \"00\");\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            break;\n" \
  "        }\n" \
  "\n" \
  "        case (int4)13:\n" \
  "        {\n" \
  "            if (0 == memcmp(&GIVvInscrip.acLocAct[0], \"055\", (int4)3))\n" \
  "            {\n" \
  "                /* Marseille */\n" \
  "                iArrond = atoi(&GIVvInscrip.acLocAct[3]);\n" \
  "\n" \
  "                if (((int4)1 <= iArrond) && ((int4)16 >= iArrond))\n" \
  "                {\n" \
  "                    strcpy(doc->value.rubriques.arract, &GIVvInscrip.acLocAct[3]);\n" \
  "                    strcpy(&doc->value.rubriques.locact[3], \"00\");\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            break;\n" \
  "        }\n" \
  "\n" \
  "        default:\n" \
  "        {\n" \
  "            /* Pas d'arrondissement */\n" \
  "            strcpy(doc->value.rubriques.arract, \"\");\n" \
  "            break;\n" \
  "        }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du compte utilisateur  */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sCteUtilI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.cteutil, GIVvInscrip.acCteUtil);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"CteUtil : %s\\n\", doc->value.inscription[indice].moyen_de_com.cteutil));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du nom supplémentaire  */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sNomSuppI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.nomsupplement, GIVvInscrip.acNomSupp);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Nom Supplémentaire : %s\\n\", doc->value.inscription[indice].moyen_de_com.nomsupplement));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du masque numnat  */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMskNumI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.msknum, GIVvInscrip.acMskNum);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MskNum : %s\\n\", doc->value.inscription[indice].moyen_de_com.msknum));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du masque mel  */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMskMelI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.mskmel, GIVvInscrip.acMskMel);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MskMel : %s\\n\", doc->value.inscription[indice].moyen_de_com.mskmel));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage de la date de maj CU  */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sDatCUI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.datcu, GIVvInscrip.acDatCU);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MskMel : %s\\n\", doc->value.inscription[indice].moyen_de_com.datcu));\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefMoyensTelecom ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble \"moyens de telecommunication\"      */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Nov/13/1997 lgu) : V2 ajout adresse e-mail                   */\n" \
  "/* Modification (Fev/03/1998 lgu) : Adresse internet dans numero d'appel      */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefMoyensTelecom(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    nat1 ucCompteur, ucCptTmp;\n" \
  "    int1 cDrapeauNumap = (int1)GIV::GWCCodeKO;\n" \
  "    /* on a qu'une inscription dans doc */\n" \
  "    indice = 0;\n" \
  "\n" \
  "    /* Encodage du code produit */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sCodproI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.code_produit, GIVvInscrip.acCodpro);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"CODE_PRODUIT : %s\\n\", doc->value.inscription[indice].moyen_de_com.code_produit));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du code produit étendu*/\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sCodproEtenduI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.code_produit_etd, GIVvInscrip.acCodproEtendu);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"CODE_PRODUIT_ETD : %s\\n\", doc->value.inscription[indice].moyen_de_com.code_produit_etd));\n" \
  "    }\n" \
  "\n" \
  "    /* groupe des données associées au produit lui même */\n" \
  "    /**-------------------------------------------------*/\n" \
  "    /* Encodage du numero  */\n" \
  "    strcpy(doc->value.inscription[indice].moyen_de_com.numero, GIVvInscrip.acNumnat);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"NUMERO : %s\\n\", doc->value.inscription[indice].moyen_de_com.numero));\n" \
  "\n" \
  "    /* numap pour monaco */\n" \
  "    if ((!strcmp(GIVvInscrip.acCoddep, giv_DEP_MONACO) && !strcmp(GIVvInscrip.acCodloc, giv_LOC_MONACO)) || (!strcmp(GIVvInscrip.acDeppar, giv_DEP_MONACO) && !strcmp(GIVvInscrip.acLocpar, giv_LOC_MONACO)\n" \
  "            && (0 == strcmp(\"0000\", GIVvInscrip.acNumls))))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"traitement particulier monaco pour numap\\n\"));\n" \
  "        cDrapeauNumap = (int1)GIV::GWCCodeKO;\n" \
  "\n" \
  "        /* Encodage du numero d'appel du produit */\n" \
  "        if ((GIVvInscrip.acNumnat[0] == '0') && ((GIVvInscrip.acNumnat[1] == '6') || (GIVvInscrip.acNumnat[1] == '8') || (GIVvInscrip.acNumnat[1] == '9')))\n" \
  "        {\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sNumapI)\n" \
  "            {\n" \
  "                /* Numap present on envoi telquel */\n" \
  "                strcpy(givcNumnat, GIVvInscrip.acNumap);\n" \
  "                cDrapeauNumap = (int1)GIV::GWCCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sNumapI)\n" \
  "            {\n" \
  "                /* Numap present */\n" \
  "                ucCompteur = 0;\n" \
  "\n" \
  "                for (ucCptTmp = 0; ucCptTmp < strlen(GIVvInscrip.acNumap); ucCptTmp++)\n" \
  "                {\n" \
  "                    if ((GIVvInscrip.acNumap[ucCptTmp] >= '0') && (GIVvInscrip.acNumap[ucCptTmp] <= '9'))\n" \
  "                        ucCompteur++;\n" \
  "                }\n" \
  "\n" \
  "                if (ucCompteur == 10)\n" \
  "                {\n" \
  "                    /* on met au format « 00 377 » + un espace + les 8 derniers\n" \
  "                     chiffres du Numap en conservant leur mise en forme */\n" \
  "                    ucCompteur = 0;\n" \
  "\n" \
  "                    for (ucCptTmp = strlen(GIVvInscrip.acNumap) - 1; (int1)ucCptTmp >= 0; ucCptTmp--)\n" \
  "                    {\n" \
  "                        if ((GIVvInscrip.acNumap[ucCptTmp] >= '0') && (GIVvInscrip.acNumap[ucCptTmp] <= '9'))\n" \
  "                            ucCompteur++;\n" \
  "\n" \
  "                        if (ucCompteur == 8)\n" \
  "                            break;\n" \
  "                    }\n" \
  "\n" \
  "                    sprintf(givcNumnat, \"00 377 %s\", GIVvInscrip.acNumap + ucCptTmp);\n" \
  "                    cDrapeauNumap = (int1)GIV::GWCCodeOK;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    /* on transmet le numap telquel. */\n" \
  "                    strcpy(givcNumnat, GIVvInscrip.acNumap);\n" \
  "                    cDrapeauNumap = (int1)GIV::GWCCodeOK;\n" \
  "                }\n" \
  "            }\n" \
  "            else if ('0' == GIVvInscrip.acIndPart[0])\n" \
  "            {\n" \
  "                /*  Numap absent -> on met au format '00 377 XX XX XX XX' */\n" \
  "                sprintf(givcNumnat, \"00 377 %c%c %c%c %c%c %c%c\", GIVvInscrip.acNumnat[2], GIVvInscrip.acNumnat[3], GIVvInscrip.acNumnat[4], GIVvInscrip.acNumnat[5], GIVvInscrip.acNumnat[6], GIVvInscrip.acNumnat[7],\n" \
  "                        GIVvInscrip.acNumnat[8], GIVvInscrip.acNumnat[9]);\n" \
  "                cDrapeauNumap = (int1)GIV::GWCCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (cDrapeauNumap == GIV::GWCCodeOK)\n" \
  "        {\n" \
  "            strcpy(doc->value.inscription[indice].moyen_de_com.numero_parution, givcNumnat);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"NUMERO_PARUTION : %s\\n\", doc->value.inscription[indice].moyen_de_com.numero_parution));\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Encodage du numero parution */\n" \
  "        if ((int4)GIV::GYBok == GIVvIndInscrip.sNumapI)\n" \
  "        {\n" \
  "            (void)strcpy(givcNumnat, GIVvInscrip.acNumap);\n" \
  "\n" \
  "            if (((int4)GIV::GYBok == GIVvIndInscrip.sCoddepI) && (0 == memcmp(GIVvInscrip.acCoddep, givcDepPays, strlen(GIVvInscrip.acCoddep))))\n" \
  "            {\n" \
  "                /* recherche de l'indicatif du pays */\n" \
  "                iIntRet = GIVLectureTabPAYS(GIVvInscrip.acCoddep, GIVvInscrip.acCodloc);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                {\n" \
  "                    /* concaténation de l'indicatif avec le numap */\n" \
  "                    (void)sprintf(givcNumnat, \"00 %s %s\", GIVvPays.acIndpays, GIVvInscrip.acNumap);\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            strcpy(doc->value.inscription[indice].moyen_de_com.numero_parution, givcNumnat);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"NUMERO_PARUTION : %s\\n\", doc->value.inscription[indice].moyen_de_com.numero_parution));\n" \
  "        }\n" \
  "        else if ('0' == GIVvInscrip.acIndPart[0])\n" \
  "        {\n" \
  "            if (((int4)GIV::GYBok == GIVvIndInscrip.sCoddepI) && (0 == memcmp(GIVvInscrip.acCoddep, givcDepPays, strlen(GIVvInscrip.acCoddep))))\n" \
  "            {\n" \
  "                (void)sprintf(givcNumnat, \"%c%c %c%c %c%c %c%c %c%c\", GIVvInscrip.acNumnat[0], GIVvInscrip.acNumnat[1], GIVvInscrip.acNumnat[2], GIVvInscrip.acNumnat[3], GIVvInscrip.acNumnat[4],\n" \
  "                              GIVvInscrip.acNumnat[5], GIVvInscrip.acNumnat[6], GIVvInscrip.acNumnat[7], GIVvInscrip.acNumnat[8], GIVvInscrip.acNumnat[9]);\n" \
  "                /* recherche de l'indicatif du pays */\n" \
  "                iIntRet = GIVLectureTabPAYS(GIVvInscrip.acCoddep, GIVvInscrip.acCodloc);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                {\n" \
  "                    /* concatination de l'indicatif avec le numnat */\n" \
  "                    (void)sprintf(givcNumnat, \"00 %s %c%c %c%c %c%c %c%c %c%c\", GIVvPays.acIndpays, GIVvInscrip.acNumnat[0], GIVvInscrip.acNumnat[1], GIVvInscrip.acNumnat[2], GIVvInscrip.acNumnat[3],\n" \
  "                                  GIVvInscrip.acNumnat[4], GIVvInscrip.acNumnat[5], GIVvInscrip.acNumnat[6], GIVvInscrip.acNumnat[7], GIVvInscrip.acNumnat[8], GIVvInscrip.acNumnat[9]);\n" \
  "                }\n" \
  "\n" \
  "                strcpy(doc->value.inscription[indice].moyen_de_com.numero_parution, givcNumnat);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"NUMERO_PARUTION : %s\\n\", doc->value.inscription[indice].moyen_de_com.numero_parution));\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du mnemonique (telex ou teletel) */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMnemonI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.mnemonique, GIVvInscrip.acMnemon);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MNEMONIC : %s\\n\", doc->value.inscription[indice].moyen_de_com.mnemonique));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du libellé d'url */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sLibUrlI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.url, GIVvInscrip.acLibUrl);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"URL : %s\\n\", doc->value.inscription[indice].moyen_de_com.url));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sIpaysI)\n" \
  "    {\n" \
  "        /* Encodage de l'indicatif du pays */\n" \
  "        strcpy(doc->value.inscription[indice].adresse.ipays, GIVvInscrip.acIpays);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"IPAYS : %s\\n\", doc->value.inscription[indice].adresse.ipays));\n" \
  "    }\n" \
  "\n" \
  "    /* groupe des données associées à la dénumérotation */\n" \
  "    /**-------------------------------------------------*/\n" \
  "\n" \
  "    /* Encodage de l'adresse e-mail */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sEmailI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.email, GIVvInscrip.acEmail);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"EMAIL : %s\\n\", doc->value.inscription[indice].moyen_de_com.email));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du tiliphone mobile */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sEquitelI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.equiptel, GIVvInscrip.acEquitel);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"EQUIPTEL : %s\\n\", doc->value.inscription[indice].moyen_de_com.equiptel));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du tiliphone mobile */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sServtelI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.servtel, GIVvInscrip.acServtel);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"SERVTEL : %s\\n\", doc->value.inscription[indice].moyen_de_com.servtel));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du tiliphone mobile */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sTarifartI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.tarifart, GIVvInscrip.acTarifart);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"TARIFART : %s\\n\", doc->value.inscription[indice].moyen_de_com.tarifart));\n" \
  "    }\n" \
  "\n" \
  "    /* Encodage du tiliphone mobile */\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sOpeartI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.operateur, GIVvInscrip.acOpeart);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"OPERATEUR : %s\\n\", doc->value.inscription[indice].moyen_de_com.operateur));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sNumRGI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.numrg, GIVvInscrip.acNumRG);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"NUMRG : %s\\n\", doc->value.inscription[indice].moyen_de_com.numrg));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sIndRGI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.indrg, GIVvInscrip.acIndRG);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"INDRG : %s\\n\", doc->value.inscription[indice].moyen_de_com.indrg));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sLaMarqueI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.lamarque, GIVvInscrip.acLaMarque);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LAMARQUE : %s\\n\", doc->value.inscription[indice].moyen_de_com.lamarque));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sLaQualiteI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.laqualite, GIVvInscrip.acLaQualite);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LAQUALITE : %s\\n\", doc->value.inscription[indice].moyen_de_com.laqualite));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMntarifI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.tarif_exact, GIVvInscrip.acMntarif);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"TARIF_EXACT : %s\\n\", doc->value.inscription[indice].moyen_de_com.tarif_exact));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sCatNumI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].moyen_de_com.catnum, GIVvInscrip.acCatNum);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"CAT_NUM : %s\\n\", doc->value.inscription[indice].moyen_de_com.catnum));\n" \
  "    }\n" \
  "\n" \
  "    /* réconciliation GPP */\n" \
  "    doc->cIndRecGpp = GIVvInscrip.acIndRecGpp[0];\n" \
  "    doc->cTypRecGpp = GIVvInscrip.acTypRecGpp[0];\n" \
  "    GWTTrace(GWT_NIV_FONCT,\n" \
  "             (\"Rec GPP : %c,%c\\n\", doc->cIndRecGpp, doc->cTypRecGpp));\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    /* Sortie de la fonction givMefMoyensTelecom */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefLieuParution ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble \"lieu de parution\"      */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 givMefLieuParution(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    /* indicateur de parution */\n" \
  "    strcpy(doc->value.intitule.parution, GIVvInscrip.acInparu);\n" \
  "\n" \
  "    /* groupe des données définissant le lieu de parution */\n" \
  "    /**---------------------------------------------------*/\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sDepparI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[0].cDeppar, GIVvInscrip.acDeppar);\n" \
  "        strcpy(doc->value.inscription[0].cLocpar, GIVvInscrip.acLocpar);\n" \
  "        strcpy(doc->value.inscription[0].cArrpar, GIVvInscrip.acArrpar);\n" \
  "\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur encodage TLV Deppar */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur sur encodage TLV du code departement de parution ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == GIVvIndInscrip.sLocparI)\n" \
  "        {\n" \
  "            if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur encodage TLV Locpar */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur sur encodage TLV du code localite de parution ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction givMefLieuParution */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefLieuInstallation ()                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble \"lieu d'installation\"              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Avr/25/2000 mb) : prise en compte des départment et localité */\n" \
  "/*                                 d'installation                             */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Jan/10/2001 tw) : geocodage des inscriptions                 */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "int4 givMefLieuInstallation(GYBrDOCUMENTEpj* doc, int4 aindice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 iRetCP;\n" \
  "    int4 i, j, iIdx = 0; /* Index de boucle */\n" \
  "    char cBufAdrnr[sizeof(GIVvInscrip.acAdrnr) + 1 + sizeof(GIVvLocrep.acCodpos) + 1 + sizeof(GIVvLocrep.acLibloc)] = \"\";\n" \
  "    char cBufLibVoie[sizeof(GIVvInscrip.acTypvoi) + 1 + sizeof(GIVvInscrip.acLibvoi)] = \"\";\n" \
  "    char cAdrnr[sizeof(GIVvInscrip.acAdrnr) + 1] = \"\";\n" \
  "    char* pcChaine = NULL;\n" \
  "    char* pcCp = NULL;\n" \
  "    char tcLibTypVoi[ GYBPetvoiLgLibvoi + 1];\n" \
  "    int4 iLocIns = 0;\n" \
  "    int4 indice = 0;\n" \
  "    int4 iFaireGeocod; /* si GIV::GWZOk on geocode */\n" \
  "    double dWgsLon;\n" \
  "    double dWgsLat;\n" \
  "    /* initialisation données locales */\n" \
  "    (void)memset(&cBufAdrnr[0], 0x00, sizeof(cBufAdrnr));\n" \
  "    (void)memset(&cBufLibVoie[0], 0x00, sizeof(cBufLibVoie));\n" \
  "    (void)memset(&cAdrnr[0], 0x00, sizeof(cAdrnr));\n" \
  "    (void)memset(&tcLibTypVoi[0], ' ', GYBPetvoiLgLibvoi);\n" \
  "    tcLibTypVoi[GYBPetvoiLgLibvoi] = '\\0';\n" \
  "\n" \
  "    /* Mise en forme de \"ensemble de\" lieux d'installation */\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sCoddepI)\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[0].cCoddep, GIVvInscrip.acCoddep);\n" \
  "        strcpy(doc->value.inscription[0].cCodloc, GIVvInscrip.acCodloc);\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sArrondI)\n" \
  "        strcpy(doc->value.inscription[0].cArrond, GIVvInscrip.acArrond);\n" \
  "\n" \
  "    /* indicateur de parution */\n" \
  "    strcpy(doc->value.inscription[0].adresse.parution, doc->value.intitule.parution);\n" \
  "    /* rang d'adresse non initialisé */\n" \
  "    doc->value.inscription[indice].adresse.irangadr = (int4)0;\n" \
  "\n" \
  "    /* gestion de l'adresse */\n" \
  "    /**---------------------*/\n" \
  "    if (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr])\n" \
  "    {\n" \
  "        /* parution de l'adresse */\n" \
  "        if (givcParuSSNo != GIVvInscrip.acInparu[givcIndParuAdr])\n" \
  "        {\n" \
  "            /* parution du numéro dans la voie */\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sNovoieI)\n" \
  "            {\n" \
  "                /* Encodage du numero dans la voie */\n" \
  "                strcpy(doc->value.inscription[indice].adresse.numero_voie, GIVvInscrip.acNovoie);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"NoVOIE : %s\\n\", doc->value.inscription[indice].adresse.numero_voie));\n" \
  "\n" \
  "                if ((int4)GIV::GYBok == GIVvIndInscrip.sCplnovI)\n" \
  "                {\n" \
  "                    /* Encodage du complement de numero dans la voie */\n" \
  "                    strcpy(doc->value.inscription[indice].adresse.complt_num_voie, GIVvInscrip.acCplnov);\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"COMP_NoVOIE : %s\\n\", doc->value.inscription[indice].adresse.complt_num_voie));\n" \
  "\n" \
  "                    switch (GIVvInscrip.acCplnov[0])\n" \
  "                    {\n" \
  "                    /** Ne pas traduire A B C et D */\n" \
  "                    case '1':\n" \
  "                        break;\n" \
  "\n" \
  "                    case '2':\n" \
  "                        strcpy(doc->value.inscription[indice].adresse.lib_complt_num_voie, \"Bis\");\n" \
  "                        break;\n" \
  "\n" \
  "                    case '3':\n" \
  "                        strcpy(doc->value.inscription[indice].adresse.lib_complt_num_voie, \"Ter\");\n" \
  "                        break;\n" \
  "\n" \
  "                    case '4':\n" \
  "                        strcpy(doc->value.inscription[indice].adresse.lib_complt_num_voie, \"Quater\");\n" \
  "                        break;\n" \
  "\n" \
  "                    case '5':\n" \
  "                        strcpy(doc->value.inscription[indice].adresse.lib_complt_num_voie, \"Quinquies\");\n" \
  "                        break;\n" \
  "\n" \
  "                    case '6':\n" \
  "                        strcpy(doc->value.inscription[indice].adresse.lib_complt_num_voie, \"Sexto\");\n" \
  "                        break;\n" \
  "\n" \
  "                    default:\n" \
  "                        strcpy(doc->value.inscription[indice].adresse.lib_complt_num_voie, doc->value.inscription[indice].adresse.complt_num_voie);\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"LIB_COMP_NoVOIE : %s\\n\", doc->value.inscription[indice].adresse.lib_complt_num_voie));\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == GIVvIndInscrip.sCodvoiI)\n" \
  "        {\n" \
  "            /* Encodage du code voie repertoriee */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.code_voie, GIVvInscrip.acCodvoi);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"CODE_VOIE : %s\\n\", doc->value.inscription[indice].adresse.code_voie));\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == GIVvIndInscrip.sLibvoiI)\n" \
  "        {\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sTypvoiI)\n" \
  "            {\n" \
  "                /** 14/09/1998 LGU ANO_xxxx Traduire le type de voie en fonction du contenu de GYTtabPetvoi */\n" \
  "                /* Traduire le type de voie */\n" \
  "                iCodRet = GIVTradTypvoi(GIVvInscrip.acTypvoi, tcLibTypVoi);\n" \
  "\n" \
  "                if (GIV::GWCCodeOK != iCodRet)\n" \
  "                {\n" \
  "                    strcpy(tcLibTypVoi, GIVvInscrip.acTypvoi);\n" \
  "                    iCodRet = GIV::GWCCodeOK;\n" \
  "                }\n" \
  "\n" \
  "                /* Suppression des blancs éventuels derrière le type de voie*/\n" \
  "                for (iIdx = (strlen(tcLibTypVoi) - 1); (0 <= iIdx) && (tcLibTypVoi[iIdx] == GIV_CHAR_BLANC); iIdx--)\n" \
  "                    tcLibTypVoi[iIdx] = '\\0';\n" \
  "\n" \
  "                /* type de voie */\n" \
  "                strcpy(doc->value.inscription[indice].adresse.type_voie, tcLibTypVoi);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"TYPE_VOIE : %s\\n\", doc->value.inscription[indice].adresse.type_voie));\n" \
  "                /* Concaténation du type de voie et du libellé de voie */\n" \
  "                (void)sprintf(&cBufLibVoie[0], \"%s %s\", tcLibTypVoi, GIVvInscrip.acLibvoi);\n" \
  "                /** 14/09/1998 LGU ANO_xxxx fin de modif */\n" \
  "            }\n" \
  "            else\n" \
  "                (void)strcpy(&cBufLibVoie[0], GIVvInscrip.acLibvoi);\n" \
  "\n" \
  "            /* Encodage du libelle de voie */\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sCodvoiI)\n" \
  "            {\n" \
  "                /* voie répertoriée */\n" \
  "                strcpy(doc->value.inscription[indice].adresse.lib_code_voie, cBufLibVoie);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"LIBEL_VOIE : %s\\n\", doc->value.inscription[indice].adresse.lib_code_voie));\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* voie non répertoriée */\n" \
  "                strcpy(doc->value.inscription[indice].adresse.libel_voie, cBufLibVoie);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"LIBEL_VOIE : %s\\n\", doc->value.inscription[indice].adresse.libel_voie));\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* Si le libelle de voie n'est pas dans le référentiel inscription */\n" \
  "            /* s'il existe un code voie repertoriee */\n" \
  "            /*   le recuperer dans la table PEVREP*/\n" \
  "            /* S'il n'y a pas de code voie, ne rien faire */\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sCodvoiI)\n" \
  "            {\n" \
  "                iIntRet = GIVLectureTabPEVREP(GIVvInscrip.acDeppar, GIVvInscrip.acLocpar, GIVvInscrip.acCodvoi);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                {\n" \
  "                    /* Si le libelle de voie a ete trouve dans la table voies repertoriees */\n" \
  "                    /* le charger dans le mouvement CD */\n" \
  "                    if (0 != GIViNbTuplePevrep)\n" \
  "                    {\n" \
  "                        /* Encodage du libelle de voie */\n" \
  "                        strcpy(doc->value.inscription[indice].adresse.lib_code_voie, GIVvVoirep.acLibvoi);\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"LIBEL_VOIE : %s\\n\", doc->value.inscription[indice].adresse.lib_code_voie));\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        /* Si le libelle de voie repertoriee n'existe pas dans la base PEVREP, generer une signalisation */\n" \
  "                        GWTTrace(GWT_NIV_BIZAR, (\"Libelle de voie repertoriee non trouve ...\\n\"));\n" \
  "                    }\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    /* La consultation de la table voie repertoriee s'est mal passee */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Erreur sur acces a la table voie repertoriee  ...\\n\"));\n" \
  "                    iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == GIVvIndInscrip.sEnsbatI)\n" \
  "        {\n" \
  "            /* Encodage de l'ensemble batiment */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.ensemble_batiment, GIVvInscrip.acEnsbat);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ENSEMBLE_BAT : %s\\n\", doc->value.inscription[indice].adresse.ensemble_batiment));\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GYBok == GIVvIndInscrip.sLieuaeI)\n" \
  "        {\n" \
  "            /* Encodage du lieu dit AE*/\n" \
  "            strcpy(doc->value.inscription[indice].adresse.lieue_ae, GIVvInscrip.acLieuae);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"LIEU_AE : %s\\n\", doc->value.inscription[indice].adresse.lieue_ae));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) || ((0 == strcmp(GIVtcGeneSSAdr, \"OUI\")) && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])))\n" \
  "    {\n" \
  "        /* traitement du champ adresse non répertoriée */\n" \
  "        /**--------------------------------------------*/\n" \
  "        /* on récupère l'adrnr de l'inscription si elle existe */\n" \
  "        if (((int4)GIV::GYBok == GIVvIndInscrip.sAdrnrI) && ((0 == strcmp(\"0000\", cNumls)) || (0 == strcmp(GIVtcGeneCP, \"OUI\"))))\n" \
  "        {\n" \
  "            /* recherche de l'existence d'un code postal dans l'adresse */\n" \
  "            iIntRet = GIV::GWCCodeKO;\n" \
  "            iRetCP = GIV::GWCCodeOK;\n" \
  "            (void)strcpy(cAdrnr, GIVvInscrip.acAdrnr);\n" \
  "            pcChaine = strtok(cAdrnr, \" \");\n" \
  "\n" \
  "            while ((NULL != pcChaine) && (GIV::GWCCodeKO == iIntRet))\n" \
  "            {\n" \
  "                if ((sizeof(GIVvLocrep.acCodpos) - 1) == strlen(pcChaine))\n" \
  "                {\n" \
  "                    for (iIdx = 0; isdigit(pcChaine[iIdx]); iIdx++)\n" \
  "                        ;\n" \
  "\n" \
  "                    if ((sizeof(GIVvLocrep.acCodpos) - 1) == iIdx)\n" \
  "                        iIntRet = GIV::GWCCodeOK;\n" \
  "                }\n" \
  "\n" \
  "                /* passer au mot suivant */\n" \
  "                if ((GIV::GWCCodeOK == iRetCP) && (GIV::GWCCodeOK == iIntRet))\n" \
  "                    pcCp = pcChaine + strlen(pcChaine) + 1;\n" \
  "                else\n" \
  "                {\n" \
  "                    iRetCP = GIV::GWCCodeKO;\n" \
  "                    pcChaine = strtok(NULL, \" \");\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* recherche du CODDEP dans l'adresse */\n" \
  "            if (NULL != strstr(GIVvInscrip.acAdrnr, GIVvInscrip.acCoddep))\n" \
  "                iIntRet = GIV::GWCCodeOK;\n" \
  "\n" \
  "            GIVvInscrip.searchCODDEPInAdress(iIntRet, GIV::GWCCodeOK, cBufAdrnr, GIVtcGeneCP, iRetCP, cNumls, pcCp, cAdrnr, &GIVvIndInscrip, &GIVvLocrep, GIV::GYBok);\n" \
  "\n" \
  "            \n" \
  "        }\n" \
  "        else if (((int4)GIV::GYBok == GIVvIndInscrip.sAdrnrI) && (0 != strcmp(\"0000\", cNumls)))\n" \
  "        {\n" \
  "            /* adrnr déjà formaté */\n" \
  "            (void)strcpy(cBufAdrnr, GIVvInscrip.acAdrnr);\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != strlen(cBufAdrnr)) && (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))\n" \
  "        {\n" \
  "            /* Encodage de l'adresse non repertoriee */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.adrnr, cBufAdrnr);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ADRNR : %s\\n\", doc->value.inscription[indice].adresse.adrnr));\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* pas Encodage de l'adresse non repertoriee */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.adrnr, \"\");\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ADRNR : %s\\n\", doc->value.inscription[indice].adresse.adrnr));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sArrondI)\n" \
  "    {\n" \
  "        if (((0 == strcmp(GIVtcGeneSSAdr, \"OUI\")) && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])) || (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))\n" \
  "        {\n" \
  "            /* Encodage du code arrondissement */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.arrondissement, GIVvInscrip.acArrond);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ARROND : %s\\n\", doc->value.inscription[indice].adresse.arrondissement));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* les informations BP, code cedex et libellé cedex sont conditionnées par */\n" \
  "    /* presence du code cedex et un libellé existe en association avec ce code */\n" \
  "    if (((int4)GIV::GYBok == GIVvIndInscrip.sCodcdxI) && ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) || ((0 == strcmp(GIVtcGeneSSAdr, \"OUI\"))\n" \
  "            && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))))\n" \
  "    {\n" \
  "        /* Recuperation du libelle cedex */\n" \
  "        iIntRet = GIVLectureTabPECDEX(GIVvInscrip.acCodcdx);\n" \
  "\n" \
  "        if ((int4)0 < GIViNbTuplePecdex)\n" \
  "        {\n" \
  "            /* on a un tuple libellé cedex */\n" \
  "            /* Encodage du code Cedex */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.code_cedex, GIVvInscrip.acCodcdx);\n" \
  "            strcpy(doc->value.inscription[indice].adresse.lib_cedex, GIVvCedex.acLibcdx);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"CODE_CEDEX : %s\\n\", doc->value.inscription[indice].adresse.code_cedex));\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* le code postal n'a de sens qu'en absence du code cedex */\n" \
  "        if (((int4)GIV::GYBok == GIVvIndInscrip.sCodposI) && ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) || ((0 == strcmp(GIVtcGeneSSAdr, \"OUI\"))\n" \
  "                && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))))\n" \
  "        {\n" \
  "            /* Encodage du code postal */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.code_postal, GIVvInscrip.acCodpos);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"CODE_POSTAL : %s\\n\", doc->value.inscription[indice].adresse.code_postal));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (((int4)GIV::GYBok == GIVvIndInscrip.sBoiteI) && (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))\n" \
  "    {\n" \
  "        /* Encodage du numero de la boite postale */\n" \
  "        strcpy(doc->value.inscription[indice].adresse.boite, GIVvInscrip.acBoite);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"BOITE : %s\\n\", doc->value.inscription[indice].adresse.boite));\n" \
  "    }\n" \
  "\n" \
  "    /* localité d'installation */\n" \
  "    if (((0 == strcmp(GIVtcGeneSSAdr, \"OUI\")) && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr])) || (givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]))\n" \
  "    {\n" \
  "        if ((int4)GIV::GYBok == GIVvIndInscrip.sCoddepI)\n" \
  "        {\n" \
  "            sprintf(doc->value.inscription[indice].adresse.instal, \"%s%s\", GIVvInscrip.acCoddep, GIVvInscrip.acCodloc);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sArrondI)\n" \
  "                iIntRet = GIVLectureArrPELREP(GIVvInscrip.acCoddep, GIVvInscrip.acCodloc, GIVvInscrip.acArrond);\n" \
  "            else\n" \
  "                iIntRet = GIVLectureTabPELREP(GIVvInscrip.acCoddep, GIVvInscrip.acCodloc);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            sprintf(doc->value.inscription[indice].adresse.instal, \"%s%s\", GIVvInscrip.acDeppar, GIVvInscrip.acLocpar);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok == GIVvIndInscrip.sArrondI)\n" \
  "                iIntRet = GIVLectureArrPELREP(GIVvInscrip.acDeppar, GIVvInscrip.acLocpar, GIVvInscrip.acArrond);\n" \
  "            else\n" \
  "                iIntRet = GIVLectureTabPELREP(GIVvInscrip.acDeppar, GIVvInscrip.acLocpar);\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "        {\n" \
  "            /* libellé de localité */\n" \
  "            strcpy(doc->value.inscription[indice].adresse.libinstal, GIVvLocrep.acLibloc);\n" \
  "        }\n" \
  "        else if (0 == strcmp(GIVvInscrip.acLocpar, givcLocFictive))\n" \
  "            strcpy(doc->value.inscription[indice].adresse.libinstal, \"LOCALITE FICTIVE\");\n" \
  "\n" \
  "        if (GIVvIndInscrip.isActivityLocDep(GIV::GYBok, GIVtcGeneActiv,\"OUI\"))\n" \
  "        {\n" \
  "            if (0 != strlen(doc->value.rubriques.arract))\n" \
  "                iIntRet = GIVLectureArrPELREP(doc->value.rubriques.depact, doc->value.rubriques.locact, doc->value.rubriques.arract);\n" \
  "            else\n" \
  "                iIntRet = GIVLectureTabPELREP(doc->value.rubriques.depact, doc->value.rubriques.locact);\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "            {\n" \
  "                /* libellé de localité */\n" \
  "                strcpy(doc->value.inscription[indice].adresse.libinstact, GIVvLocrep.acLibloc);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"INSTAL : %s\\n\", doc->value.inscription[indice].adresse.instal));\n" \
  "\n" \
  "    if (((int4)GIV::GYBok != GIVvIndInscrip.sCodposI) && ((int4)GIV::GYBok != GIVvIndInscrip.sCodcdxI) && ((int4)GIV::GYBok != GIVvIndInscrip.sBoiteI) && (0 == strcmp(\"0000\", GIVvInscrip.acNumls))\n" \
  "            && ((givcParuSSAdr != GIVvInscrip.acInparu[givcIndParuAdr]) || ((0 == strcmp(GIVtcGeneSSAdr, \"OUI\")) && (givcParuSSAdr == doc->value.intitule.parution[givcIndParuAdr]))))\n" \
  "    {\n" \
  "        /* Encodage du code postal */\n" \
  "        strcpy(doc->value.inscription[indice].adresse.code_postal, GIVvLocrep.acCodpos);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"CODE_POSTAL LO : %s\\n\", doc->value.inscription[indice].adresse.code_postal));\n" \
  "    }\n" \
  "\n" \
  "    /* groupe de données de géocodage */\n" \
  "    /* ------------------------------ */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Valeurs de la rGeocod avant encodage: <iStatus=%d>,<tcX=%s>, <tcY=%s>, <tcQualite=%s>\\n\", GIVvGeocod.iStatus, GIVvGeocod.tcX, GIVvGeocod.tcY, GIVvGeocod.tcQualite));\n" \
  "    strcpy(doc->value.inscription[indice].adresse.geoloc.precision, GIVvGeocod.tcQualite);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"QUALITE : %s\\n\", doc->value.inscription[indice].adresse.geoloc.precision));\n" \
  "    strcpy(doc->value.inscription[indice].adresse.geoloc.precMappy, GIVvGeocod.tcPrecMappy);\n" \
  "\n" \
  "    if (GIVvGeocod.isStatus(GIVGeocodSEnvXYQ, GIVGeocodSEnvXY))\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[indice].adresse.geoloc.longitude, GIVvGeocod.tcLongitude);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LONGITUDE : %s\\n\", doc->value.inscription[indice].adresse.geoloc.longitude));\n" \
  "        strcpy(doc->value.inscription[indice].adresse.geoloc.latitude, GIVvGeocod.tcLatitude);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LATITUDE : %s\\n\", doc->value.inscription[indice].adresse.geoloc.latitude));\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LONGITUDE WGS : %s\\n\", doc->value.inscription[indice].adresse.geoloc.longitude));\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LATITUDE WGS : %s\\n\", doc->value.inscription[indice].adresse.geoloc.latitude));\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction givMefLieuInstallation */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefProfessionnel ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble \"professionnel\"                    */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefProfessionnel(GYBrDOCUMENTEpj* doc, int4 aindice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 i, giviInsertTLV = 0; /* indice de deplacement dans le tableau AN9 de depart */\n" \
  "    char givcAn9Courant[GYBPaprofLgCodan9 + 1] = givcR00000000;\n" \
  "    char givcOrigCourant[GYBIaprofLgOrigine + 1] = \"\" \"\";\n" \
  "    /* Initialisation du nombre d'An9 */\n" \
  "    char conf[50];\n" \
  "    nb_an9 = 0;\n" \
  "    nb_marque = 0;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" Entrer CodeAn9... %s\\n\"));\n" \
  "\n" \
  "    if (GIV::GIXCodeOK == (int1)GIVcPresenceAn9)\n" \
  "    {\n" \
  "        /* Mise en forme de l'ensemble \"critere professionnel\" */\n" \
  "        /* tant qu'il existe des elements dans le tableau des AN9 */\n" \
  "        giviInsertTLV = GIViNbTupleIaprof;\n" \
  "\n" \
  "        while (giviInsertTLV < GIViNbMaxTabAn9)\n" \
  "        {\n" \
  "            if ((0 != strcmp(givcAn9Courant, GIVtrProfIns[giviInsertTLV].acCodan8)) || (0 != strcmp(givcOrigCourant, GIVtrProfIns[giviInsertTLV].acOrigine)))\n" \
  "            {\n" \
  "                if (0 != memcmp(\"78\", GIVtrProfIns[giviInsertTLV].acCodan8, strlen(\"78\")))\n" \
  "                {\n" \
  "                    /* ne pas garder les rubriques \"rue commerçante\" */\n" \
  "                    if (MAX_AN9 == nb_an9)\n" \
  "                    {\n" \
  "                        /* probleme max AN9 atteint */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"probleme max AN9 atteint\"));\n" \
  "                        iCodRet = GIV::GIXCodeKO;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    /* Changement d'AN9, demarrage d'un critère professionnel */\n" \
  "                    /* préalablement on supprime les marques / spécialités  associées à l'AN9 précédent s'il est vide */\n" \
  "                    /* sous réserve que l'on ait déjà traité un AN9 */\n" \
  "                    strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, GIVtrProfIns[giviInsertTLV].acCodan8);\n" \
  "                    strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan8, GIVtrProfIns[giviInsertTLV].acCodInit);\n" \
  "                    strcpy(doc->value.rubriques.Tan9[nb_an9].nature, GIVtrProfIns[giviInsertTLV].acNature);\n" \
  "                    doc->value.rubriques.Tan9[nb_an9].orig = GIVtrProfIns[giviInsertTLV].acOrigine[0];\n" \
  "                    doc->value.rubriques.Tan9[nb_an9].paru = GIVtrProfIns[giviInsertTLV].acParuloc[0];\n" \
  "                    doc->value.rubriques.Tan9[nb_an9].recgpp = GIVtrProfIns[giviInsertTLV].acRecGpp[0];\n" \
  "                    doc->value.rubriques.Tan9[nb_an9].dnex = GIVtrProfIns[giviInsertTLV].acPjdc;\n" \
  "                    strcpy(doc->value.rubriques.Tan9[nb_an9].thematique, GIVtrProfIns[giviInsertTLV].thematique);\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" CodeAn9... %s\\n\", doc->value.rubriques.Tan9[nb_an9].val_codan9));\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" CodeAn8... %s\\n\", doc->value.rubriques.Tan9[nb_an9].val_codan8));\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" Nature... %s\\n\", doc->value.rubriques.Tan9[nb_an9].nature));\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" Paruloc... %c\\n\", doc->value.rubriques.Tan9[nb_an9].paru));\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" No_indice : ... %d\\n\", nb_an9));\n" \
  "                    nb_an9++;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* Memorisation du dernier AN9 traite */\n" \
  "            GIVtrProfIns[giviInsertTLV].memlastAN9(givcAn9Courant, givcOrigCourant);\n" \
  "            giviInsertTLV++;\n" \
  "        }\n" \
  "    }\n" \
  "    else if ('0' == GIVvInscrip.acIndPart[0])\n" \
  "    {\n" \
  "        if (MAX_AN9 == nb_an9)\n" \
  "        {\n" \
  "            /* probleme max AN9 atteint */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"probleme max AN9 atteint\"));\n" \
  "            iCodRet = GIV::GIXCodeKO;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* defaut absence de rubrique */\n" \
  "            strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, givcR00000000);\n" \
  "            strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan8, givcR000000);\n" \
  "            doc->value.rubriques.Tan9[nb_an9].paru = '0';\n" \
  "            doc->value.rubriques.Tan9[nb_an9].dnex = '0';\n" \
  "            doc->value.rubriques.Tan9[nb_an9].recgpp = '0';\n" \
  "            strcpy(doc->value.rubriques.Tan9[nb_an9].thematique, \"\");\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" CodeAn9... %s\\n\", doc->value.rubriques.Tan9[nb_an9].val_codan9));\n" \
  "            nb_an9++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((GIV::GIXCodeOK != (int1)GIVcPresenceAn9) && ('0' != GIVvInscrip.acIndPart[0]))\n" \
  "    {\n" \
  "        for (i = 0; i < GIViNbTupleIapart; i++)\n" \
  "        {\n" \
  "            (void)strcpy(givtcOriPart, GIVtrPart[i].acOriPart);\n" \
  "            (void)sprintf(conf, \"%s_%s\", \"GIV_AN9_PART\", GIVtrPart[i].acOriPart);\n" \
  "            iIntRet = GWTLireConf(conf, givtcAn9Part);\n" \
  "\n" \
  "            if (GIV::GWTok != iIntRet)\n" \
  "            {\n" \
  "                /* defaut absence de rubrique */\n" \
  "                (void)strcpy(givtcAn9Part, givcR00000000);\n" \
  "                (void)strcpy(givtcAn8Part, givcR000000);\n" \
  "            }\n" \
  "\n" \
  "            (void)sprintf(conf, \"%s_%s\", \"GIV_AN8_PART\", GIVtrPart[i].acOriPart);\n" \
  "            iIntRet = GWTLireConf(conf, givtcAn8Part);\n" \
  "\n" \
  "            if (MAX_AN9 == nb_an9)\n" \
  "            {\n" \
  "                /* probleme max AN9 atteint */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"probleme max AN9 atteint\"));\n" \
  "                iCodRet = GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, givtcAn9Part);\n" \
  "                strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan8, givtcAn8Part);\n" \
  "                doc->value.rubriques.Tan9[nb_an9].orig = '1';\n" \
  "                doc->value.rubriques.Tan9[nb_an9].paru = '0';\n" \
  "                doc->value.rubriques.Tan9[nb_an9].dnex = '0';\n" \
  "                doc->value.rubriques.Tan9[nb_an9].recgpp = '0';\n" \
  "                strcpy(doc->value.rubriques.Tan9[nb_an9].thematique, \"\");\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" CodeAn9 Part %s\\n\", doc->value.rubriques.Tan9[nb_an9].val_codan9));\n" \
  "                nb_an9++;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 == GIViNbTupleIapart)\n" \
  "        {\n" \
  "            /* defaut absence de rubrique */\n" \
  "            strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan9, givcR00000000);\n" \
  "            strcpy(doc->value.rubriques.Tan9[nb_an9].val_codan8, givcR000000);\n" \
  "            doc->value.rubriques.Tan9[nb_an9].paru = '0';\n" \
  "            doc->value.rubriques.Tan9[nb_an9].dnex = '0';\n" \
  "            doc->value.rubriques.Tan9[nb_an9].recgpp = '0';\n" \
  "            strcpy(doc->value.rubriques.Tan9[nb_an9].thematique, \"\");\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" CodeAn9... %s\\n\", doc->value.rubriques.Tan9[nb_an9].val_codan9));\n" \
  "            nb_an9++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    doc->value.rubriques.iNban9 = nb_an9;\n" \
  "\n" \
  "    /* Mise en place de la mention professionnelle : ODA payante prioritaire et 14D gratuite */\n" \
  "    /* dans deux champs différents */\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMenormI)\n" \
  "    {\n" \
  "        strcpy(doc->value.rubriques.mpg, GIVvInscrip.acMenorm);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MPG  : ... %s\\n\", doc->value.rubriques.mpg));\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == GIVvIndInscrip.sMenadjI)\n" \
  "    {\n" \
  "        strcpy(doc->value.rubriques.mogmoi, GIVvInscrip.acMenadj);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MOGMOI  : ... %s\\n\", doc->value.rubriques.mogmoi));\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction givMefProfessionnel */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefCRC ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble critère complémentaire             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefCRC(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet; /* Code retour de la fonction */\n" \
  "    int4 iIntRet; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch; /* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    int4 i; /* indice de boucle */\n" \
  "    int4 nb_crc;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPeCRCT* pvCrc;\n" \
  "    GYBrIndPeCRCT* pvIndCrc;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"givLectureCRC\\n\"));\n" \
  "    indice = 0;\n" \
  "    /* Initialisation du nombre de CRC */\n" \
  "    nb_crc = 0;\n" \
  "    iIntRet = givPreparerLectureCRC();\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur prepare curseur SQL */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur  crsLectureCRC ...\\n\"));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* Initialisation des variables locales */\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        /* Valorisation du pointeur vers la structure de description de la table PAYS */\n" \
  "        pvCrc = &GIVvCrc;\n" \
  "        pvIndCrc = &GIVvIndCrc;\n" \
  "        /* Valorisation du pointeur vers la structure de description */\n" \
  "        /*   du tableau de recuperation des crc */\n" \
  "        (void)memcpy(&pvCrc->acDepart[0], &doc->value.inscription[0].adresse.instal[0], strlen(GIVvInscrip.acDeppar));\n" \
  "        pvCrc->acDepart[strlen(GIVvInscrip.acDeppar)] = '\\0';\n" \
  "        (void)strcpy((char*)pvCrc->acNumloc, (const char*)&doc->value.inscription[0].adresse.instal[strlen(GIVvInscrip.acDeppar)]);\n" \
  "        (void)strcpy((char*)pvCrc->acNumnat, (const char*)GIVvInscrip.acNumnat);\n" \
  "\n" \
  "        for (i = 0; i < nb_an9; i++)\n" \
  "        {\n" \
  "            /* rubrique courante */\n" \
  "            (void)strcpy((char*)pvCrc->acCodan9, (const char*)doc->value.rubriques.Tan9[i].val_codan9);\n" \
  "            /* Ouverture curseur SQL (car requete type SELECT) */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureCRC\");\n" \
  "            EXEC SQL\n" \
  "            open crsLectureCRC\n" \
  "            using :pvCrc->acDepart,\n" \
  "            :pvCrc->acNumloc,\n" \
  "            :pvCrc->acNumnat,\n" \
  "            :pvCrc->acCodan9\n" \
  "            ;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                /* Erreur sur declaration curseur SQL */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Erreur OPEN crsLectureCRC ...\\n\"));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* Execution requete de denombrement (FETCH du curseur) */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "\n" \
  "                while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "                {\n" \
  "                    (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureCRC\");\n" \
  "                    EXEC SQL\n" \
  "                    fetch crsLectureCRC\n" \
  "                    into\n" \
  "                    :pvCrc->acCodCrc\n" \
  "                    :pvIndCrc->sCodCrcI,\n" \
  "                    :pvCrc->acLibCrc:pvIndCrc->sLibCrcI,\n" \
  "                    :pvCrc->acNavCrc:pvIndCrc->sNavCrcI\n" \
  "                    ;\n" \
  "                    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "                    /* Analyse du code retour SQL */\n" \
  "                    switch (iIntRet)\n" \
  "                    {\n" \
  "                    case (int4)GIV::GYBok:\n" \
  "                    {\n" \
  "                        strcpy(doc->value.crc.trCrc[nb_crc].acCodCrc, GIVvCrc.acCodCrc);\n" \
  "                        strcpy(doc->value.crc.trCrc[nb_crc].acLibCrc, GIVvCrc.acLibCrc);\n" \
  "                        strcpy(doc->value.crc.trCrc[nb_crc].acNavCrc, GIVvCrc.acNavCrc);\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\" CRC... %s ,%s ,%s\\n\", GIVvCrc.acCodCrc, GIVvCrc.acLibCrc, GIVvCrc.acNavCrc));\n" \
  "                        nb_crc++;\n" \
  "                        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "                        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    case (int4)GIV::GYBnodata:\n" \
  "                    {\n" \
  "                        /* la localite n'existe pas */\n" \
  "                        /* generer une signalisation */\n" \
  "                        indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    default:\n" \
  "                    {\n" \
  "                        /* la consultation de la base s'est mal passee */\n" \
  "                        GWTTrace(GWT_NIV_GRAVE, (\"Erreur execute rqtLectureCRC : [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "                        indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                        break;\n" \
  "                    }\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                /* Fermeture du curseur */\n" \
  "                (void)strcpy(vErreurSQL.acOrdre_sql, \"close crsLectureCRC\");\n" \
  "                EXEC SQL\n" \
  "                close crsLectureCRC;\n" \
  "                iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "                if ((int4)GIV::GYBok != iIntRet)\n" \
  "                {\n" \
  "                    /* Erreur sur fermeture curseur SQL */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Erreur CLOSE crsLectureCRC ...\\n\"));\n" \
  "                }\n" \
  "\n" \
  "                /* an9 suivant */\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    doc->value.crc.iNbCrc = nb_crc;\n" \
  "    /* Sortie de la fonction */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GIVLectureCRC\\n\"));\n" \
  "    /* Sortie de la fonction givMefCRC */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefPublicite ()                                             */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble \"publicite\"                        */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefPublicite(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    nat2 usSaveLgMod = 0;\n" \
  "    /* longueur d'un sous ensemble TLV module */\n" \
  "    nat2 usSaveLgNoy = 0;\n" \
  "    /* longueur d'un sous ensemble TLV noyau */\n" \
  "    nat2 usSaveLgMic = 0; /** -- V2 lgu 14/11/1997 -- */\n" \
  "    /* longueur d'un sous ensemble TLV objet micro */\n" \
  "    nat2 usSaveLgEnsMod = 0;\n" \
  "    /* longueur d'un ensemble TL module */\n" \
  "    nat2 usSaveLgEnsNoy = 0;\n" \
  "    /* longueur d'un ensemble TL noyau */\n" \
  "    nat2 usSaveLgEnsPub = 0;\n" \
  "    /* longueur d'un ensemble TL publicite */\n" \
  "    nat2 usSaveLgEnsMic = 0; /** -- V2 lgu 14/11/1997 -- */\n" \
  "    /* longueur d'un ensemble TL objet micro */\n" \
  "    nat2 usLgPubTot = 0;\n" \
  "    /* longueur de travail */\n" \
  "    int4 giviInsertTLV = 0;\n" \
  "    /* indice de deplacement dans le tableau de depart */\n" \
  "    char cTypeObjMicro = 0;\n" \
  "    /* type d'objet micro *//** -- V2 lgu 27/11/1997 -- */\n" \
  "    char cNoyauCondense[8 + 1];\n" \
  "    /* zone receptrice du compactage du numero de noyau */\n" \
  "    char cModuleCondense[8 + 1];\n" \
  "    /* zone receptrice du compactage du numero de module */\n" \
  "    char cMicroCondense[8 + 1]; /** -- V2 lgu 14/11/1997 -- */\n" \
  "    /* zone receptrice du compactage du numero d'objet micro */\n" \
  "    char tcType[2 + 1];\n" \
  "    nb_noyau = 0;\n" \
  "    nb_micro = 0;\n" \
  "    nb_module = 0;\n" \
  "\n" \
  "    /* Traitement des noyaux */\n" \
  "    /**----------------------*/\n" \
  "    /* N'appeler la mise en forme de l'ensemble de noyaux que s'il existe des noyaux */\n" \
  "    if (GIV::GIXCodeOK == (int1)GIVcPresenceNoyau)\n" \
  "    {\n" \
  "        /* initialiser l'indice de deplacement dans le tableau de depart */\n" \
  "        giviInsertTLV = 0;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"NOYAU EXISTE : %s\\n\", doc->value.objets_pub.noyau[nb_noyau].type));\n" \
  "\n" \
  "        while (giviInsertTLV < GIViNbTupleIanoy)\n" \
  "        {\n" \
  "            /* encodage TLV du type d'objet */\n" \
  "            doc->value.objets_pub.noyau[nb_noyau].type[0] = givcTypNoyau;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"TYPE : %s\\n\", doc->value.objets_pub.noyau[nb_noyau].type));\n" \
  "            /* encodage TLV du sous-type d'objet */\n" \
  "            strcpy(doc->value.objets_pub.noyau[nb_noyau].stype, GIVtrNoyau[giviInsertTLV].acGstaff);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"STYPE : %s\\n\", doc->value.objets_pub.noyau[nb_noyau].stype));\n" \
  "            /* encodage TLV du numero d'objet (noyau) apres appel de la fonction de compactage */\n" \
  "            GWCCompacterIdObj(GIVtrNoyau[giviInsertTLV].acNoyau, cNoyauCondense);\n" \
  "            strcpy(doc->value.objets_pub.noyau[nb_noyau].id, GIVtrNoyau[giviInsertTLV].acNoyau);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"STYPE : %s\\n\", doc->value.objets_pub.noyau[nb_noyau].stype));\n" \
  "            nb_noyau++;\n" \
  "            giviInsertTLV++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* traitement des modules */\n" \
  "    /**-----------------------*/\n" \
  "    /* N'appeler la mise en forme de l'ensemble de modules que s'il existe des modules */\n" \
  "    if (GIV::GIXCodeOK == (int1)GIVcPresenceModule)\n" \
  "    {\n" \
  "        /* initialiser l'indice de deplacement dans le tableau de depart */\n" \
  "        giviInsertTLV = 0;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MODULE EXISTE : %s\\n\", doc->value.objets_pub.module[nb_module].type));\n" \
  "\n" \
  "        while (giviInsertTLV < GIViNbTupleIamod)\n" \
  "        {\n" \
  "            /* encodage TLV du type d'objet pour les modules */\n" \
  "            doc->value.objets_pub.module[nb_module].type[0] = givcTypModule;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"TYPE : %s\\n\", doc->value.objets_pub.module[nb_module].type));\n" \
  "            /* encodage TLV du sous-type d'objet (type de module) */\n" \
  "            strcpy(doc->value.objets_pub.module[nb_module].stype, GIVtrModule[giviInsertTLV].acTypmod);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"STYPE : %s\\n\", doc->value.objets_pub.module[nb_module].stype));\n" \
  "            /* encodage TLV du module apres compactage du numero de module */\n" \
  "            GWCCompacterIdObj(GIVtrModule[giviInsertTLV].acModule, cModuleCondense);\n" \
  "            strcpy(doc->value.objets_pub.module[nb_module].id, GIVtrModule[giviInsertTLV].acModule);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ID_PUB : %s\\n\", doc->value.objets_pub.module[nb_module].id));\n" \
  "            nb_module++;\n" \
  "            giviInsertTLV++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /** -- V2 lgu 14/11/1997 -- */\n" \
  "    /* Traitement des objet publicitaire 11 Micro */\n" \
  "    /**-------------------------------------------*/\n" \
  "    /* N'appeler la mise en forme de l'ensemble d'objet 11 micro que s'il en existe */\n" \
  "    if (GIV::GIXCodeOK == (int1)GIVcPresenceObjMicro)\n" \
  "    {\n" \
  "        /* initialiser l'indice de deplacement dans le tableau de depart */\n" \
  "        giviInsertTLV = 0;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"MICRO EXISTE : %s\\n\", doc->value.objets_pub.noyau[nb_micro].type));\n" \
  "\n" \
  "        while (giviInsertTLV < GIViNbTupleIamic)\n" \
  "        {\n" \
  "            /* encodage TLV du type d'objet */\n" \
  "            switch (GIVtrObjMicro[giviInsertTLV].acTypobj[0])\n" \
  "            {\n" \
  "            case 'N':\n" \
  "                cTypeObjMicro = 'C';\n" \
  "                break;\n" \
  "\n" \
  "            case 'M':\n" \
  "                cTypeObjMicro = 'X';\n" \
  "                break;\n" \
  "\n" \
  "            default:\n" \
  "                cTypeObjMicro = GIVtrObjMicro[giviInsertTLV].acTypobj[0];\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            /* Encodage du type */\n" \
  "            doc->value.objets_pub.micro[nb_micro].type[0] = cTypeObjMicro;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"TYPE : %s\\n\", doc->value.objets_pub.micro[nb_micro].type));\n" \
  "            /* encodage TLV de la date d'activation */\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].tcdatact, GIVtrObjMicro[giviInsertTLV].acDatact);\n" \
  "            /* type de CVI */\n" \
  "            doc->value.objets_pub.micro[nb_micro].iCVI = GIVtrObjMicro[giviInsertTLV].iFlagCVI;\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stypcvi, GIVtrObjMicro[giviInsertTLV].acTpdcvi);\n" \
  "            /* encodage TLV du sous-type d'objet */\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stype, GIVtrObjMicro[giviInsertTLV].acTpdobj);\n" \
  "            /* encodage TLV du sous-type interne d'objet */\n" \
  "            strcpy(doc->value.objets_pub.micro[nb_micro].stypint, GIVtrObjMicro[giviInsertTLV].acTpobint);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"STYPINT : %s\\n\", doc->value.objets_pub.micro[nb_micro].stypint));\n" \
  "\n" \
  "            /* Si sous-type sur un caractère, mettre un blanc devant */\n" \
  "            if (strlen(doc->value.objets_pub.micro[nb_micro].stype) == 1)\n" \
  "            {\n" \
  "                doc->value.objets_pub.micro[nb_micro].stype[1] = doc->value.objets_pub.micro[nb_micro].stype[0];\n" \
  "                doc->value.objets_pub.micro[nb_micro].stype[0] = ' ';\n" \
  "            }\n" \
  "\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"STYPE : %s\\n\", doc->value.objets_pub.micro[nb_micro].stype));\n" \
  "\n" \
  "            /* encodage TLV du sous-sous-type d'objet */\n" \
  "            /********************* OA11 ******************/\n" \
  "            if (0 == strlen(GIVtrObjMicro[giviInsertTLV].acStobj))\n" \
  "                strcpy(doc->value.objets_pub.micro[nb_micro].sstype, doc->value.objets_pub.micro[nb_micro].stype);\n" \
  "            else\n" \
  "                strcpy(doc->value.objets_pub.micro[nb_micro].sstype, GIVtrObjMicro[giviInsertTLV].acStobj);\n" \
  "\n" \
  "            doc->value.objets_pub.micro[nb_micro].valeur[0] = '\\0';\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"SSTYPE : %s\\n\", doc->value.objets_pub.micro[nb_micro].sstype));\n" \
  "            GWC_ISO88591_To_MajSansAccent((unsigned char*)doc->value.objets_pub.micro[nb_micro].stype, (unsigned char*)tcType);\n" \
  "\n" \
  "            if (0 == strcmp(doc->value.objets_pub.micro[nb_micro].stype, tcType))\n" \
  "            {\n" \
  "                /* encodage TLV du numero d'objet micro apres appel de la fonction de compactage */\n" \
  "                GWCCompacterIdObj(GIVtrObjMicro[giviInsertTLV].acNumobj, cMicroCondense);\n" \
  "                strcpy(doc->value.objets_pub.micro[nb_micro].id, GIVtrObjMicro[giviInsertTLV].acNumobj);\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"ID : %s\\n\", doc->value.objets_pub.micro[nb_micro].id));\n" \
  "                nb_micro++;\n" \
  "            }\n" \
  "\n" \
  "            giviInsertTLV++;\n" \
  "        }\n" \
  "\n" \
  "        doc->value.objets_pub.nb_micro = nb_micro;\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefEnsemble ()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme de l'ensemble                                    */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefEnsemble(GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 i, j, k, q; /* indice boucle doubles */\n" \
  "    GYBrMouvementsT rMouvement;\n" \
  "    /* init données de tri en sous-blocs */\n" \
  "    doc->iIndice = indice;\n" \
  "    doc->iRang = (int4)0;\n" \
  "    iCodRet = givMefDonneesGestion(doc, indice);\n" \
  "    iCodRet = givMefDonneesParution(doc, indice);\n" \
  "    iCodRet = givMefMoyensTelecom(doc, indice);\n" \
  "    iCodRet = givMefLieuParution(doc, indice);\n" \
  "    /* Initialisation du nombre d'An9 */\n" \
  "    nb_an9 = 0;\n" \
  "    nb_marque = 0;\n" \
  "\n" \
  "    /* Lecture de la table liens codes AN8 */\n" \
  "    /* et de la table liens Epj AN8 si IO */\n" \
  "    if (((-1 != GIVvIndInscrip.sIndprfI) && ('1' == GIVvInscrip.acIndprf[0])) || ((0 == strcmp(\"0000\", doc->value.inscription[0].val_ls)) && ((int4)GIV::GYBok == GIVvIndInscrip.sEtabI)))\n" \
  "    {\n" \
  "    	rMouvement.copyNumNatLoLs(GIVvInscrip.acNumnat, GIVvInscrip.acNumlo, GIVvInscrip.acNumls);\n" \
  "        iIntRet = GIVLectureTabIAPROF(&rMouvement);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK != iIntRet)\n" \
  "        {\n" \
  "            /* Echec de la lecture de la table liens codes AN8 */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Echec lecture table liens codes AN8 ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        GIVcPresenceAn9 = (int1)GIV::GIXCodeKO;\n" \
  "        GIViNbTupleIaprof = (int4)0;\n" \
  "    }\n" \
  "\n" \
  "    snprintf(GIVvGeocod.tcQualite, GIVGeocodLgQualite + 1, \"%2d\", GIVGeocodQIgnorer);\n" \
  "    GIVvGeocod.iStatus = GIVGeocodSEnvRien; /* par défaut rien n'est envoyé au CD */\n" \
  "    /* toute inscription est géocodée au CG2G */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Appel de GIVGeocod...\\n\"));\n" \
  "    GIVGeocod(&GIVvGeocod, GIXcDepartement); /* à partir de IEINSC structure rGeocod */\n" \
  "    iCodRet = givMefProfessionnel(doc, indice);\n" \
  "    iCodRet = givMefLieuInstallation(doc, indice);\n" \
  "    /* géocodage du centre de localité */\n" \
  "    GIVvGeocod.iStatus = GIVGeocodSEnvRien; /* par défaut rien */\n" \
  "    strcpy(GIVvGeocod.tcQualite, doc->value.inscription[0].adresse.geoloc.precision);\n" \
  "    iCodRet = GIVGeoCentreLoc(&GIVvGeocod);\n" \
  "\n" \
  "    if (GIVvGeocod.isStatus(GIVGeocodSEnvXYQ, GIVGeocodSEnvXY))\n" \
  "    {\n" \
  "        strcpy(doc->value.inscription[0].adresse.centreloc.precision, GIVvGeocod.tcQualite);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"QUALITE Centre : %s\\n\", doc->value.inscription[0].adresse.centreloc.precision));\n" \
  "        strcpy(doc->value.inscription[0].adresse.centreloc.precision, \"0\");\n" \
  "        strcpy(doc->value.inscription[0].adresse.centreloc.longitude, GIVvGeocod.tcLongitude);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LONGITUDE Centre : %s\\n\", doc->value.inscription[0].adresse.centreloc.longitude));\n" \
  "        strcpy(doc->value.inscription[0].adresse.centreloc.latitude, GIVvGeocod.tcLatitude);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"LATITUDE Centre : %s\\n\", doc->value.inscription[0].adresse.centreloc.latitude));\n" \
  "    }\n" \
  "\n" \
  "    /* Initialisation du nombre d'objets publicitaires */\n" \
  "    nb_noyau = 0;\n" \
  "    nb_micro = 0;\n" \
  "    nb_module = 0;\n" \
  "\n" \
  "    if ((GIV::GIXCodeOK == (int1)GIVcPresenceNoyau) || (GIV::GIXCodeOK == (int1)GIVcPresenceModule) || (GIV::GIXCodeOK == (int1)GIVcPresenceObjMicro))\n" \
  "        iCodRet = givMefPublicite(doc, indice);\n" \
  "\n" \
  "    /* Initialisation du nombre de crc */\n" \
  "    if (0 != nb_an9)\n" \
  "        doc->value.crc.iNbCrc = 0;\n" \
  "\n" \
  "    /* anotation de l'intitulé */\n" \
  "    if (-1 != GIVvIndInscrip.sIntlAnnotI)\n" \
  "        strcpy(doc->value.intitule.tcIntlAnnot, GIVvInscrip.acIntlAnnot);\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefProfInstal ()                                                */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme dues associations rub.geo                        */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification :                                                             */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMefProfInstal(GYBrDOCUMENTEpj* doc, int4 aindice)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 iFusRet = GIV::GWCCodeKO; /* Code retour interne localité fusionnée */\n" \
  "    int4 i, j, k, l, iIdx = 0; /* Index de boucle */\n" \
  "    int4 iGeo;\n" \
  "    int4 iNbrParu, iNbrParuMax, iNbrInst, iNbrInstMax;\n" \
  "    /* indicateurs de sélection géographique */\n" \
  "\n" \
  "    if ((0 != strlen(doc->value.rubriques.depact)) && (0 != strlen(doc->value.rubriques.locact)))\n" \
  "    {\n" \
  "        /* utilisation des données d'activité */\n" \
  "        strcpy(doc->value.inscription[0].cCoddep, doc->value.rubriques.depact);\n" \
  "        strcpy(doc->value.inscription[0].cCodloc, doc->value.rubriques.locact);\n" \
  "        /* arrondissement */\n" \
  "        strcpy(doc->value.inscription[0].cArrond, doc->value.rubriques.arract);\n" \
  "    }\n" \
  "\n" \
  "    /* géographie sur première rubrique */\n" \
  "    for (k = 0 ; ((k < doc->value.rubriques.iNban9) && ('0' != doc->value.rubriques.Tan9[k].recgpp)); k++);\n" \
  "\n" \
  "    if (doc->value.rubriques.iNban9 == k)\n" \
  "    {\n" \
  "        /* Sortie de la fonction car tout est réconcilié ! */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    iNbrParu = givrListParu.iNbr;\n" \
  "    iNbrInst = givrListInst.iNbr;\n" \
  "\n" \
  "    if ((MAX_LIST == givrListInst.iNbr) || (MAX_LIST == givrListParu.iNbr))\n" \
  "    {\n" \
  "        /* Trop d'entrées internes */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "        /* Sortie de la fonction */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(doc->value.inscription[0].cCoddep))\n" \
  "    {\n" \
  "        /* arrondissement d'installation */\n" \
  "        iGeo = givrListInst.iNbr;\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].dep, doc->value.inscription[0].cCoddep);\n" \
  "\n" \
  "        if (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc))\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].loc, doc->value.inscription[0].cCodloc);\n" \
  "        else\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].loc, givcLocIndf);\n" \
  "\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].arr, doc->value.inscription[0].cArrond);\n" \
  "        /* région */\n" \
  "        iIntRet = givLectureTabRegion(doc->value.inscription[0].cCoddep);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "        else\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "        (void)strcpy(doc->value.inscription[0].cReg, givrListInst.trEltList[iGeo].reg);\n" \
  "        (void)strcpy(doc->value.inscription[0].cAncReg, givrListInst.trEltList[iGeo].reg);\n" \
  "        (void)strcpy(doc->value.inscription[0].cLocFus, \"\");\n" \
  "        givrListInst.trEltList[iGeo].iRgLigne = aindice;\n" \
  "        givrListInst.trEltList[iGeo].iGeo = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoReg = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoDept = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoLoc = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoArr = 99;\n" \
  "        givrListInst.trEltRangList[iGeo] = iGeo;\n" \
  "        givrListInst.iNbr++;\n" \
  "\n" \
  "        if (0 == strlen(givrListInst.trEltList[iGeo].arr))\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].arr, \"99\");\n" \
  "\n" \
  "        if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListInst.iNbr))\n" \
  "        {\n" \
  "            /* ancienne région */\n" \
  "            (void)strcpy(doc->value.inscription[0].cAncReg, GIVvRegion.acAncReg);\n" \
  "            memcpy(&givrListInst.trEltList[iGeo + 1], &givrListInst.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "            strcpy(givrListInst.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "            givrListInst.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "            givrListInst.iNbr++;\n" \
  "        }\n" \
  "\n" \
  "        /* localité fusionnée */\n" \
  "        iFusRet = givLectureTabLocFus(doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iFusRet)\n" \
  "        {\n" \
  "            if (MAX_LIST == givrListInst.iNbr)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                /* Sortie de la fonction */\n" \
  "                iCodRet = GIV::GWCCodeKO;\n" \
  "                return (iCodRet);\n" \
  "            }\n" \
  "\n" \
  "            (void)strcpy(doc->value.inscription[0].cLocFus, GIVvPole.acLocPole);\n" \
  "            memcpy(&givrListInst.trEltList[givrListInst.iNbr], &givrListInst.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "            (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].dep, GIVvPole.acDepPole);\n" \
  "            (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].loc, GIVvPole.acLocPole);\n" \
  "            givrListInst.trEltRangList[givrListInst.iNbr] = givrListInst.iNbr;\n" \
  "            givrListInst.iNbr++;\n" \
  "        }\n" \
  "    }\n" \
  "    else if ((0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp(givcDepFictif, doc->value.inscription[0].cDeppar)))\n" \
  "    {\n" \
  "        /* arrondisement d'installation */\n" \
  "        iGeo = givrListInst.iNbr;\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].dep, doc->value.inscription[0].cDeppar);\n" \
  "\n" \
  "        if (0 != strcmp(givcLocFictive, doc->value.inscription[0].cLocpar))\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].loc, doc->value.inscription[0].cLocpar);\n" \
  "        else\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].loc, givcLocIndf);\n" \
  "\n" \
  "        (void)strcpy(givrListInst.trEltList[iGeo].arr, doc->value.inscription[0].cArrond);\n" \
  "        /* région */\n" \
  "        iIntRet = givLectureTabRegion(doc->value.inscription[0].cDeppar);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "        else\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "        (void)strcpy(doc->value.inscription[0].cReg, givrListInst.trEltList[iGeo].reg);\n" \
  "        (void)strcpy(doc->value.inscription[0].cAncReg, givrListInst.trEltList[iGeo].reg);\n" \
  "        givrListInst.trEltList[iGeo].iRgLigne = aindice;\n" \
  "        givrListInst.trEltList[iGeo].iGeo = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoReg = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoDept = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoLoc = 99;\n" \
  "        givrListInst.trEltList[iGeo].iGeoArr = 99;\n" \
  "        givrListInst.trEltRangList[iGeo] = iGeo;\n" \
  "        givrListInst.iNbr++;\n" \
  "\n" \
  "        if (0 == strlen(givrListInst.trEltList[iGeo].arr))\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].arr, \"99\");\n" \
  "\n" \
  "        i = iGeo;\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Installation 1 [%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc,\n" \
  "                                 givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc,\n" \
  "                                 givrListInst.trEltList[i].iGeoArr));\n" \
  "\n" \
  "        if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListInst.iNbr))\n" \
  "        {\n" \
  "            /* ancienne région */\n" \
  "            (void)strcpy(doc->value.inscription[0].cAncReg, GIVvRegion.acAncReg);\n" \
  "            memcpy(&givrListInst.trEltList[iGeo + 1], &givrListInst.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "            strcpy(givrListInst.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "            givrListInst.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "            givrListInst.iNbr++;\n" \
  "        }\n" \
  "\n" \
  "        /* localité fusionnée */\n" \
  "        if (0 != strcmp(givcLocFictive, doc->value.inscription[0].cLocpar))\n" \
  "            iFusRet = givLectureTabLocFus(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iFusRet)\n" \
  "        {\n" \
  "            if (MAX_LIST == givrListInst.iNbr)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                /* Sortie de la fonction */\n" \
  "                iCodRet = GIV::GWCCodeKO;\n" \
  "                return (iCodRet);\n" \
  "            }\n" \
  "\n" \
  "            (void)strcpy(doc->value.inscription[0].cLocFus, GIVvPole.acLocPole);\n" \
  "            memcpy(&givrListInst.trEltList[givrListInst.iNbr], &givrListInst.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "            (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].dep, GIVvPole.acDepPole);\n" \
  "            (void)strcpy(givrListInst.trEltList[givrListInst.iNbr].loc, GIVvPole.acLocPole);\n" \
  "            givrListInst.trEltRangList[givrListInst.iNbr] = givrListInst.iNbr;\n" \
  "            givrListInst.iNbr++;\n" \
  "            i = givrListInst.iNbr - 1;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Installation 2 [%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc,\n" \
  "                                     givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc,\n" \
  "                                     givrListInst.trEltList[i].iGeoArr));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* arrondisement de parution */\n" \
  "    iGeo = givrListParu.iNbr;\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].dep, doc->value.inscription[0].cDeppar);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].loc, doc->value.inscription[0].cLocpar);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].arr, doc->value.inscription[0].cArrpar);\n" \
  "    /* région */\n" \
  "    iIntRet = givLectureTabRegion(doc->value.inscription[0].cDeppar);\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "    else\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "    givrListParu.trEltList[iGeo].iDbl = -1;\n" \
  "    givrListParu.trEltList[iGeo].iRgLigne = aindice;\n" \
  "    givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "    givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "    givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeKO;\n" \
  "    givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "    givrListParu.iNbr++;\n" \
  "\n" \
  "    if (0 == strlen(givrListParu.trEltList[iGeo].arr))\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].arr, \"99\");\n" \
  "\n" \
  "    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "    {\n" \
  "        /* ancienne région */\n" \
  "        memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "        strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "        givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "        givrListParu.iNbr++;\n" \
  "    }\n" \
  "\n" \
  "    if ((0 != strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp(givcLocFictive, doc->value.inscription[0].cLocpar))\n" \
  "            && ((0 != strcmp(doc->value.inscription[0].cCodloc, doc->value.inscription[0].cLocpar)) || (0 != strcmp(doc->value.inscription[0].cCoddep, doc->value.inscription[0].cDeppar))))\n" \
  "        iFusRet = givLectureTabLocFus(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK == iFusRet)\n" \
  "    {\n" \
  "        if (MAX_LIST == givrListParu.iNbr)\n" \
  "        {\n" \
  "            /* Trop d'entrées internes */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "            /* Sortie de la fonction */\n" \
  "            iCodRet = GIV::GWCCodeKO;\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        memcpy(&givrListParu.trEltList[givrListParu.iNbr], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "        (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep, GIVvPole.acDepPole);\n" \
  "        (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc, GIVvPole.acLocPole);\n" \
  "        (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr, \"99\");\n" \
  "        givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;\n" \
  "        givrListParu.iNbr++;\n" \
  "    }\n" \
  "\n" \
  "    if ((0 == strcmp(givcLocFictive, doc->value.inscription[0].cLocpar)) && (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc))\n" \
  "            && (0 == strcmp(doc->value.inscription[0].cCoddep, doc->value.inscription[0].cDeppar)))\n" \
  "    {\n" \
  "        /* arrondisement de parution */\n" \
  "        iGeo = givrListParu.iNbr;\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "        givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "        givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].dep, doc->value.inscription[0].cCoddep);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].loc, doc->value.inscription[0].cCodloc);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].arr, doc->value.inscription[0].cArrond);\n" \
  "        /* région */\n" \
  "        iIntRet = givLectureTabRegion(doc->value.inscription[0].cDeppar);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "        else\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "        givrListParu.trEltList[iGeo].iDbl = -1;\n" \
  "        givrListParu.trEltList[iGeo].iRgLigne = (int4)GIV::GIXCodeKO;\n" \
  "        givrListParu.trEltList[iGeo].iRgLigne = aindice;\n" \
  "        givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "        givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "        givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeKO;\n" \
  "        givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "        givrListParu.iNbr++;\n" \
  "\n" \
  "        if (0 == strlen(givrListParu.trEltList[iGeo].arr))\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].arr, \"99\");\n" \
  "\n" \
  "        if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "        {\n" \
  "            /* ancienne région */\n" \
  "            memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "            strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "            givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "            givrListParu.iNbr++;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iFusRet)\n" \
  "        {\n" \
  "            if (MAX_LIST == givrListParu.iNbr)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                /* Sortie de la fonction */\n" \
  "                iCodRet = GIV::GWCCodeKO;\n" \
  "                return (iCodRet);\n" \
  "            }\n" \
  "\n" \
  "            memcpy(&givrListParu.trEltList[givrListParu.iNbr], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "            (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep, GIVvPole.acDepPole);\n" \
  "            (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc, GIVvPole.acLocPole);\n" \
  "            (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr, \"99\");\n" \
  "            givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;\n" \
  "            givrListParu.iNbr++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Pole de zone urbaine */\n" \
  "    if (((0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp(doc->value.inscription[0].cLocpar, givcLocFictive))) || ((0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc))\n" \
  "            && (0 != strlen(doc->value.inscription[0].cCoddep)) && (0 == memcmp(doc->value.inscription[0].cLocpar, doc->value.inscription[0].cCodloc, strlen(doc->value.inscription[0].cCodloc)))\n" \
  "            && (0 == memcmp(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCoddep, strlen(doc->value.inscription[0].cCoddep)))))\n" \
  "    {\n" \
  "        doc->iGeoLoc = GIV::giv_LOC;\n" \
  "        iIntRet = givLectureTabZU(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);\n" \
  "\n" \
  "        if ((MAX_LIST == givrListParu.iNbr) && ((int4)GIV::GIXCodeOK == iIntRet))\n" \
  "        {\n" \
  "            /* Trop d'entrées internes */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "            iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "        {\n" \
  "            /* pole de parution */\n" \
  "            iGeo = givrListParu.iNbr;\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "            givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "            givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].dep, GIVvPole.acDepPole);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].loc, GIVvPole.acLocPole);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].arr, \"00\");\n" \
  "            /* région */\n" \
  "            iIntRet = givLectureTabRegion(GIVvPole.acDepPole);\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "            else\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "            givrListParu.trEltList[iGeo].iDbl = -1;\n" \
  "            givrListParu.trEltList[iGeo].iRgLigne = aindice;\n" \
  "            givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "            givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "            givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeOK;\n" \
  "            givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "            givrListParu.iNbr++;\n" \
  "\n" \
  "            if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "            {\n" \
  "                /* ancienne région */\n" \
  "                memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "                strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "                givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "                givrListParu.iNbr++;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        if ((0 == memcmp(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCoddep, strlen(doc->value.inscription[0].cCoddep))) || (0 == strlen(doc->value.inscription[0].cCoddep)))\n" \
  "        {\n" \
  "            if ((0 == strcmp(givcLocFictive, doc->value.inscription[0].cLocpar)) && (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)))\n" \
  "                doc->iGeoLoc = GIV::giv_LOC;\n" \
  "            else if (0 != strcmp(givcDepFictif, doc->value.inscription[0].cDeppar))\n" \
  "                doc->iGeoLoc = GIV::giv_DEPT;\n" \
  "            else\n" \
  "                doc->iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            /* pôle de zone urbaine d'installation  */\n" \
  "            iIntRet = givLectureTabZU(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCodloc);\n" \
  "\n" \
  "            if ((MAX_LIST == givrListParu.iNbr) && ((int4)GIV::GIXCodeOK == iIntRet))\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "            {\n" \
  "                /* pole de parution */\n" \
  "                iGeo = givrListParu.iNbr;\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "                givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "                givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].dep, GIVvPole.acDepPole);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].loc, GIVvPole.acLocPole);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].arr, \"00\");\n" \
  "                /* région */\n" \
  "                iIntRet = givLectureTabRegion(GIVvPole.acDepPole);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "                else\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "                givrListParu.trEltList[iGeo].iDbl = -1;\n" \
  "                givrListParu.trEltList[iGeo].iRgLigne = aindice;\n" \
  "                givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "                givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeOK;\n" \
  "                givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "                givrListParu.iNbr++;\n" \
  "\n" \
  "                if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "                {\n" \
  "                    /* ancienne région */\n" \
  "                    memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "                    strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "                    givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "                    givrListParu.iNbr++;\n" \
  "                }\n" \
  "\n" \
  "                if (MAX_LIST == givrListParu.iNbr)\n" \
  "                {\n" \
  "                    /* Trop d'entrées internes */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                }\n" \
  "                else if ((0 == strcmp(givcLocFictive, doc->value.inscription[0].cLocpar)) && (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep))\n" \
  "                         && (0 == strcmp(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCoddep)) && (0 == strcmp(doc->value.inscription[0].cDeppar, GIVvPole.acDepPole)))\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"ZU et LF : %s,%s,%s,%s,%s,%s\\n\", doc->value.inscription[0].cLocpar, doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc,\n" \
  "                                             GIVvPole.acDepPole, GIVvPole.acLocPole));\n" \
  "                    /* implicitement parution sur le pôle */\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rub, givrListParu.trEltList[iGeo].rub);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rubinit, givrListParu.trEltList[iGeo].rubinit);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].nature, givrListParu.trEltList[iGeo].nature);\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].orig = givrListParu.trEltList[iGeo].orig;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].cParuloc = givrListParu.trEltList[iGeo].cParuloc;\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep, GIVvPole.acDepPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc, GIVvPole.acLocPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr, \"00\");\n" \
  "\n" \
  "                    /* région */\n" \
  "                    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                        (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg, GIVvRegion.acRegion);\n" \
  "                    else\n" \
  "                        (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg, \"99\");\n" \
  "\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iDbl = -1;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iRgLigne = aindice;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeo = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoReg = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoDept = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoLoc = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoArr = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iZU = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;\n" \
  "                    givrListParu.iNbr++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            doc->iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (0 != strlen(doc->value.inscription[0].cCoddep))\n" \
  "            {\n" \
  "                /* pôle de zone urbaine d'installation  */\n" \
  "                iIntRet = givLectureTabZU(doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc);\n" \
  "\n" \
  "                if ((MAX_LIST == givrListParu.iNbr) && ((int4)GIV::GIXCodeOK == iIntRet))\n" \
  "                {\n" \
  "                    /* Trop d'entrées internes */\n" \
  "                    GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                    iIntRet = (int4)GIV::GIXCodeKO;\n" \
  "                }\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                {\n" \
  "                    /* pole de parution */\n" \
  "                    iGeo = givrListParu.iNbr;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "                    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "                    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].dep, GIVvPole.acDepPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].loc, GIVvPole.acLocPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].arr, \"00\");\n" \
  "                    /* région */\n" \
  "                    iIntRet = givLectureTabRegion(GIVvPole.acDepPole);\n" \
  "\n" \
  "                    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "                    else\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "                    givrListParu.trEltList[iGeo].iDbl = -1;\n" \
  "                    givrListParu.trEltList[iGeo].iRgLigne = aindice;\n" \
  "                    givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeOK;\n" \
  "                    givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "                    givrListParu.iNbr++;\n" \
  "\n" \
  "                    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "                    {\n" \
  "                        /* ancienne région */\n" \
  "                        memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "                        strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "                        givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "                        givrListParu.iNbr++;\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GeoLoc : %d\\n\", doc->value.rubriques.iNban9));\n" \
  "    /* géographie sur rubriques suivantes */\n" \
  "    iNbrInstMax = givrListInst.iNbr - iNbrInst;\n" \
  "    iNbrParuMax = givrListParu.iNbr - iNbrParu;\n" \
  "\n" \
  "    for (k = k + 1 ; k < doc->value.rubriques.iNban9; k++)\n" \
  "    {\n" \
  "        if ('0' != doc->value.rubriques.Tan9[k].recgpp)\n" \
  "        {\n" \
  "            /* rubrique réconciliée */\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        for (l = 0; l < iNbrInstMax; l++)\n" \
  "        {\n" \
  "            iGeo = givrListInst.iNbr;\n" \
  "\n" \
  "            if (MAX_LIST == iGeo)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].dep, givrListInst.trEltList[iNbrInst + l].dep);\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].loc, givrListInst.trEltList[iNbrInst + l].loc);\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].arr, givrListInst.trEltList[iNbrInst + l].arr);\n" \
  "            (void)strcpy(givrListInst.trEltList[iGeo].reg, givrListInst.trEltList[iNbrInst + l].reg);\n" \
  "            givrListInst.trEltList[iGeo].iRgLigne = givrListInst.trEltList[iNbrInst + l].iRgLigne;\n" \
  "            givrListInst.trEltList[iGeo].iGeo = 99;\n" \
  "            givrListInst.trEltList[iGeo].iGeoReg = 99;\n" \
  "            givrListInst.trEltList[iGeo].iGeoDept = 99;\n" \
  "            givrListInst.trEltList[iGeo].iGeoLoc = 99;\n" \
  "            givrListInst.trEltList[iGeo].iGeoArr = 99;\n" \
  "            givrListInst.trEltRangList[iGeo] = iGeo;\n" \
  "            givrListInst.iNbr++;\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ParuLoc 0: %c\\n\", doc->value.rubriques.Tan9[k].paru));\n" \
  "\n" \
  "        for (l = 0; l < iNbrParuMax; l++)\n" \
  "        {\n" \
  "            iGeo = givrListParu.iNbr;\n" \
  "\n" \
  "            if (MAX_LIST == iGeo)\n" \
  "            {\n" \
  "                /* Trop d'entrées internes */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille liste interne dépassée\\n\"));\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "            givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "            givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ParuLoc 1: %c\\n\", givrListParu.trEltList[iGeo].cParuloc));\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].dep, givrListParu.trEltList[iNbrParu + l].dep);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].loc, givrListParu.trEltList[iNbrParu + l].loc);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].arr, givrListParu.trEltList[iNbrParu + l].arr);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].reg, givrListParu.trEltList[iNbrParu + l].reg);\n" \
  "            givrListParu.trEltList[iGeo].iDbl = givrListParu.trEltList[iNbrParu + l].iDbl;\n" \
  "            givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[iNbrParu + l].iRgLigne;\n" \
  "            givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "            givrListParu.trEltList[iGeo].iZU = givrListParu.trEltList[iNbrParu + l].iZU;\n" \
  "            givrListParu.trEltList[iGeo].iLF = givrListParu.trEltList[iNbrParu + l].iLF;\n" \
  "            givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "            givrListParu.iNbr++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GeoLoc : %d\\n\", doc->iGeoLoc));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" Doubles %d,%d\\n\", givrListInst.iNbr, givrListParu.iNbr));\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMefProfParu ()                                                */\n" \
  "/*                                                                            */\n" \
  "/* But       : Mise en forme des parutions rub.geo                        */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification :                                                             */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "extern int4 GIVMefProfParu(GYBrIaparuT* apIaparu, int4 aiDbl, int4 aiRef)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 k = 0; /* Index de boucle */\n" \
  "    int4 iGeo, iIndice;\n" \
  "    GYBrDOCUMENTEpj rDoc;\n" \
  "    GYBrDOCUMENTEpj* doc;\n" \
  "    /* indicateurs de sélection géographique */\n" \
  "    doc = &rDoc;\n" \
  "    (void)strcpy(doc->value.inscription[0].cDeppar, apIaparu->acDeppar);\n" \
  "    (void)strcpy(doc->value.inscription[0].cLocpar, apIaparu->acLocpar);\n" \
  "    (void)strcpy(doc->value.inscription[0].cArrpar, apIaparu->acArrpar);\n" \
  "    (void)strcpy(doc->value.inscription[0].cCoddep, givrListInst.trEltList[aiRef].dep);\n" \
  "    (void)strcpy(doc->value.inscription[0].cCodloc, givrListInst.trEltList[aiRef].loc);\n" \
  "    (void)strcpy(doc->value.inscription[0].cArrond, givrListInst.trEltList[aiRef].arr);\n" \
  "    (void)strcpy(doc->value.rubriques.Tan9[0].val_codan9, givrListParu.trEltList[aiRef].rub);\n" \
  "    (void)strcpy(doc->value.rubriques.Tan9[0].val_codan8, givrListParu.trEltList[aiRef].rubinit);\n" \
  "    (void)strcpy(doc->value.rubriques.Tan9[0].nature, givrListParu.trEltList[aiRef].nature);\n" \
  "    doc->value.rubriques.Tan9[0].orig = givrListParu.trEltList[aiRef].orig;\n" \
  "    doc->value.rubriques.Tan9[0].paru = givrListParu.trEltList[aiRef].cParuloc;\n" \
  "    /* géographie sur première rubrique */\n" \
  "    k = 0;\n" \
  "    iIndice = 0;\n" \
  "    /* arrondisement de parution */\n" \
  "    iGeo = givrListParu.iNbr;\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].dep, doc->value.inscription[0].cDeppar);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].loc, doc->value.inscription[0].cLocpar);\n" \
  "    (void)strcpy(givrListParu.trEltList[iGeo].arr, doc->value.inscription[0].cArrpar);\n" \
  "    /* région */\n" \
  "    iIntRet = givLectureTabRegion(doc->value.inscription[0].cDeppar);\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "    else\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "    givrListParu.trEltList[iGeo].iDbl = aiDbl;\n" \
  "    givrListParu.trEltList[iGeo].iRgLigne = iIndice;\n" \
  "    givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "    givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "    givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "    givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeKO;\n" \
  "    givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "    givrListParu.iNbr++;\n" \
  "\n" \
  "    if (0 == strlen(givrListParu.trEltList[iGeo].arr))\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].arr, \"99\");\n" \
  "\n" \
  "    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "    {\n" \
  "        /* ancienne région */\n" \
  "        memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "        strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "        givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "        givrListParu.iNbr++;\n" \
  "    }\n" \
  "\n" \
  "    if ((0 == strcmp(givcLocFictive, doc->value.inscription[0].cLocpar)) && (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc))\n" \
  "            && (0 == strcmp(doc->value.inscription[0].cCoddep, doc->value.inscription[0].cDeppar)))\n" \
  "    {\n" \
  "        /* arrondisement de parution */\n" \
  "        iGeo = givrListParu.iNbr;\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "        givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "        givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].dep, doc->value.inscription[0].cCoddep);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].loc, doc->value.inscription[0].cCodloc);\n" \
  "        (void)strcpy(givrListParu.trEltList[iGeo].arr, doc->value.inscription[0].cArrond);\n" \
  "        /* région */\n" \
  "        iIntRet = givLectureTabRegion(doc->value.inscription[0].cDeppar);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "        else\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "        givrListParu.trEltList[iGeo].iDbl = aiDbl;\n" \
  "        givrListParu.trEltList[iGeo].iRgLigne = (int4)GIV::GIXCodeKO;\n" \
  "        givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "        givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "        givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "        givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeKO;\n" \
  "        givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "        givrListParu.iNbr++;\n" \
  "\n" \
  "        if (0 == strlen(givrListParu.trEltList[iGeo].arr))\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].arr, \"99\");\n" \
  "\n" \
  "        if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "        {\n" \
  "            /* ancienne région */\n" \
  "            memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "            strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "            givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "            givrListParu.iNbr++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Pole de zone urbaine */\n" \
  "    if (((0 == strlen(doc->value.inscription[0].cCoddep)) && (0 != strcmp(doc->value.inscription[0].cLocpar, givcLocFictive))) || ((0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc))\n" \
  "            && (0 != strlen(doc->value.inscription[0].cCoddep)) && (0 == memcmp(doc->value.inscription[0].cLocpar, doc->value.inscription[0].cCodloc, strlen(doc->value.inscription[0].cCodloc)))\n" \
  "            && (0 == memcmp(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCoddep, strlen(doc->value.inscription[0].cCoddep)))))\n" \
  "    {\n" \
  "        doc->iGeoLoc = GIV::giv_LOC;\n" \
  "        iIntRet = givLectureTabZU(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cLocpar);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "        {\n" \
  "            /* pole de parution */\n" \
  "            iGeo = givrListParu.iNbr;\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "            givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "            givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].dep, GIVvPole.acDepPole);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].loc, GIVvPole.acLocPole);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].arr, \"00\");\n" \
  "            /* région */\n" \
  "            iIntRet = givLectureTabRegion(GIVvPole.acDepPole);\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "            else\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "            givrListParu.trEltList[iGeo].iDbl = aiDbl;\n" \
  "            givrListParu.trEltList[iGeo].iRgLigne = iIndice;\n" \
  "            givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "            givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "            givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeOK;\n" \
  "            givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "            givrListParu.iNbr++;\n" \
  "\n" \
  "            if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "            {\n" \
  "                /* ancienne région */\n" \
  "                memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "                strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "                givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "                givrListParu.iNbr++;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        if ((0 == memcmp(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCoddep, strlen(doc->value.inscription[0].cCoddep))) || (0 == strlen(doc->value.inscription[0].cCoddep)))\n" \
  "        {\n" \
  "            if ((0 == strcmp(givcLocFictive, doc->value.inscription[0].cLocpar)) && (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)))\n" \
  "                doc->iGeoLoc = GIV::giv_LOC;\n" \
  "            else if (0 != strcmp(givcDepFictif, doc->value.inscription[0].cDeppar))\n" \
  "                doc->iGeoLoc = GIV::giv_DEPT;\n" \
  "            else\n" \
  "                doc->iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            /* pôle de zone urbaine d'installation  */\n" \
  "            iIntRet = givLectureTabZU(doc->value.inscription[0].cDeppar, doc->value.inscription[0].cCodloc);\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "            {\n" \
  "                /* pole de parution */\n" \
  "                iGeo = givrListParu.iNbr;\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "                givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "                givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].dep, GIVvPole.acDepPole);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].loc, GIVvPole.acLocPole);\n" \
  "                (void)strcpy(givrListParu.trEltList[iGeo].arr, \"00\");\n" \
  "                /* région */\n" \
  "                iIntRet = givLectureTabRegion(GIVvPole.acDepPole);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "                else\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "                givrListParu.trEltList[iGeo].iDbl = aiDbl;\n" \
  "                givrListParu.trEltList[iGeo].iRgLigne = iIndice;\n" \
  "                givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "                givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeOK;\n" \
  "                givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "                givrListParu.iNbr++;\n" \
  "\n" \
  "                if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "                {\n" \
  "                    /* ancienne région */\n" \
  "                    memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "                    strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "                    givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "                    givrListParu.iNbr++;\n" \
  "                }\n" \
  "\n" \
  "                if ((0 == strcmp(givcLocFictive, doc->value.inscription[0].cLocpar)) && (0 != strcmp(givcLocFictive, doc->value.inscription[0].cCodloc)) && (0 != strlen(doc->value.inscription[0].cCoddep)))\n" \
  "                {\n" \
  "                    /* implicitement parution sur le pôle */\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rub, givrListParu.trEltList[iGeo].rub);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].rubinit, givrListParu.trEltList[iGeo].rubinit);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].nature, givrListParu.trEltList[iGeo].nature);\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].orig = givrListParu.trEltList[iGeo].orig;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].cParuloc = givrListParu.trEltList[iGeo].cParuloc;\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].dep, GIVvPole.acDepPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].loc, GIVvPole.acLocPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].arr, \"00\");\n" \
  "\n" \
  "                    /* région */\n" \
  "                    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                        (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg, GIVvRegion.acRegion);\n" \
  "                    else\n" \
  "                        (void)strcpy(givrListParu.trEltList[givrListParu.iNbr].reg, \"99\");\n" \
  "\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iDbl = aiDbl;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iRgLigne = iIndice;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeo = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoReg = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoDept = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoLoc = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iGeoArr = 99;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[givrListParu.iNbr].iZU = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltRangList[givrListParu.iNbr] = givrListParu.iNbr;\n" \
  "                    givrListParu.iNbr++;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            doc->iGeoLoc = GIV::giv_EXTL;\n" \
  "\n" \
  "            if (0 != strlen(doc->value.inscription[0].cCoddep))\n" \
  "            {\n" \
  "                /* pôle de zone urbaine d'installation  */\n" \
  "                iIntRet = givLectureTabZU(doc->value.inscription[0].cCoddep, doc->value.inscription[0].cCodloc);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                {\n" \
  "                    /* pole de parution */\n" \
  "                    iGeo = givrListParu.iNbr;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "                    givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "                    givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].dep, GIVvPole.acDepPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].loc, GIVvPole.acLocPole);\n" \
  "                    (void)strcpy(givrListParu.trEltList[iGeo].arr, \"00\");\n" \
  "                    /* région */\n" \
  "                    iIntRet = givLectureTabRegion(GIVvPole.acDepPole);\n" \
  "\n" \
  "                    if ((int4)GIV::GIXCodeOK == iIntRet)\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo].reg, GIVvRegion.acRegion);\n" \
  "                    else\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo].reg, \"99\");\n" \
  "\n" \
  "                    givrListParu.trEltList[iGeo].iDbl = aiDbl;\n" \
  "                    givrListParu.trEltList[iGeo].iRgLigne = iIndice;\n" \
  "                    givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "                    givrListParu.trEltList[iGeo].iLF = (int4)GIV::GIXCodeKO;\n" \
  "                    givrListParu.trEltList[iGeo].iZU = (int4)GIV::GIXCodeOK;\n" \
  "                    givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "                    givrListParu.iNbr++;\n" \
  "\n" \
  "                    if ((0 != strcmp(GIVvRegion.acAncReg, GIVvRegion.acRegion)) && (GIV::GIXCodeOK == iIntRet) && (MAX_LIST != givrListParu.iNbr))\n" \
  "                    {\n" \
  "                        /* ancienne région */\n" \
  "                        memcpy(&givrListParu.trEltList[iGeo + 1], &givrListParu.trEltList[iGeo], sizeof(GivrEltListTEpj));\n" \
  "                        strcpy(givrListParu.trEltList[iGeo + 1].reg, GIVvRegion.acAncReg);\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo + 1].dep, \"999\");\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo + 1].loc, \"99999\");\n" \
  "                        (void)strcpy(givrListParu.trEltList[iGeo + 1].arr, \"99\");\n" \
  "                        givrListParu.trEltRangList[iGeo + 1] = iGeo + 1;\n" \
  "                        givrListParu.iNbr++;\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GeoLocParu : %d\\n\", doc->iGeoLoc));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nb Parutions  %d,%d\\n\", givrListInst.iNbr, givrListParu.iNbr));\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "static int4 givMefMultProfParu(GYBrDOCUMENTEpj* doc, int4 aiParuMax)\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 k, l = 0; /* Index de boucle */\n" \
  "    int4 iGeo;\n" \
  "    int4 iNbrParu, iNbrParuMax;\n" \
  "    /* géographie sur rubriques suivantes */\n" \
  "    iNbrParu = givrListParu.iNbr - aiParuMax;\n" \
  "    iNbrParuMax = aiParuMax;\n" \
  "\n" \
  "    for (k = 1; k < doc->value.rubriques.iNban9; k++)\n" \
  "    {\n" \
  "        for (l = 0; l < iNbrParuMax; l++)\n" \
  "        {\n" \
  "            iGeo = givrListParu.iNbr;\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rub, doc->value.rubriques.Tan9[k].val_codan9);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].rubinit, doc->value.rubriques.Tan9[k].val_codan8);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].nature, doc->value.rubriques.Tan9[k].nature);\n" \
  "            givrListParu.trEltList[iGeo].orig = doc->value.rubriques.Tan9[k].orig;\n" \
  "            givrListParu.trEltList[iGeo].cParuloc = doc->value.rubriques.Tan9[k].paru;\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].dep, givrListParu.trEltList[iNbrParu + l].dep);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].loc, givrListParu.trEltList[iNbrParu + l].loc);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].arr, givrListParu.trEltList[iNbrParu + l].arr);\n" \
  "            (void)strcpy(givrListParu.trEltList[iGeo].reg, givrListParu.trEltList[iNbrParu + l].reg);\n" \
  "            givrListParu.trEltList[iGeo].iDbl = givrListParu.trEltList[iNbrParu + l].iDbl;\n" \
  "            givrListParu.trEltList[iGeo].iRgLigne = givrListParu.trEltList[iNbrParu + l].iRgLigne;\n" \
  "            givrListParu.trEltList[iGeo].iGeo = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoReg = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoDept = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoLoc = 99;\n" \
  "            givrListParu.trEltList[iGeo].iGeoArr = 99;\n" \
  "            givrListParu.trEltList[iGeo].iZU = givrListParu.trEltList[iNbrParu + l].iZU;\n" \
  "            givrListParu.trEltList[iGeo].iLF = givrListParu.trEltList[iNbrParu + l].iLF;\n" \
  "            givrListParu.trEltRangList[iGeo] = iGeo;\n" \
  "            givrListParu.iNbr++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"GeoLocParu : %d\\n\", doc->iGeoLoc));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nb Parutions  %d,%d\\n\", givrListInst.iNbr, givrListParu.iNbr));\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givBlocs ()                                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : Ecriture des blocs                                             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givBlocs(char** buf_pos_in, GYBrDOCUMENTEpj* docEPJ, GYBrDOCUMENTEpj* docIG, int4 indice)\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    char* buf_pos_ref;\n" \
  "    char* pcVersion = NULL;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int4 i, j, k, l; /* indices de boucle */\n" \
  "    int4 lg_write;\n" \
  "    int4 iNbrInstMax, iNbrParuMax;\n" \
  "    int4 iNbMicro;\n" \
  "    GYBrIaparuT rIaparu; /* accès GYTtabIaParu */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Pointeur sur debut du bloc */\n" \
  "    buf_pos_ref = buf_pos;\n" \
  "    iCodRet = giv_ecrit_partie_1(&buf_pos, docIG, indice);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_1 ...\\n\"));\n" \
  "\n" \
  "    /* écriture de bloc */\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d\\n\", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep,\n" \
  "                                 givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc,\n" \
  "                                 givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Installation [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep,\n" \
  "                                 givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc,\n" \
  "                                 givrListInst.trEltList[i].iGeoArr));\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < (indice); i++)\n" \
  "    {\n" \
  "        iCodRet = givMefProfInstal((docIG + i), i);\n" \
  "        (docIG + i)->iSource = 1;\n" \
  "    }\n" \
  "\n" \
  "    /* Ajout des parutions multiples */\n" \
  "    for (i = 0; i < (indice); i++)\n" \
  "    {\n" \
  "        if (giv_cCHRO == (docIG + i)->value.inscription[0].val_num[0])\n" \
  "        {\n" \
  "            j = givrListParu.iNbr;\n" \
  "            (void)strcpy(rIaparu.acNumnat, (docIG + i)->value.inscription[0].val_num);\n" \
  "            (void)strcpy(rIaparu.acNumlo, (docIG + i)->value.inscription[0].val_lo);\n" \
  "            (void)strcpy(rIaparu.acNumls, (docIG + i)->value.inscription[0].val_ls);\n" \
  "            iCodRet = GIVLectureIAPARU(&rIaparu, 0);\n" \
  "\n" \
  "            if (0 != (docIG + i)->value.rubriques.iNban9 && 1 != (docIG + i)->value.rubriques.iNban9)\n" \
  "                iCodRet = givMefMultProfParu((docIG + i), (givrListParu.iNbr - j));\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* Analyse ZU selon LF */\n" \
  "    iCodRet = givTriZU();\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution [%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgLigne,\n" \
  "                                 givrListParu.trEltList[i].rub, givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg,\n" \
  "                                 givrListParu.trEltList[i].iGeoDept, givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iRgLigne));\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Installation [%d],[%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].iRgLigne, givrListInst.trEltList[i].rub,\n" \
  "                                 givrListInst.trEltList[i].dep, givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept,\n" \
  "                                 givrListInst.trEltList[i].iGeoLoc, givrListInst.trEltList[i].iGeoArr));\n" \
  "    }\n" \
  "\n" \
  "    /* nombre de CRC (balise <normale>) */\n" \
  "    giviNbCRC = 0;\n" \
  "    givrListCRC.iNbr = 0;\n" \
  "    /* objets par établissement */\n" \
  "    iNbMicro = docIG->value.objets_pub.nb_micro;\n" \
  "    /* lecture des objets de l'etablissement */\n" \
  "    iCodRet = givLectureObjetsEtab(docIG->value.a_classer.etab, docIG, indice);\n" \
  "    /* objets par établissement de type Grand Compte */\n" \
  "    strcpy(docIG->value.objets_pub.libUrlGCpt, \"\");\n" \
  "    /* lecture des objets de l'etablissement */\n" \
  "    iCodRet = givLectureObjetsGCpt(docIG->value.a_classer.etab, docIG, indice);\n" \
  "    iNbMicro = docIG->value.objets_pub.nb_micro - iNbMicro;\n" \
  "\n" \
  "    /* ajout des objets de l'etablissement à chaque MC */\n" \
  "    for (i = 1; i < indice; i++)\n" \
  "    {\n" \
  "        k = docIG->value.objets_pub.nb_micro - iNbMicro;\n" \
  "        l = (docIG + i)->value.objets_pub.nb_micro;\n" \
  "\n" \
  "        for (j = 0; j < iNbMicro; j++)\n" \
  "        {\n" \
  "            strcpy((docIG + i)->value.objets_pub.micro[l + j].type, \"X\");\n" \
  "            strcpy((docIG + i)->value.objets_pub.micro[l + j].stype, docIG->value.objets_pub.micro[k + j].stype);\n" \
  "            strcpy((docIG + i)->value.objets_pub.micro[l + j].sstype, docIG->value.objets_pub.micro[k + j].sstype);\n" \
  "            strcpy((docIG + i)->value.objets_pub.micro[l + j].id, docIG->value.objets_pub.micro[k + j].id);\n" \
  "            strcpy((docIG + i)->value.objets_pub.libUrlGCpt, docIG->value.objets_pub.libUrlGCpt);\n" \
  "        }\n" \
  "\n" \
  "        (docIG + i)->value.objets_pub.nb_micro = l + iNbMicro;\n" \
  "    }\n" \
  "\n" \
  "    /* description des objets au niveau global du bloc epj */\n" \
  "    iIntRet = givInitTriObj(docIG, indice, GIV::giv_RUB);\n" \
  "    iCodRet = giv_ecrit_partie_2_1(&buf_pos, docEPJ, docIG, indice);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_2_1 ...\\n\"));\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Parution [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d],[%d],[%d],[%d]\\n\", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].rub,\n" \
  "                                 givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc, givrListParu.trEltList[i].arr, givrListParu.trEltList[i].reg, givrListParu.trEltList[i].iGeoReg, givrListParu.trEltList[i].iGeoDept,\n" \
  "                                 givrListParu.trEltList[i].iGeoLoc, givrListParu.trEltList[i].iGeoArr, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].iDbl, givrListParu.trEltList[i].iRgLigne));\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListInst.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListInst.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Installation [%d],[%s],[%s],[%s],[%s],[%s],[%d],[%d],[%d],[%d]\\n\", givrListInst.trEltList[i].iRangTri, givrListInst.trEltList[i].rub, givrListInst.trEltList[i].dep,\n" \
  "                                 givrListInst.trEltList[i].loc, givrListInst.trEltList[i].arr, givrListInst.trEltList[i].reg, givrListInst.trEltList[i].iGeoReg, givrListInst.trEltList[i].iGeoDept, givrListInst.trEltList[i].iGeoLoc,\n" \
  "                                 givrListInst.trEltList[i].iGeoArr));\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"parutions\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "    /* tri d'init des rangs d'objet */\n" \
  "    givrListParu.iNbrTot = givrListParu.iNbr;\n" \
  "    givrListInst.iNbrTot = givrListInst.iNbr;\n" \
  "    iIntRet = givInitTriObjGeo(docIG, indice, GIV::giv_RUB);\n" \
  "    iIntRet = givInitTriAn9Geo();\n" \
  "    iIntRet = givInitTriDenomGeo(GIV::giv_RUB);\n" \
  "    /* Tri global sur An9 */\n" \
  "    iIntRet = givTriGeo(docIG, indice, GIV::giv_RUB);\n" \
  "    /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    iCodRet = giv_ecrit_partie_3(&buf_pos, docIG, indice, GIV::giv_RUB);\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_3 An9 ...\\n\"));\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbrTot); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if ((j < givrListParu.iNbr) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[i].iZU))\n" \
  "        {\n" \
  "            /* restauration parution ZU Pôle */\n" \
  "            givrListParu.trEltList[i].iZU = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        givrListParu.trEltList[i].iGeo = 99;\n" \
  "        givrListParu.trEltList[i].iGeoReg = 99;\n" \
  "        givrListParu.trEltList[i].iGeoDept = 99;\n" \
  "        givrListParu.trEltList[i].iGeoLoc = 99;\n" \
  "        givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < (givrListInst.iNbrTot); i++)\n" \
  "    {\n" \
  "        givrListInst.trEltList[i].iGeo = 99;\n" \
  "        givrListInst.trEltList[i].iGeoReg = 99;\n" \
  "        givrListInst.trEltList[i].iGeoDept = 99;\n" \
  "        givrListInst.trEltList[i].iGeoLoc = 99;\n" \
  "        givrListInst.trEltList[i].iGeoArr = 99;\n" \
  "    }\n" \
  "\n" \
  "    givrListParu.iNbr = givrListParu.iNbrTot;\n" \
  "    givrListInst.iNbr = givrListInst.iNbrTot;\n" \
  "    /* tri d'init des rangs de dénomination */\n" \
  "    iIntRet = givInitTriDenomGeo(GIV::giv_DNOM);\n" \
  "    /* Tri global sur Denom */\n" \
  "    iIntRet = givTriGeo(docIG, indice, GIV::giv_DNOM);\n" \
  "    /* Ecriture dans le fichier de sortie en UTF8 */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    iCodRet = giv_ecrit_partie_3(&buf_pos, docIG, indice, GIV::giv_DNOM);\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_3 Denom...\\n\"));\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbrTot); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if ((j < givrListParu.iNbr) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[i].iZU))\n" \
  "        {\n" \
  "            /* restauration parution ZU Pôle */\n" \
  "            givrListParu.trEltList[i].iZU = (int4)GIV::GIXCodeKO;\n" \
  "            givrListParu.trEltList[i].iRgDnom = -1;\n" \
  "        }\n" \
  "\n" \
  "        if (-1 == givrListParu.trEltList[i].iRgGeoTri)\n" \
  "            givrListParu.trEltList[i].iRgDnom = -1;\n" \
  "\n" \
  "        givrListParu.trEltList[i].iGeo = 99;\n" \
  "        givrListParu.trEltList[i].iGeoReg = 99;\n" \
  "        givrListParu.trEltList[i].iGeoDept = 99;\n" \
  "        givrListParu.trEltList[i].iGeoLoc = 99;\n" \
  "        givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < (givrListInst.iNbrTot); i++)\n" \
  "    {\n" \
  "        givrListInst.trEltList[i].iGeo = 99;\n" \
  "        givrListInst.trEltList[i].iGeoReg = 99;\n" \
  "        givrListInst.trEltList[i].iGeoDept = 99;\n" \
  "        givrListInst.trEltList[i].iGeoLoc = 99;\n" \
  "        givrListInst.trEltList[i].iGeoArr = 99;\n" \
  "    }\n" \
  "\n" \
  "    givrListParu.iNbr = givrListParu.iNbrTot;\n" \
  "    givrListInst.iNbr = givrListInst.iNbrTot;\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Pôle ZU Dnom [%d],[%d],[%d],[%s],[%s]\\n\", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgDnom, givrListParu.trEltList[i].iZU,\n" \
  "                                 givrListParu.trEltList[i].dep, givrListParu.trEltList[i].loc));\n" \
  "    }\n" \
  "\n" \
  "    /* init type des contenus de l'établissement */\n" \
  "    giviNbContEtab = 0;\n" \
  "    iIntRet = givLectureTypeContEtab((docIG)->value.a_classer.etab);\n" \
  "\n" \
  "    for (i = 0; i < giviNbContEtab; i++)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Type contenu EPJ [%s],[%s],[%s]\\n\", givrListContEtab[i].tcEtab, givrListContEtab[i].tcType, givrListContEtab[i].tcThm));\n" \
  "\n" \
  "    /* init des contenus prof de l'établissement */\n" \
  "    giviNbProfEtab = 0;\n" \
  "    iIntRet = givLectureContProfEtab((docIG)->value.a_classer.etab);\n" \
  "\n" \
  "    for (i = 0; i < giviNbProfEtab; i++)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"contenu Prof EPJ [%s],[%s],[%s],[%c]\\n\", givrListProfEtab[i].tcType, givrListProfEtab[i].tcEtab, givrListProfEtab[i].tcAn8, givrListProfEtab[i].cIndic));\n" \
  "\n" \
  "    /* tri d'init des rangs d'objet */\n" \
  "    iIntRet = givInitTriObjGeo(docIG, indice, GIV::giv_OBJ);\n" \
  "\n" \
  "    /* Tri global sur objet */\n" \
  "    if (0 != givrListParu.iNbrTri)\n" \
  "    {\n" \
  "        /* présence d'objet */\n" \
  "        iIntRet = givTriGeo(docIG, indice, GIV::giv_OBJ);\n" \
  "        iCodRet = giv_ecrit_partie_3(&buf_pos, docIG, indice, GIV::giv_OBJ);\n" \
  "\n" \
  "        if ('\\0' != GIVBuffXML[0])\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_3 Objet...\\n\"));\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"parutions\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if (0 != givrListObj.iNbrTri)\n" \
  "    {\n" \
  "        /* liens objets-rubriques */\n" \
  "        iCodRet = giv_ecrit_partie_3_obj(&buf_pos, docIG);\n" \
  "    }\n" \
  "\n" \
  "    lg_write = giv_ecrit_noeud_simple(buf_pos, \"inscriptions\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbrTot); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if ((j < givrListParu.iNbr) && ((int4)GIV::GIXCodeOK == givrListParu.trEltList[i].iZU) && (0 != givrListParu.iNbrTri))\n" \
  "        {\n" \
  "            /* restauration parution ZU Pôle */\n" \
  "            givrListParu.trEltList[i].iZU = (int4)GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        givrListParu.trEltList[i].iGeo = 99;\n" \
  "        givrListParu.trEltList[i].iGeoReg = 99;\n" \
  "        givrListParu.trEltList[i].iGeoDept = 99;\n" \
  "        givrListParu.trEltList[i].iGeoLoc = 99;\n" \
  "        givrListParu.trEltList[i].iGeoArr = 99;\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < (givrListInst.iNbrTot); i++)\n" \
  "    {\n" \
  "        givrListInst.trEltList[i].iGeo = 99;\n" \
  "        givrListInst.trEltList[i].iGeoReg = 99;\n" \
  "        givrListInst.trEltList[i].iGeoDept = 99;\n" \
  "        givrListInst.trEltList[i].iGeoLoc = 99;\n" \
  "        givrListInst.trEltList[i].iGeoArr = 99;\n" \
  "    }\n" \
  "\n" \
  "    givrListParu.iNbr = givrListParu.iNbrTot;\n" \
  "    givrListInst.iNbr = givrListInst.iNbrTot;\n" \
  "\n" \
  "    /* analyse Pôle de ZU */\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Pôle ZU [%d],[%d],[%d],[%s],[%s]\\n\", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgDnom, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].dep,\n" \
  "                                 givrListParu.trEltList[i].loc));\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < givrListParu.iNbr; j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        givrListParu.trEltList[i].iRangTri = (int4)0;\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK != givrListParu.trEltList[i].iZU)\n" \
  "            continue;\n" \
  "\n" \
  "        /* validation d'un pôle de ZU */\n" \
  "        for (l = 0; l < givrListParu.iNbr; l++)\n" \
  "        {\n" \
  "            if (l == j)\n" \
  "                continue;\n" \
  "\n" \
  "            k = givrListParu.trEltRangList[l];\n" \
  "\n" \
  "            if ((0 == strcmp(givrListParu.trEltList[i].dep, givrListParu.trEltList[k].dep)) && (0 == strcmp(givrListParu.trEltList[i].loc, givrListParu.trEltList[k].loc))\n" \
  "                    && ((int4)GIV::GIXCodeOK != givrListParu.trEltList[k].iZU))\n" \
  "            {\n" \
  "                /* validation */\n" \
  "                givrListParu.trEltList[k].iRangTri = (int4) - 1;\n" \
  "                break;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (givrListParu.iNbr == l)\n" \
  "        {\n" \
  "            /* pas de validation */\n" \
  "            givrListParu.trEltList[i].iRangTri = (int4) - 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < givrListParu.iNbr; j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if ((-1 == givrListParu.trEltList[i].iRgDnom) && (0 == givrListParu.trEltList[i].iRangTri) && ((int4)GIV::GIXCodeOK != givrListParu.trEltList[i].iZU))\n" \
  "            givrListParu.trEltList[i].iRangTri = -1;\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListParu.trEltRangList[j];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Pôle ZU Ins [%d],[%d],[%d],[%s],[%s]\\n\", givrListParu.trEltList[i].iRangTri, givrListParu.trEltList[i].iRgDnom, givrListParu.trEltList[i].iZU, givrListParu.trEltList[i].dep,\n" \
  "                                 givrListParu.trEltList[i].loc));\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        /* Tri par ligne */\n" \
  "        iIntRet = givTriGeoIns(docIG + i, i);\n" \
  "        iCodRet = giv_ecrit_partie_2_2(&buf_pos, docIG + i, i, docIG, indice);\n" \
  "\n" \
  "        if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_2_2 ...\\n\"));\n" \
  "\n" \
  "        iCodRet = giv_ecrit_partie_3_ins(&buf_pos, docIG + i, indice);\n" \
  "\n" \
  "        if ('\\0' != GIVBuffXML[0])\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_3_INS ...\\n\"));\n" \
  "    }\n" \
  "\n" \
  "    iCodRet = giv_ecrit_partie_2_3(&buf_pos, docIG, indice);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"ECRITURE PARTIE_2_3 ...\\n\"));\n" \
  "\n" \
  "    /* Fin document */\n" \
  "    lg_write = giv_ecrit_fin_noeud(&buf_pos, \"document\");\n" \
  "    buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    /* enrichissement du bloc */\n" \
  "    if ((int4)GIV::GIXCodeOK == giviEnrich)\n" \
  "    {\n" \
  "        GIVAnnulerBlocCGenTest = 0;\n" \
  "        iIntRet = GIVEnrichirTest(docIG->value.a_classer.etab, GIVBuffTest, givtcMoteur);\n" \
  "\n" \
  "        if (iIntRet != GIV::GWZOk)\n" \
  "        {\n" \
  "            sprintf(GIVBuffTest, \"<!-- Non-generation du bloc EPJ pour l'etab %s pour cause d'echec CGenTest -->\\n\", docIG->value.a_classer.etab);\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Non-generation du bloc EPJ pour l'etab %s pour cause d'echec CGenTest\\n\", docIG->value.a_classer.etab));\n" \
  "            GIVAnnulerBlocCGenTest = 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    pcVersion = strchr(pcVersionInsFour[0], (char)'.');\n" \
  "    pcVersion++;\n" \
  "    iIntRet = givFin(&buf_pos, docIG->parution_id);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "    {\n" \
  "        /* Erreur sur ecriture fin document */\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Erreur sur ecriture fin document dans partie_3 ...\\n\"));\n" \
  "        iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = GIVBuffXML;\n" \
  "    /* Effacement du buffer */\n" \
  "    GIVBuffXML[0] = '\\0';\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givDelIeBlocCRC                                                */\n" \
  "/*                                                                            */\n" \
  "/* But       : suppression des CRC du bloc dans GYTtabIeBlocCRC               */\n" \
  "/*             de l'ensemble du bloc                                          */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, documents                                           */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Création (Oct/04/2012 - mb)                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givDelIeBlocCRC(char* acBlocid)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cBlocid[26 + 1];\n" \
  "    char tcRequete[1024];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"Suppression anciens blocs GYTtabIeBlocCRC\");\n" \
  "    (void)strcpy(cBlocid, acBlocid);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"blocid  : %s\\n\", cBlocid));\n" \
  "    EXEC SQL\n" \
  "    execute rqtDelIeBlocCRC\n" \
  "    using :cBlocid;\n" \
  "    iCodRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    /* Analyse du code resultat SQL */\n" \
  "    if (((int4)GIV::GWCCodeOK != iCodRet) && ((int4)GIV::GYBnodata != iCodRet))\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givInsIeBlocCRC                                                */\n" \
  "/*                                                                            */\n" \
  "/* But       : insertion d'un CRC du bloc dans GYTtabIeBlocCRC                */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, documents                                           */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Création (Oct/04/2012 - mb)                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givInsIeBlocCRC(void)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 i, p;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPrioCRCT* prOraPrioCRC;\n" \
  "    char cBlocid[26 + 1];\n" \
  "    char tcRequete[1024];\n" \
  "    char* pcVersion;\n" \
  "    /* tables pour insertion globale */\n" \
  "    int4 j;\n" \
  "    char tcVersion[MAX_LIST_CRC][GXWLgIdDonnees]; /* version du bloc */\n" \
  "    GYBstrBlocBlocidT trBlocid[MAX_LIST_CRC]; /* numero de bloc */\n" \
  "    GYBstrPrioTypeT trType[MAX_LIST_CRC]; /* type de crc */\n" \
  "    char tcCodan8[MAX_LIST_CRC][GYBIaprofLgCodan8 + 1]; /* code AN8 */\n" \
  "    char tcTpdsob[MAX_LIST_CRC][GYBIamicLgTpdsob + 1]; /* source (type dans l objet) */\n" \
  "    GYBstrIeinscEtabT trEtab[MAX_LIST_CRC]; /* code etablissement */\n" \
  "    GYBstrPrioCRCT trCRC[MAX_LIST_CRC]; /* contenu  CRC */\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    static int4 iDejaPrepare = (int4)GIV::GWCCodeKO;\n" \
  "    /* version du bloc */\n" \
  "    pcVersion = strchr(pcVersionInsFour[0], (char)'.');\n" \
  "    pcVersion++;\n" \
  "    j = 0;\n" \
  "\n" \
  "    for (i = 0; i < givrListCRC.iNbr; i++)\n" \
  "    {\n" \
  "        p = givrListCRC.trEltRangList[i];\n" \
  "\n" \
  "        if ((0 != strlen(givrListCRC.trEltList[p].acEtab)) && (-1 != givrListCRC.trEltList[p].iRgEtab) && (-1 != givrListCRC.trEltList[p].iRgCRC))\n" \
  "        {\n" \
  "            /* insetion CRC sur blocid dans GYTtabIeBlocCRC */\n" \
  "            (void)strcpy(tcVersion[j], pcVersion);\n" \
  "            (void)strcpy(trBlocid[j], nom_bloc_ref);\n" \
  "            (void)strcpy(tcCodan8[j], givrListCRC.trEltList[p].acCodan8);\n" \
  "            (void)strcpy(tcTpdsob[j], givrListCRC.trEltList[p].acTpdsob);\n" \
  "            (void)strcpy(trType[j], givrListCRC.trEltList[p].acType);\n" \
  "            (void)strcpy(trEtab[j], givrListCRC.trEltList[p].acEtab);\n" \
  "            (void)strcpy(trCRC[j], givrListCRC.trEltList[p].acCRC);\n" \
  "            j++;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (0 == j)\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    if ((int4)GIV::GWCCodeOK != iDejaPrepare)\n" \
  "    {\n" \
  "        (void)sprintf(tcRequete, GIV_INS_IEBLOC_CRC, GIXcNomDest);\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Insertion bloc GYTtabIeBlocCRC\");\n" \
  "        EXEC SQL\n" \
  "        prepare rqtInsIeBlocCRC\n" \
  "        from: tcRequete;\n" \
  "        iDejaPrepare = (int4)GIV::GWCCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"blocid  : %s\\n\", nom_bloc_ref));\n" \
  "    EXEC SQL\n" \
  "    FOR :j execute\n" \
  "    rqtInsIeBlocCRC\n" \
  "    using :trBlocid,\n" \
  "    :trEtab,\n" \
  "    :trCRC,\n" \
  "    :trType,\n" \
  "    :tcCodan8,\n" \
  "    :tcTpdsob,\n" \
  "    :tcVersion;\n" \
  "    iCodRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    /* Analyse du code resultat SQL */\n" \
  "    if ((int4)GIV::GWCCodeOK != iCodRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"echec insert crc : %s,%s\\n\", nom_bloc_ref, pcVersion));\n" \
  "        GWTTrace(GWT_NIV_BIZAR, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givGroupement ()                                               */\n" \
  "/*                                                                            */\n" \
  "/* But       : Ecriture des blocs groupement simples et clones                */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Modification (Nov/14/1997 lgu) : V2 ajout objet 11 micro                   */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givGroupement(char** buf_pos_in, GYBrDOCUMENTEpj* docEPJ, GYBrDOCUMENTEpj* docIG, int4 indice)\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    int4 i, m, n, p;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cBlocid[26 + 1];\n" \
  "    char tcRequete[1024];\n" \
  "    char cDepart[GYBIeinscLgDeppar + 1];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    GYBstrIeinscDenomT rDenom;\n" \
  "    int4 iRang;\n" \
  "    giviPart = (int4)GIV::GWCCodeOK;\n" \
  "\n" \
  "    for (p = 0; p < indice; p++)\n" \
  "    {\n" \
  "        if (('0' <= (docIG + p)->value.inscription[0].val_num[0]) && ('9' >= (docIG + p)->value.inscription[0].val_num[0]))\n" \
  "        {\n" \
  "            giviPart = (int4)GIV::GWCCodeKO;\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"part :'%s', '%d'\\n\", docIG->value.inscription[0].val_num, giviPart));\n" \
  "\n" \
  "    for (p = 1; p < indice; p++)\n" \
  "    {\n" \
  "        if (docIG->iRang != (docIG + p)->iRang)\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    /* enrichissement du bloc */\n" \
  "    giviEnrich = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "    for (n = 0; n < GIViNbEPJTest; n++)\n" \
  "    {\n" \
  "        if (0 == strcmp(docIG->value.a_classer.etab, GIVtrEPJTest[n]))\n" \
  "        {\n" \
  "            /* enrichissement configuré */\n" \
  "            giviEnrich = (int4)GIV::GIXCodeOK;\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Enrichissement :'%d'\\n\", giviEnrich));\n" \
  "    /* Rang de tri de dénomination dans document d'une ligne */\n" \
  "    strcpy(rDenom, \"      \");\n" \
  "    iRang = -1;\n" \
  "\n" \
  "    for (n = 0; n < indice; n++)\n" \
  "    {\n" \
  "        if ((0 != strcmp(rDenom, (docIG + n)->value.intitule.denomination)) || (0 == n))\n" \
  "        {\n" \
  "            /* rang denom identique au rang de doc */\n" \
  "            iRang = n;\n" \
  "            strcpy(rDenom, (docIG + n)->value.intitule.denomination);\n" \
  "        }\n" \
  "\n" \
  "        (docIG + n)->value.intitule.iRgDnom = iRang;\n" \
  "        sprintf((docIG + n)->value.intitule.tcRgDnom, \"%04d\", iRang);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"dénom triées :'%d', '%s'\\n\", iRang, (docIG + n)->value.intitule.tcRgDnom));\n" \
  "    }\n" \
  "\n" \
  "    /* Report du numéro de client sur toutes les lignes */\n" \
  "    for (n = 0; n < indice; n++)\n" \
  "    {\n" \
  "        if (0 != strlen((docIG + n)->value.numero_client))\n" \
  "        {\n" \
  "            for (m = 0; m < indice; m++)\n" \
  "            {\n" \
  "                if (0 == strlen((docIG + m)->value.numero_client))\n" \
  "                    strcpy((docIG + m)->value.numero_client, (docIG + n)->value.numero_client);\n" \
  "            }\n" \
  "\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* au moins un bloc à écrire */\n" \
  "    iMaxBlocEcritAvant++;\n" \
  "    giviCodRetEcr = (int4)GIV::GIXCodeOK;\n" \
  "    /* Bloc ordonné par rang  */\n" \
  "    iCodRet = givBlocs(&buf_pos, docEPJ, docIG, indice);\n" \
  "\n" \
  "    if ((int4)GIV::GIXCodeOK != giviCodRetEcr)\n" \
  "    {\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        givrListParu.iNbr = 0;\n" \
  "        givrListInst.iNbr = 0;\n" \
  "    }\n" \
  "\n" \
  "    if (!GIVAnnulerBlocCGenTest)\n" \
  "    {\n" \
  "        if (0 == strcmp(GIVtcGeneIeBloc, \"OUI\"))\n" \
  "        {\n" \
  "            /* suppressions de lignes du blocid */\n" \
  "            (void)strcpy(vErreurSQL.acOrdre_sql, \"Suppression anciens blocs GYTtabIeBloc\");\n" \
  "            (void)strcpy((char*)cDepart, (const char*)GIXcDepartement);\n" \
  "            (void)strcpy(cBlocid, nom_bloc_ref);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"blocid  : %s\\n\", cBlocid));\n" \
  "            EXEC SQL\n" \
  "            execute rqtDelIeBloc\n" \
  "            using\n" \
  "            :cDepart,\n" \
  "            :cBlocid;\n" \
  "            iCodRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            /* Analyse du code resultat SQL */\n" \
  "            if (((int4)GIV::GWCCodeOK != iCodRet) && ((int4)GIV::GYBnodata != iCodRet))\n" \
  "                GWTTrace(GWT_NIV_BIZAR, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "\n" \
  "            /* maj table des blocs pour un bloc à la source */\n" \
  "            for (i = 0; (i < indice); i++)\n" \
  "            {\n" \
  "                /* ligne par ligne */\n" \
  "                iCodRet = giv_ecrit_tabIeBloc(docIG + i);\n" \
  "            }\n" \
  "\n" \
  "            if ((0 == strcmp(\"OUI\", givtcGeneIeBlocCRC)) && (0 != strcmp(givRecreerCD, GIXcNomFour)))\n" \
  "            {\n" \
  "                /* suppression sur blocid dans GYTtabIeBlocCRC */\n" \
  "                iCodRet = givDelIeBlocCRC(nom_bloc_ref);\n" \
  "            }\n" \
  "\n" \
  "            /* mise à jour TabIeBlocCRC */\n" \
  "            if (0 == strcmp(\"OUI\", givtcGeneIeBlocCRC))\n" \
  "                iCodRet = givInsIeBlocCRC();\n" \
  "        }\n" \
  "\n" \
  "        if ((int4)GIV::GWCCodeOK == iCodRet)\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"ECRITURE TABLE BLOCS DE PARUTIONS ...\\n\"));\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    /* init liste des codes géographiques du bloc */\n" \
  "    givrListParu.iNbr = 0;\n" \
  "    givrListInst.iNbr = 0;\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritContenu()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les contenus SGIPRO                                      */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification (Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritContenu(char* obj, char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice, int4* picvi)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i, k, kk = 0;\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos, *buf_pos_ref;\n" \
  "    char* pt_fin_liste;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_mil_element;\n" \
  "    char* pt_suite_element;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iRet = GIV::GWCCodeKO; /* Code retour de la fonction */\n" \
  "    char tcType[3 + 1];\n" \
  "    char tcObj[3 + 1] = \"\";\n" \
  "    char tcBalise[50 + 1];\n" \
  "    int4 lg_a_ecrire;\n" \
  "    int4 iRang, iObj, iRef, iMC, iBalise;\n" \
  "    GYBrIamicT rIamic;\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    if (0 != strlen(obj))\n" \
  "    {\n" \
  "        strcpy(tcObj, obj);\n" \
  "        tcObj[0] = toupper(tcObj[0]);\n" \
  "        tcObj[1] = toupper(tcObj[1]);\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Ecriture Contenu %s, %s\\n\", obj, tcObj));\n" \
  "    pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "\n" \
  "    for (pt_debut_element = givtcObjCont; pt_debut_element < pt_fin_liste;)\n" \
  "    {\n" \
  "        pt_fin_element = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "        if (pt_fin_element == 0)\n" \
  "            pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "        pt_mil_element = strchr(pt_debut_element, '/');\n" \
  "\n" \
  "        if (pt_mil_element == 0)\n" \
  "            break;\n" \
  "\n" \
  "        pt_suite_element = 0;\n" \
  "        iRet = (int4)GIV::GIXCodeKO;\n" \
  "        buf_pos_ref = buf_pos;\n" \
  "\n" \
  "        while (pt_suite_element < pt_mil_element)\n" \
  "        {\n" \
  "            pt_suite_element = strchr(pt_debut_element, '|');\n" \
  "\n" \
  "            if (pt_suite_element == 0 || pt_suite_element > pt_mil_element)\n" \
  "                pt_suite_element = pt_mil_element;\n" \
  "\n" \
  "            /* analyse type et balise associés */\n" \
  "            /*memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));*/\n" \
  "            memcpy(tcType, pt_debut_element, (pt_suite_element - pt_debut_element));\n" \
  "            tcType[(pt_mil_element - pt_debut_element)] = '\\0';\n" \
  "            tcType[0] = toupper(tcType[0]);\n" \
  "            tcType[1] = toupper(tcType[1]);\n" \
  "            memcpy(tcBalise, (pt_mil_element + 1), (pt_fin_element - pt_mil_element - 1));\n" \
  "            tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\\0';\n" \
  "            iRang = -1;\n" \
  "            iRef = -1;\n" \
  "            iMC = -1;\n" \
  "            iBalise = GIV::GIXCodeKO;\n" \
  "            GIVBuffInter[0] = '\\0';\n" \
  "            GIVBuffClob[0] = '\\0';\n" \
  "\n" \
  "            if ((0 != strlen(obj)) && (0 != strcmp(tcType, tcObj)) && ((int4)GIV::GIXCodeKO == iRet))\n" \
  "            {\n" \
  "                /* hors configuration prioritaire */\n" \
  "                break;\n" \
  "            }\n" \
  "            else\n" \
  "                for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Ecriture Contenu %s, %s, %s\\n\", obj, tcObj, tcType));\n" \
  "                    k = givrListObj.trEltRangListObj[i];\n" \
  "                    kk = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "                    iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "                    if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].type, \"X\")) && (iRang != givrListObj.trEltListObj[k].iRangTri))\n" \
  "                    {\n" \
  "                        iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Annonceur : %d,%d,%s\\n\", (doc + kk)->value.objets_pub.micro[iObj].iCVI, *picvi, (doc + kk)->value.objets_pub.micro[iObj].id));\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Objet Contenu %s, %s\\n\", (doc + kk)->value.objets_pub.micro[iObj].stype, (doc + kk)->value.objets_pub.micro[iObj].sstype));\n" \
  "\n" \
  "                        if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"SC\")) && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"PV\")))\n" \
  "                        {\n" \
  "                            /* contenu valide uniquement pour SC-PV */\n" \
  "                            continue;\n" \
  "                        }\n" \
  "                        else if ((0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"LC\")) && (0 != strcmp((doc + kk)->value.objets_pub.micro[iObj].sstype, \"CH\")))\n" \
  "                        {\n" \
  "                            /* contenu valide uniquement pour chronoresto LC-CH */\n" \
  "                            continue;\n" \
  "                        }\n" \
  "\n" \
  "                        if (0 == strcmp(tcType, (doc + kk)->value.objets_pub.micro[iObj].stype))\n" \
  "                        {\n" \
  "                            if (GIV::GIXCodeKO == *picvi && 2 == (doc + kk)->value.objets_pub.micro[iObj].iCVI)\n" \
  "                            {\n" \
  "                                /* nouveau CVI traité à part */\n" \
  "                                continue;\n" \
  "                            }\n" \
  "\n" \
  "                            if (GIV::GIXCodeKO != *picvi && 2 != (doc + kk)->value.objets_pub.micro[iObj].iCVI)\n" \
  "                            {\n" \
  "                                /* hors nouveau CVI traité à part */\n" \
  "                                continue;\n" \
  "                            }\n" \
  "\n" \
  "                            (doc + kk)->value.objets_pub.micro[iObj].iCont = 1;\n" \
  "                        }\n" \
  "                        else\n" \
  "                            continue;\n" \
  "\n" \
  "                        /* écriture SGIPRO */\n" \
  "                        if (0 == strcmp(tcObj, obj))\n" \
  "                        {\n" \
  "                            /* accès à un fichier */\n" \
  "                            if (GIV::GIXCodeKO == *picvi)\n" \
  "                                iCodRet = givEcritSgiPro(&buf_pos, doc, kk, iObj, indice, tcBalise, GIV::GIXCodeKO);\n" \
  "                            else if (GIV::GIXCodeOK == *picvi)\n" \
  "                                iCodRet = givEcritSgiPro(&buf_pos, doc, kk, iObj, indice, \"affcviv\", iRet);\n" \
  "                            else\n" \
  "                            {\n" \
  "                                /* nouvel objet CVI */\n" \
  "                                iCodRet = givEcritSgiPro(&buf_pos, doc, kk, iObj, indice, tcBalise, GIV::GIXCodeOK);\n" \
  "                            }\n" \
  "                        }\n" \
  "                        else\n" \
  "                        {\n" \
  "                            /* accès à la base */\n" \
  "                            if (0 == strcmp(\"MO\", (doc + kk)->value.objets_pub.micro[iObj].stype))\n" \
  "                            {\n" \
  "                                if ((0 != memcmp(&rIamic.acNumobj[4], &(doc + kk)->value.objets_pub.micro[iObj].id[4], 8)) && (0 != strlen(GIVBuffInter)))\n" \
  "                                {\n" \
  "                                    GWTTrace(GWT_NIV_FONCT, (\"Ecriture Mots Cles 1 %d\\n\", iRef));\n" \
  "\n" \
  "                                    if (GIV::GIXCodeKO == iBalise)\n" \
  "                                    {\n" \
  "                                        iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, tcBalise);\n" \
  "                                        iBalise = GIV::GIXCodeOK;\n" \
  "                                    }\n" \
  "                                    else\n" \
  "                                        iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, \"\");\n" \
  "\n" \
  "                                    GIVBuffInter[0] = '\\0';\n" \
  "                                    GIVBuffClob[0] = '\\0';\n" \
  "                                }\n" \
  "\n" \
  "                                (void)strcpy(rIamic.acNumobj, (doc + kk)->value.objets_pub.micro[iObj].id);\n" \
  "                                iCodRet = givLectureMotsCles(&rIamic);\n" \
  "\n" \
  "                                if (0 != strlen(GIVBuffInter))\n" \
  "                                {\n" \
  "                                    iRef = kk;\n" \
  "                                    iMC = iObj;\n" \
  "                                }\n" \
  "                            }\n" \
  "                            else if (GIV::GIXCodeKO == *picvi)\n" \
  "                                iCodRet = givEcritDonAnnonceur(&buf_pos, doc, kk, iObj, indice, tcBalise, GIV::GIXCodeKO);\n" \
  "                            else if (GIV::GIXCodeOK == *picvi)\n" \
  "                                iCodRet = givEcritDonAnnonceur(&buf_pos, doc, kk, iObj, indice, \"affcviv\", iRet);\n" \
  "                            else\n" \
  "                            {\n" \
  "                                /* nouvel objet CVI */\n" \
  "                                iCodRet = givEcritDonAnnonceur(&buf_pos, doc, kk, iObj, indice, tcBalise, GIV::GIXCodeOK);\n" \
  "                            }\n" \
  "                        }\n" \
  "\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"En-tête 1 : %d,%d\\n\", iCodRet, iRet));\n" \
  "\n" \
  "                        if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "                        {\n" \
  "                            iRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "                            if ((GIV::GIXCodeKO == *picvi) && (0 != strcmp(\"MO\", (doc + kk)->value.objets_pub.micro[iObj].stype)))\n" \
  "                            {\n" \
  "                                lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "                                buf_pos = buf_pos + lg_write;\n" \
  "                            }\n" \
  "                        }\n" \
  "                        else if ((int4)GIV::GIXCodeOK != iRet)\n" \
  "                            iRet = (int4)GIV::GIXCodeRIEN;\n" \
  "\n" \
  "                        if ((GIV::GIXCodeOK == *picvi) && ((int4)GIV::GIXCodeOK != iCodRet))\n" \
  "                        {\n" \
  "                            /* nouvel objet CVI sans contenu associé */\n" \
  "                            (doc + kk)->value.objets_pub.micro[iObj].iCVI = 3;\n" \
  "                        }\n" \
  "\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"En-tête 2 : %d,%d\\n\", iCodRet, iRet));\n" \
  "                    }\n" \
  "                } /* Fin boucle */\n" \
  "\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"En-tête 3 : %d,%d\\n\", iRet, *picvi));\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iRet)\n" \
  "            {\n" \
  "                if ((0 == strcmp(\"MO\", tcType)) && (0 != strlen(GIVBuffInter)))\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Ecriture Mots Cles 3 %d\\n\", iRef));\n" \
  "\n" \
  "                    if (GIV::GIXCodeKO == iBalise)\n" \
  "                    {\n" \
  "                        iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, tcBalise);\n" \
  "                        iBalise = GIV::GIXCodeOK;\n" \
  "                    }\n" \
  "                    else\n" \
  "                        iCodRet = givEcritureMotsCles(&buf_pos, doc, iRef, iMC, indice, \"\");\n" \
  "\n" \
  "                    GIVBuffInter[0] = '\\0';\n" \
  "                    GIVBuffClob[0] = '\\0';\n" \
  "                }\n" \
  "\n" \
  "                if (GIV::GIXCodeOK == iBalise)\n" \
  "                {\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Ecriture Mots Cles 4 %d\\n\", iRef));\n" \
  "                    lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    iBalise = GIV::GIXCodeKO;\n" \
  "                }\n" \
  "\n" \
  "                if (GIV::GIXCodeOK == *picvi)\n" \
  "                    *picvi = GIV::GIXCodeRIEN;\n" \
  "\n" \
  "                pt_suite_element = pt_mil_element;\n" \
  "            }\n" \
  "            else if ((int4)GIV::GIXCodeRIEN == iRet)\n" \
  "                pt_debut_element = pt_suite_element + 1;\n" \
  "            else\n" \
  "                pt_suite_element = pt_mil_element;\n" \
  "        }\n" \
  "\n" \
  "        pt_debut_element = pt_fin_element + 1;\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Contenu\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritPart()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les contenus SGIPRO de partenaires                       */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification (Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritPart(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i, q = 0;\n" \
  "    int4 lg_write;\n" \
  "    int4 iDebut;\n" \
  "    char* buf_pos;\n" \
  "    char* buf_pos_part;\n" \
  "    char* pt_fin_liste;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_suite_element;\n" \
  "    char* pt_mil_element;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char tcType[3 + 1];\n" \
  "    char tcTYPE[3 + 1];\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBalises[50 + 2];\n" \
  "    char tcElmt[29 + 1]; /* partenaire*/\n" \
  "    int4 lg_a_ecrire;\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 iRet;\n" \
  "    /* pas de gestion de conflit */\n" \
  "    giviConflitCRC = GIV::GWCCodeKO;\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "\n" \
  "    for (pt_debut_element = givtcObjCont; pt_debut_element < pt_fin_liste;)\n" \
  "    {\n" \
  "        pt_fin_element = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "        if (pt_fin_element == 0)\n" \
  "            pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "        pt_mil_element = strchr(pt_debut_element, '/');\n" \
  "\n" \
  "        if (pt_mil_element == 0)\n" \
  "            break;\n" \
  "\n" \
  "        /* analyse premier type et balise associés */\n" \
  "        pt_suite_element = strchr(pt_debut_element, '|');\n" \
  "\n" \
  "        if ((pt_suite_element != 0) && (pt_suite_element < pt_mil_element))\n" \
  "        {\n" \
  "            memcpy(tcType, pt_debut_element, (pt_suite_element - pt_debut_element));\n" \
  "            tcType[(pt_suite_element - pt_debut_element)] = '\\0';\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));\n" \
  "            tcType[(pt_mil_element - pt_debut_element)] = '\\0';\n" \
  "        }\n" \
  "\n" \
  "        strcpy(tcTYPE, tcType);\n" \
  "        tcTYPE[0] = toupper(tcTYPE[0]);\n" \
  "        tcTYPE[1] = toupper(tcTYPE[1]);\n" \
  "        memcpy(tcBalise, (pt_mil_element + 1), (pt_fin_element - pt_mil_element - 1));\n" \
  "        tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\\0';\n" \
  "        strcpy(tcBalises, tcBalise);\n" \
  "        /* strcat(tcBalises,\"s\"); */\n" \
  "\n" \
  "        if ((0 == strcmp(tcTYPE, \"DC\")) || (0 == strcmp(tcTYPE, \"RA\")))\n" \
  "        {\n" \
  "            /* enrichissement des partenaires */\n" \
  "            /* écriture SGIPRO */\n" \
  "            iDebut = 1;\n" \
  "\n" \
  "            if ((0 != strlen(doc->value.a_classer.etab)) && (0 == strcmp(tcTYPE, \"DC\")))\n" \
  "            {\n" \
  "                /* établissement */\n" \
  "                if (0 == strcmp(tcTYPE, tcType))\n" \
  "                {\n" \
  "                    /* accès à un fichier */\n" \
  "                    iCodRet = givEcritSgiProPart(&buf_pos, doc, doc->value.a_classer.etab, doc->value.a_classer.etab, tcType, tcBalise, &iDebut);\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    /* accès à la base */\n" \
  "                    iCodRet = givEcritDonEtab(tcTYPE, tcBalise, &buf_pos, *buf_pos_in, doc, \"\", \"\", \"\", &iDebut);\n" \
  "                }\n" \
  "            }\n" \
  "            else if ((0 != strlen(doc->value.a_classer.etab)) && (0 == strcmp(tcTYPE, \"RA\")))\n" \
  "            {\n" \
  "                if (0 == strcmp(tcTYPE, tcType))\n" \
  "                {\n" \
  "                    /* accès à un fichier */\n" \
  "                    iCodRet = givEcritSgiProBOC(&buf_pos, doc, indice, doc->value.a_classer.etab, tcType, tcBalise);\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    /* accès à la base */\n" \
  "                    iCodRet = givEcritDonEtab(tcTYPE, tcBalise, &buf_pos, *buf_pos_in, doc, \"\", \"\", \"\", &iDebut);\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        pt_debut_element = pt_fin_element + 1;\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Contenu\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givAffCRCEtab                                                  */\n" \
  "/*                                                                            */\n" \
  "/* But       : liste des balises NORMALE par epj                              */\n" \
  "/*             de l'ensemble du bloc                                          */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, documents                                           */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Création    (Oct/01/2012 - mb)                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givAffCRCEtab(char** buf_pos_in)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_write, lg_ecr = 0;\n" \
  "    int4 lg;\n" \
  "    int4 i, j, k, l, p, q, r, rr;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    char tcElmt[GYBLgPrioCRC2]; /* CRC normale */\n" \
  "    GYBrPrioCRCT rPrioCRC;\n" \
  "    int4 iNbEtabCRC, iNbCRCCRC;\n" \
  "    int4 iRgEtabCRC, iRgCRCCRC;\n" \
  "    int4 iRgEtab, iRgCRC;\n" \
  "    int4 iRangDeb;\n" \
  "    int4 iBLEtab;\n" \
  "\n" \
  "    if (0 == giviNbCRC)\n" \
  "    {\n" \
  "        /* pas de nouveau CRC */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    givrListCRC.iNbr = giviNbCRC;\n" \
  "\n" \
  "    for (i = 0; i < givrListCRC.iNbr; i++)\n" \
  "    {\n" \
  "        p = givrListCRC.trEltRangList[i];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"crc init : %d,%d,%d,%s\\n\", givrListCRC.iNbr, i, p, givrListCRC.trEltList[p].acEtab));\n" \
  "    }\n" \
  "\n" \
  "    /* trier en fonction des crc */\n" \
  "    qsort(givrListCRC.trEltRangList, givrListCRC.iNbr, sizeof(int4), givCompListCRC);\n" \
  "\n" \
  "    /* suppression autres crc sans epj */\n" \
  "    for (i = 0; i < giviNbCRC; i++)\n" \
  "    {\n" \
  "        p = givrListCRC.trEltRangList[i];\n" \
  "\n" \
  "        if (0 == strlen(givrListCRC.trEltList[p].acEtab))\n" \
  "            break;\n" \
  "    }\n" \
  "\n" \
  "    if (0 != i)\n" \
  "        givrListCRC.iNbr = i;\n" \
  "\n" \
  "    /* référence courante */\n" \
  "    (void)strcpy(rPrioCRC.acEtab, \"00000000\");\n" \
  "    (void)strcpy(rPrioCRC.acCodan8, \"\");\n" \
  "    iRgEtab = -1;\n" \
  "    iRgCRC = -1;\n" \
  "    iBLEtab = -1;\n" \
  "\n" \
  "    /* rang de chaque etab et de chaque crc */\n" \
  "    for (i = 0; i < givrListCRC.iNbr; i++)\n" \
  "    {\n" \
  "        p = givrListCRC.trEltRangList[i];\n" \
  "\n" \
  "        if ((0 != strcmp(rPrioCRC.acEtab, givrListCRC.trEltList[p].acEtab)) || (0 == i))\n" \
  "        {\n" \
  "            iRgEtab++;\n" \
  "            iRgCRC = 0;\n" \
  "        }\n" \
  "        else if (0 != strcmp(rPrioCRC.acCodan8, givrListCRC.trEltList[p].acCodan8))\n" \
  "            iRgCRC++;\n" \
  "\n" \
  "        givrListCRC.trEltList[p].iRgEtab = iRgEtab;\n" \
  "        givrListCRC.trEltList[p].iRgCRC = iRgCRC;\n" \
  "\n" \
  "        if (((0 != strcmp(rPrioCRC.acEtab, givrListCRC.trEltList[p].acEtab)) || (0 == i)) && (0 != strlen(givrListCRC.trEltList[p].acEtab)))\n" \
  "        {\n" \
  "            /* analyse du black-listage en fiche détaillée sur EPJ */\n" \
  "            iCodRet = givLectureBListEPJFD(givrListCRC.trEltList[p].acEtab);\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "            {\n" \
  "                givrListCRC.trEltList[p].iRgEtab = -1;\n" \
  "                givrListCRC.trEltList[p].iRgCRC = -1;\n" \
  "                iBLEtab = 0;\n" \
  "            }\n" \
  "            else\n" \
  "                iBLEtab = -1;\n" \
  "        }\n" \
  "        else if ((0 == strcmp(rPrioCRC.acEtab, givrListCRC.trEltList[p].acEtab)) && (0 == strcmp(rPrioCRC.acTpdsob, givrListCRC.trEltList[p].acTpdsob))\n" \
  "                 && (0 == strcmp(rPrioCRC.acCRC, givrListCRC.trEltList[p].acCRC)) && (0 == strcmp(rPrioCRC.acCodan8, givrListCRC.trEltList[p].acCodan8))\n" \
  "                 && (0 == strcmp(rPrioCRC.acType, givrListCRC.trEltList[p].acType)))\n" \
  "        {\n" \
  "            /* crc en double */\n" \
  "            givrListCRC.trEltList[p].iRgEtab = -1;\n" \
  "            givrListCRC.trEltList[p].iRgCRC = -1;\n" \
  "        }\n" \
  "        else if ((0 == strcmp(rPrioCRC.acEtab, givrListCRC.trEltList[p].acEtab)) && (0 == iBLEtab))\n" \
  "        {\n" \
  "            /* bl sur même epj */\n" \
  "            givrListCRC.trEltList[p].iRgEtab = -1;\n" \
  "            givrListCRC.trEltList[p].iRgCRC = -1;\n" \
  "        }\n" \
  "\n" \
  "        strcpy(rPrioCRC.acEtab, givrListCRC.trEltList[p].acEtab);\n" \
  "        strcpy(rPrioCRC.acTpdsob, givrListCRC.trEltList[p].acTpdsob);\n" \
  "        strcpy(rPrioCRC.acCRC, givrListCRC.trEltList[p].acCRC);\n" \
  "        strcpy(rPrioCRC.acCodan8, givrListCRC.trEltList[p].acCodan8);\n" \
  "        strcpy(rPrioCRC.acType, givrListCRC.trEltList[p].acType);\n" \
  "    }\n" \
  "\n" \
  "    iNbEtabCRC = 0;\n" \
  "    iRgEtab = 0;\n" \
  "    iRangDeb = 0;\n" \
  "\n" \
  "    /* rang dans chaque etab */\n" \
  "    for (j = 0; j < (givrListCRC.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListCRC.trEltRangList[j];\n" \
  "\n" \
  "        if ((iRgEtab != givrListCRC.trEltList[i].iRgEtab) && (-1 != givrListCRC.trEltList[i].iRgEtab))\n" \
  "        {\n" \
  "            iRgEtabCRC = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < j; l++)\n" \
  "            {\n" \
  "                k = givrListCRC.trEltRangList[l];\n" \
  "                givrListCRC.trEltList[k].iNbEtabCRC = iNbEtabCRC;\n" \
  "                givrListCRC.trEltList[k].iRgEtabCRC = iRgEtabCRC;\n" \
  "                givrListCRC.trEltList[k].iNbCRCCRC = 1;\n" \
  "                givrListCRC.trEltList[k].iRgCRCCRC = 0;\n" \
  "                iRgEtabCRC++;\n" \
  "            }\n" \
  "\n" \
  "            iRgEtab = givrListCRC.trEltList[i].iRgEtab;\n" \
  "            iNbEtabCRC = 0;\n" \
  "            iRangDeb = j;\n" \
  "        }\n" \
  "\n" \
  "        iNbEtabCRC++;\n" \
  "\n" \
  "        if ((givrListCRC.iNbr - 1) == j)\n" \
  "        {\n" \
  "            iRgEtabCRC = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < (givrListCRC.iNbr); l++)\n" \
  "            {\n" \
  "                k = givrListCRC.trEltRangList[l];\n" \
  "                givrListCRC.trEltList[k].iNbEtabCRC = iNbEtabCRC;\n" \
  "                givrListCRC.trEltList[k].iRgEtabCRC = iRgEtabCRC;\n" \
  "                givrListCRC.trEltList[k].iNbCRCCRC = 1;\n" \
  "                givrListCRC.trEltList[k].iRgCRCCRC = 0;\n" \
  "                iRgEtabCRC++;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* rang dans chaque crc */\n" \
  "    iNbCRCCRC = 0;\n" \
  "    iRgEtab = 0;\n" \
  "    iRgCRC = 0;\n" \
  "    iRangDeb = 0;\n" \
  "\n" \
  "    for (j = 0; j < (givrListCRC.iNbr); j++)\n" \
  "    {\n" \
  "        i = givrListCRC.trEltRangList[j];\n" \
  "\n" \
  "        if (((iRgEtab != givrListCRC.trEltList[i].iRgEtab) || (iRgCRC != givrListCRC.trEltList[i].iRgCRC)) && (-1 != givrListCRC.trEltList[i].iRgEtab) && (-1 != givrListCRC.trEltList[i].iRgCRC))\n" \
  "        {\n" \
  "            iRgCRCCRC = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < j; l++)\n" \
  "            {\n" \
  "                k = givrListCRC.trEltRangList[l];\n" \
  "                givrListCRC.trEltList[k].iNbCRCCRC = iNbCRCCRC;\n" \
  "                givrListCRC.trEltList[k].iRgCRCCRC = iRgCRCCRC;\n" \
  "                iRgCRCCRC++;\n" \
  "            }\n" \
  "\n" \
  "            iRgEtab = givrListCRC.trEltList[i].iRgEtab;\n" \
  "            iRgCRC = givrListCRC.trEltList[i].iRgCRC;\n" \
  "            iNbCRCCRC = 0;\n" \
  "            iRangDeb = j;\n" \
  "        }\n" \
  "\n" \
  "        iNbCRCCRC++;\n" \
  "\n" \
  "        if ((givrListCRC.iNbr - 1) == j)\n" \
  "        {\n" \
  "            iRgCRCCRC = 0;\n" \
  "\n" \
  "            for (l = iRangDeb; l < (givrListCRC.iNbr); l++)\n" \
  "            {\n" \
  "                k = givrListCRC.trEltRangList[l];\n" \
  "                givrListCRC.trEltList[k].iNbCRCCRC = iNbCRCCRC;\n" \
  "                givrListCRC.trEltList[k].iRgCRCCRC = iRgCRCCRC;\n" \
  "                iRgCRCCRC++;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < givrListCRC.iNbr; i++)\n" \
  "    {\n" \
  "        p = givrListCRC.trEltRangList[i];\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"crc  : %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\\n\", givrListCRC.iNbr, p, givrListCRC.trEltList[p].iRgEtab, givrListCRC.trEltList[p].iRgCRC, givrListCRC.trEltList[p].iNbEtabCRC,\n" \
  "                                 givrListCRC.trEltList[p].iRgEtabCRC, givrListCRC.trEltList[p].iNbCRCCRC, givrListCRC.trEltList[p].iRgCRCCRC));\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strcmp(\"OUI\", givtcGeneAffCRC))\n" \
  "    {\n" \
  "        /* pas d'affichage de CRC */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* référence courante */\n" \
  "    (void)strcpy(rPrioCRC.acEtab, \"00000000\");\n" \
  "    (void)strcpy(rPrioCRC.acCRC, \"\");\n" \
  "\n" \
  "    for (i = 0; i < givrListCRC.iNbr;)\n" \
  "    {\n" \
  "        p = givrListCRC.trEltRangList[i];\n" \
  "\n" \
  "        /* changement d'etab */\n" \
  "        if ((-1 == givrListCRC.trEltList[p].iRgEtab) || (-1 == givrListCRC.trEltList[p].iRgCRC))\n" \
  "        {\n" \
  "            /* bl sur epj complet */\n" \
  "            i += givrListCRC.trEltList[p].iNbEtabCRC;\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        for (j = i; (j < i + givrListCRC.trEltList[p].iNbEtabCRC);)\n" \
  "        {\n" \
  "            q = givrListCRC.trEltRangList[j];\n" \
  "            /* changement de CRC */\n" \
  "            strcat(buf_pos, \"<CRC crcan8=\\\"\");\n" \
  "\n" \
  "            if (0 != strcmp(givcR000000, givrListCRC.trEltList[q].acCodan8))\n" \
  "                strcat(buf_pos, givrListCRC.trEltList[q].acCodan8);\n" \
  "\n" \
  "            strcat(buf_pos, \"\\\">\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            rr = -1;\n" \
  "\n" \
  "            for (k = j; (k < j + givrListCRC.trEltList[q].iNbCRCCRC); k++)\n" \
  "            {\n" \
  "                /* même CRC */\n" \
  "                r = givrListCRC.trEltRangList[k];\n" \
  "\n" \
  "                if ((-1 == givrListCRC.trEltList[r].iRgEtab) || (-1 == givrListCRC.trEltList[r].iRgCRC))\n" \
  "                {\n" \
  "                    /* double */\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                /* crc et type */\n" \
  "                if ((-1 != rr) && ((0 != strcmp(givrListCRC.trEltList[r].acType, givrListCRC.trEltList[rr].acType)) || (0 != strcmp(givrListCRC.trEltList[r].acCRC, givrListCRC.trEltList[rr].acCRC))))\n" \
  "                {\n" \
  "                    strcat(buf_pos, \"</origine>\");\n" \
  "                    lg_ecr = strlen(buf_pos);\n" \
  "                    *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                    *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "                    buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "                    strcat(buf_pos, \"</CRC>\");\n" \
  "                    lg_ecr = strlen(buf_pos);\n" \
  "                    *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                    *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "                    buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "                }\n" \
  "\n" \
  "                if ((-1 == rr) || (0 != strcmp(givrListCRC.trEltList[r].acType, givrListCRC.trEltList[rr].acType)) || (0 != strcmp(givrListCRC.trEltList[r].acCRC, givrListCRC.trEltList[rr].acCRC)))\n" \
  "                {\n" \
  "                    strcat(buf_pos, \"<CRC crctype=\\\"\");\n" \
  "                    strcat(buf_pos, givrListCRC.trEltList[r].acType);\n" \
  "                    strcat(buf_pos, \"\\\">\");\n" \
  "                    strcat(buf_pos, givrListCRC.trEltList[r].acCRC);\n" \
  "                    lg_ecr = strlen(buf_pos);\n" \
  "                    *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                    *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "                    buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "                    strcat(buf_pos, \"<origine>\");\n" \
  "                    lg_ecr = strlen(buf_pos);\n" \
  "                    *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                    *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "                    buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "                }\n" \
  "\n" \
  "                strcat(buf_pos, \"<origine>\");\n" \
  "\n" \
  "                if (' ' == givrListCRC.trEltList[r].acTpdsob[0])\n" \
  "                    strcat(buf_pos, &givrListCRC.trEltList[r].acTpdsob[1]);\n" \
  "                else\n" \
  "                    strcat(buf_pos, givrListCRC.trEltList[r].acTpdsob);\n" \
  "\n" \
  "                strcat(buf_pos, \"</origine>\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "                buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "                rr = r;\n" \
  "            }\n" \
  "\n" \
  "            strcat(buf_pos, \"</origine>\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            strcat(buf_pos, \"</CRC>\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            /* CRC suivant */\n" \
  "            j = k;\n" \
  "            /* fin des crc */\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"CRC\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        /* fin d'établissement */\n" \
  "        /* établissement suivant */\n" \
  "        i = j;\n" \
  "    }\n" \
  "\n" \
  "    /* fin des crc */\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givMutualiserDonPartenaires                                    */\n" \
  "/*                                                                            */\n" \
  "/* But       : mutualisation des contenus SGIPRO des partenaires               */\n" \
  "/*             de l'ensemble du bloc                                          */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, documents                                           */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Création    (Jan/09/2012 - mb)                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givMutualiserDonPartenaires(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i, j, q = 0;\n" \
  "    int4 lg_write;\n" \
  "    int4 iDebut;\n" \
  "    char* buf_pos;\n" \
  "    char* pt_fin_liste;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_mil_element;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    char* pt_mil;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBalises[50 + 2];\n" \
  "    char tcElmt1[29 + 1]; /* partenaire*/\n" \
  "    char tcElmt0[9 + 1]; /* établissement*/\n" \
  "    char tcEtab[9 + 1]; /* établissement lié à doc */\n" \
  "    char tcType[3];\n" \
  "    int4 lg_a_ecrire;\n" \
  "    int4 pipe; /* Flag pour ajout pipe */\n" \
  "    int4 iRet;\n" \
  "    pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "    strcpy(tcType, \"pr\");\n" \
  "    pt_debut_element = strstr(givtcObjCont, \"pr/\");\n" \
  "\n" \
  "    if (0 == pt_debut_element)\n" \
  "    {\n" \
  "        strcpy(tcType, \"PR\");\n" \
  "        pt_debut_element = strstr(givtcObjCont, \"PR/\");\n" \
  "\n" \
  "        if (0 == pt_debut_element)\n" \
  "            return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* pas de gestion de conflit */\n" \
  "    giviConflitCRC = GIV::GWCCodeKO;\n" \
  "    /* ref de partenaire des doubles */\n" \
  "    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "    pipe = 0;\n" \
  "\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        for (q = 0; (q < doc[i].value.a_classer.iNbPart && 0 != strlen(doc[i].value.a_classer.etab)); q++)\n" \
  "        {\n" \
  "            if (pipe == 0)\n" \
  "            {\n" \
  "                strcpy(buf_concat, doc[i].value.a_classer.trpart[q].rpart);\n" \
  "                strcat(buf_concat, \".\");\n" \
  "                strcat(buf_concat, doc[i].value.a_classer.etab);\n" \
  "                pipe = 1;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                strcat(buf_concat, \"|\");\n" \
  "                strcat(buf_concat, doc[i].value.a_classer.trpart[q].rpart);\n" \
  "                strcat(buf_concat, \".\");\n" \
  "                strcat(buf_concat, doc[i].value.a_classer.etab);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        /* suppression des doubles références */\n" \
  "        iRet = supprimer_doublon(buf_concat, '|');\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Ref partenaire pour DonPart %s,'%s'\\n\", doc[0].value.a_classer.etab, buf_concat));\n" \
  "\n" \
  "    if (0 == strlen(buf_concat))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    pt_fin_element = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "    if (pt_fin_element == 0)\n" \
  "        pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "    pt_mil_element = pt_debut_element + 2;\n" \
  "    /* analyse type et balise associés */\n" \
  "    memcpy(tcBalise, (pt_mil_element + 1), (pt_fin_element - pt_mil_element - 1));\n" \
  "    tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\\0';\n" \
  "    strcpy(tcBalises, tcBalise);\n" \
  "    /* strcat(tcBalises,\"s\"); */\n" \
  "    /* enrichissement des partenaires */\n" \
  "    /* écriture SGIPRO */\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iDebut = 1;\n" \
  "    pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "    for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "    {\n" \
  "        pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "        if (pt_fin == 0)\n" \
  "            pt_fin = pt_fin_lst;\n" \
  "\n" \
  "        pt_mil = strchr(pt_debut, '.');\n" \
  "\n" \
  "        if (pt_mil == 0)\n" \
  "            return (iCodRet);\n" \
  "\n" \
  "        /* analyse référence */\n" \
  "        memcpy(tcElmt1, pt_debut, (pt_mil - pt_debut));\n" \
  "        tcElmt1[(pt_mil - pt_debut)] = '\\0';\n" \
  "        pt_mil++;\n" \
  "        memcpy(tcElmt0, pt_mil, (pt_fin - pt_mil));\n" \
  "        tcElmt0[(pt_fin - pt_mil)] = '\\0';\n" \
  "        /* rétablir cohérence entre etab et doc */\n" \
  "        strcpy(tcEtab, doc[0].value.a_classer.etab);\n" \
  "        strcpy(doc[0].value.a_classer.etab, tcElmt0);\n" \
  "\n" \
  "        if (0 == strcmp(tcType, \"pr\"))\n" \
  "            iCodRet = givEcritSgiProPartEtab(&buf_pos, doc, indice, tcElmt0, tcElmt1, \"PR\", tcBalise, &iDebut);\n" \
  "        else\n" \
  "            iCodRet = givEcritSgiProPart(&buf_pos, doc, tcElmt0, tcElmt1, \"PR\", tcBalise, &iDebut);\n" \
  "\n" \
  "        strcpy(doc[0].value.a_classer.etab, tcEtab);\n" \
  "        pt_debut = pt_fin + 1;\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    for (i = doc[0].value.a_classer.iNbPart; i < doc[0].value.a_classer.iNbPart + giviNbIapartPJDC; i++)\n" \
  "    {\n" \
  "        /* référence de partenaire PJDC non intégrée */\n" \
  "        j = doc[0].value.a_classer.trpart[i].iRgParent;\n" \
  "        strcat(buf_pos, cComm_xml0);\n" \
  "        strcat(buf_pos, givtrPart[j].acRefPart);\n" \
  "        strcat(buf_pos, \" - \");\n" \
  "\n" \
  "        if (0 != strlen(givtrPart[j].acPrenom))\n" \
  "        {\n" \
  "            strcat(buf_pos, givtrPart[j].acPrenom);\n" \
  "            strcat(buf_pos, \" \");\n" \
  "        }\n" \
  "\n" \
  "        strcat(buf_pos, givtrPart[j].acDenom);\n" \
  "        strcat(buf_pos, cComm_xml1);\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + lg_ecr + 1) = LINE_FEED;\n" \
  "        *(buf_pos + lg_ecr + 2) = '\\0';\n" \
  "        buf_pos = buf_pos + strlen(buf_pos);\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(buf_concat))\n" \
  "    {\n" \
  "        pt_fin_lst = buf_concat + strlen(buf_concat);\n" \
  "\n" \
  "        for (pt_debut = buf_concat; pt_debut < pt_fin_lst;)\n" \
  "        {\n" \
  "            pt_fin = strchr(pt_debut, '|');\n" \
  "\n" \
  "            if (pt_fin == 0)\n" \
  "                pt_fin = pt_fin_lst;\n" \
  "\n" \
  "            pt_mil = strchr(pt_debut, '.');\n" \
  "\n" \
  "            if (pt_mil == 0)\n" \
  "                return (iCodRet);\n" \
  "\n" \
  "            /* référence de partenaire */\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"infos_part\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            memcpy(tcElmt1, pt_debut, (pt_mil - pt_debut));\n" \
  "            tcElmt1[(pt_mil - pt_debut)] = '\\0';\n" \
  "            iRet = giv_ecrit_noeud_partenaire(&buf_pos, tcElmt1, doc->value.numero_bloc_parution, doc->value.a_classer.etab);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"infos_part\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            pt_debut = pt_fin + 1;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    memset(buf_concat, 0, strlen(buf_concat));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture DonPartenaires\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritDonAdd()                                               */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les données additionnelles liées à l'établissement       */\n" \
  "/*             lecture xmltype via clob                                       */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification () :                                                          */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritDonAdd(char* apcType, char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i = 0;\n" \
  "    int4 k, x = 0;\n" \
  "    int4 iDebut = 1;\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element, *pt_mil_element, *pt_fin_liste;\n" \
  "    char tcObj[GYBIamicLgNumobj2];\n" \
  "    char tcSource[5 + 1];\n" \
  "    char tcConf[3 + 1];\n" \
  "    char tcBalise[50 + 1];\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_a_ecrire;\n" \
  "    char tcRef[3];\n" \
  "    char tcType[3];\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* balises configurées */\n" \
  "    strcpy(tcRef, \"DA\");\n" \
  "    strcpy(tcType, apcType);\n" \
  "\n" \
  "    if (0 != strcmp(tcRef, apcType))\n" \
  "    {\n" \
  "        strcpy(tcConf, apcType);\n" \
  "        strcat(tcConf, \"/\");\n" \
  "        pt_debut_element = strstr(givtcObjCont, tcConf);\n" \
  "\n" \
  "        if (0 == pt_debut_element)\n" \
  "        {\n" \
  "            tcType[0] = tolower(apcType[0]);\n" \
  "            tcType[1] = tolower(apcType[1]);\n" \
  "            strcpy(tcConf, tcType);\n" \
  "            strcat(tcConf, \"/\");\n" \
  "            pt_debut_element = strstr(givtcObjCont, tcConf);\n" \
  "\n" \
  "            if (0 == pt_debut_element)\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Contenu non configuré : %s\\n\", tcConf));\n" \
  "                return (iCodRet);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        pt_debut_element += strlen(tcConf);\n" \
  "        pt_fin_liste = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "        if (pt_fin_liste == 0)\n" \
  "            pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "\n" \
  "        memcpy(tcBalise, pt_debut_element, pt_fin_liste - pt_debut_element);\n" \
  "        tcBalise[pt_fin_liste - pt_debut_element] = '\\0';\n" \
  "    }\n" \
  "\n" \
  "    pt_debut_element = strstr(givtcObjCont, \"DA/\");\n" \
  "\n" \
  "    if (0 == pt_debut_element)\n" \
  "    {\n" \
  "        pt_debut_element = strstr(givtcObjCont, \"da/\");\n" \
  "\n" \
  "        if (0 == pt_debut_element)\n" \
  "            return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    pt_fin_liste = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "    if (pt_fin_liste == 0)\n" \
  "        pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "\n" \
  "    /* un seul epj entre les doc */\n" \
  "    i = 0;\n" \
  "    pt_mil_element = pt_debut_element + 3;\n" \
  "\n" \
  "    while (pt_fin_liste > pt_mil_element)\n" \
  "    {\n" \
  "        /* analyse type et balise associés */\n" \
  "        pt_fin_element = strchr(pt_mil_element, '/');\n" \
  "\n" \
  "        if ((pt_fin_element == 0) || (pt_fin_element > pt_fin_liste))\n" \
  "            pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "        memcpy(tcSource, pt_mil_element, pt_fin_element - pt_mil_element);\n" \
  "        tcSource[pt_fin_element - pt_mil_element] = '\\0';\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"source DA %s, %s, %c, %s\\n\", apcType, tcSource, (doc + i)->value.a_classer.parinsee, (doc + i)->value.a_classer.etab));\n" \
  "\n" \
  "        if (('0' == (doc + i)->value.a_classer.parinsee) && (0 == strcmp(tcSource, giv_B2B)))\n" \
  "        {\n" \
  "            /* pas parution des données insee pour B2B */\n" \
  "            pt_mil_element = pt_fin_element + 1;\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        /* lecture données additionnelles */\n" \
  "        if (0 == strcmp(tcRef, apcType))\n" \
  "        {\n" \
  "            /* données additionnelles en base */\n" \
  "            iRet = givLectureEtabDonSupp((doc + i)->value.a_classer.etab, \"\", tcSource, giv_ADD);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"source DA %s\\n\", (doc + i)->value.a_classer.etab));\n" \
  "        }\n" \
  "        else if (0 == strcmp(tcType, apcType))\n" \
  "        {\n" \
  "            /* données additionnelles annotées en fichier */\n" \
  "            iCodRet = givEcritSgiProED(apcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", tcSource, &iDebut);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"source AD %s\\n\", (doc + i)->value.a_classer.etab));\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* données additionnelles annotées en base */\n" \
  "            iCodRet = givEcritDonEtab(apcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", tcSource, &iDebut);\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"source ad %s\\n\", (doc + i)->value.a_classer.etab));\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != strlen(GIVBuffInter)) && (0 == strcmp(tcRef, apcType)))\n" \
  "        {\n" \
  "            if (1 == iDebut)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_noeud_simple(buf_pos, \"DonneesAddit\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                iDebut = 0;\n" \
  "            }\n" \
  "\n" \
  "            strcpy(buf_pos, \"<Addit_\");\n" \
  "        }\n" \
  "        else if ((0 != strlen(GIVBuffInter)) && (0 != strcmp(tcType, apcType)))\n" \
  "        {\n" \
  "            if (1 == iDebut)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                iDebut = 0;\n" \
  "            }\n" \
  "\n" \
  "            strcpy(buf_pos, \"<Search_\");\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != strlen(GIVBuffInter)) && ((0 != strcmp(tcType, apcType)) || (0 == strcmp(tcRef, apcType))))\n" \
  "        {\n" \
  "            strcat(buf_pos, tcSource);\n" \
  "            strcat(buf_pos, \" etablissement=\\\"\\\" id=\\\"\");\n" \
  "            strcat(buf_pos, (doc + i)->value.a_classer.etab);\n" \
  "            strcat(buf_pos, \"\\\">\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            strcpy(buf_pos, GIVBuffInter);\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "\n" \
  "            if (0 == strcmp(tcRef, apcType))\n" \
  "                strcpy(buf_pos, \"</Addit_\");\n" \
  "            else\n" \
  "                strcpy(buf_pos, \"</Search_\");\n" \
  "\n" \
  "            strcat(buf_pos, tcSource);\n" \
  "            strcat(buf_pos, \">\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = buf_pos + strlen(buf_pos);\n" \
  "        }\n" \
  "\n" \
  "        if ('\\0' != GIVBuffXML[0])\n" \
  "        {\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "\n" \
  "        /* source suivante */\n" \
  "        pt_mil_element = pt_fin_element + 1;\n" \
  "    }\n" \
  "\n" \
  "    if ((0 == iDebut) && (0 == strcmp(tcRef, apcType)))\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"DonneesAddit\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "    else if (0 == iDebut)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Données enrichies par établissement\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritDonHoraires()                                          */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les données info horaires                                */\n" \
  "/*             payantes liées à l'annonceur                                   */\n" \
  "/*             gratuites liées à l'établissement                              */\n" \
  "/*             lecture xmltype via clob                                       */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification () :                                                          */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritDonHoraires(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i, j = 0;\n" \
  "    int4 k, x, kk = 0;\n" \
  "    int4 iDebut = 1;\n" \
  "    int4 iNbRub = 0;\n" \
  "    int4 iInitRub = -1;\n" \
  "    int4 iNbDV = 0;\n" \
  "    int4 iRefDE = -1;\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    char* pt_debut_element, *pt_mil_element, *pt_debut_liste, *pt_debut_ref;\n" \
  "    char* pt_fin_element, *pt_fin_obj, *pt_fin_liste, *pt_fin_ref;\n" \
  "    char tcObj[GYBIamicLgNumobj2];\n" \
  "    char tcBalise[50 + 1];\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iLg, lg_a_ecrire;\n" \
  "    int4 iRang, iObj;\n" \
  "    pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "    pt_debut_element = strstr(givtcObjCont, \"om/\");\n" \
  "\n" \
  "    if (0 == pt_debut_element)\n" \
  "    {\n" \
  "        pt_debut_element = strstr(givtcObjCont, \"OM/\");\n" \
  "\n" \
  "        if (0 == pt_debut_element)\n" \
  "            return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    pt_fin_element = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "    if (pt_fin_element == 0)\n" \
  "        pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "    pt_mil_element = pt_debut_element + 2;\n" \
  "    /* analyse type et balise associés */\n" \
  "    memcpy(tcBalise, (pt_mil_element + 1), (pt_fin_element - pt_mil_element - 1));\n" \
  "    tcBalise[(pt_fin_element - pt_mil_element - 1)] = '\\0';\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    /* lecture des données horaires normalisées */\n" \
  "    iRang = -1;\n" \
  "\n" \
  "    for (i = 0; i < givrListObj.iNbr; i++)\n" \
  "    {\n" \
  "        k = givrListObj.trEltRangListObj[i];\n" \
  "        kk = givrListObj.trEltListObj[k].iRgLigne;\n" \
  "        iObj = givrListObj.trEltListObj[k].iRgObj;\n" \
  "\n" \
  "        if (iRang != givrListObj.trEltListObj[k].iRangTri)\n" \
  "        {\n" \
  "            iRang = givrListObj.trEltListObj[k].iRangTri;\n" \
  "\n" \
  "            if (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].type, \"X\"))\n" \
  "            {\n" \
  "                /* lecture des infos horaires payantes */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" horaire normalisé obj %d,%s\\n\", iObj, (doc + kk)->value.objets_pub.micro[iObj].id));\n" \
  "\n" \
  "                if (0 == strcmp((doc + kk)->value.objets_pub.micro[iObj].stype, \"HO\"))\n" \
  "                    iRet = givLectureEtabDonSupp(\"\", (doc + kk)->value.objets_pub.micro[iObj].id, (doc + kk)->value.objets_pub.micro[iObj].stype, giv_HPN);\n" \
  "                else if (2 == (doc + kk)->value.objets_pub.micro[iObj].iCVI)\n" \
  "                    iRet = givLectureEtabDonSupp(\"\", (doc + kk)->value.objets_pub.micro[iObj].id, (doc + kk)->value.objets_pub.micro[iObj].stypcvi, giv_HPN);\n" \
  "                else\n" \
  "                {\n" \
  "                    /* contenu valide uniquement pour HO et CVI nouveau avec contenus associés */\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                if (0 != strlen(GIVBuffInter))\n" \
  "                {\n" \
  "                    if (1 == iDebut)\n" \
  "                    {\n" \
  "                        lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "                        buf_pos = buf_pos + lg_write;\n" \
  "                        lg_write = giv_ecrit_noeud_simple(buf_pos, \"ompars\");\n" \
  "                        buf_pos = buf_pos + lg_write;\n" \
  "                        iDebut = 0;\n" \
  "                    }\n" \
  "\n" \
  "                    strcpy(buf_pos, GIVBuffInter);\n" \
  "                    lg_ecr = strlen(GIVBuffInter);\n" \
  "                    buf_pos = (buf_pos + lg_ecr);\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\" horaire normalisé obj %d,%d,%s\\n\", kk, iObj, (doc + kk)->value.objets_pub.micro[iObj].id));\n" \
  "                    /* Ecriture dans le fichier de sortie */\n" \
  "                    iRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    /* lecture des infos horaires gratuites */\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" horaire normalisé epj %s\\n\", doc->value.a_classer.etab));\n" \
  "    iInitRub = -1;\n" \
  "    iNbRub = 0;\n" \
  "    iNbDV = 0;\n" \
  "    iRefDE = -1;\n" \
  "\n" \
  "    for (j = 0; j < giviNbProfEtab; j++)\n" \
  "    {\n" \
  "        if ('N' == givrListProfEtab[j].cIndic)\n" \
  "        {\n" \
  "            iNbRub++;\n" \
  "\n" \
  "            if (0 == strcmp(\"DV\", givrListProfEtab[j].tcType))\n" \
  "            {\n" \
  "                /* DV */\n" \
  "                iNbDV++;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* DE */\n" \
  "                iRefDE = j;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    for (j = 0; j < giviNbProfEtab; j++)\n" \
  "    {\n" \
  "        if ('N' == givrListProfEtab[j].cIndic)\n" \
  "        {\n" \
  "            if ((-1 == iInitRub) && (1 == iNbRub))\n" \
  "            {\n" \
  "                /* seule donnée DHN pour un epj */\n" \
  "                iInitRub = j;\n" \
  "            }\n" \
  "            else if ((-1 == iInitRub) && (2 == iNbRub) && (-1 != iRefDE))\n" \
  "            {\n" \
  "                /* première donnée DHN plus récente entre DV et DE pour un epj */\n" \
  "                iInitRub = j;\n" \
  "            }\n" \
  "            else if ((-1 != iInitRub) && (2 == iNbRub) && (-1 != iRefDE))\n" \
  "            {\n" \
  "                /* seconde donnée DHN moins récente entre DV et DE pour un epj */\n" \
  "                continue;\n" \
  "            }\n" \
  "            else if (-1 == iRefDE)\n" \
  "            {\n" \
  "                /* plusieurs DHN DV sans DE pour un epj : pas de DHS */\n" \
  "            }\n" \
  "            else if (iRefDE == j)\n" \
  "            {\n" \
  "                /* plusieurs DHN DV avec DE pour un epj */\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* plusieurs DHN pour un epj */\n" \
  "                continue;\n" \
  "            }\n" \
  "\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" horaire normalisé epj %s,%s\\n\", givrListProfEtab[j].tcType, givrListProfEtab[j].tcAn8));\n" \
  "            iRet = givLectureEtabDonSupp(doc->value.a_classer.etab, givrListProfEtab[j].tcAn8, givrListProfEtab[j].tcType, giv_HGN);\n" \
  "\n" \
  "            if (0 != strlen(GIVBuffInter))\n" \
  "            {\n" \
  "                if (1 == iDebut)\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, \"ompars\");\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    iDebut = 0;\n" \
  "                }\n" \
  "\n" \
  "                strcpy(buf_pos, GIVBuffInter);\n" \
  "                lg_ecr = strlen(GIVBuffInter);\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                /* Ecriture dans le fichier de sortie */\n" \
  "                iRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (0 == iDebut)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"ompars\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Infos Horaires\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/** Génere la date de fraicheur des données en cours de génération, à condition\n" \
  " * que celles ci concernent la santé.\n" \
  " *\n" \
  " * Paramètre : le flux de destination\n" \
  " * Retour : le nombre de caractères écrits.\n" \
  " */\n" \
  "static int4 generer_fraicheur_ameli(char* buffer)\n" \
  "{\n" \
  "    int4 ret = 0;\n" \
  "    static int4 deja_appele = 0;\n" \
  "    static char date_ameli[20] =\n" \
  "    { 0 };\n" \
  "\n" \
  "    if (!deja_appele)\n" \
  "    {\n" \
  "        ret = GWTLireConf(\"AMELI_DATE_FRAICHEUR_D_E\", date_ameli);\n" \
  "\n" \
  "        if (ret != GIV::GWTok)\n" \
  "            date_ameli[0] = '\\0';\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"date ameli : \\\"%s\\\"\\n\", date_ameli));\n" \
  "        deja_appele = 1;\n" \
  "    }\n" \
  "\n" \
  "    if (strstr(GIVBuffInter, \"<prestationsSante>\") != NULL)\n" \
  "    {\n" \
  "        /* sprintf renvoie le nombre de caractères écrits */\n" \
  "        ret = sprintf(buffer, \"<dateFraicheur>%s</dateFraicheur>\", date_ameli);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"%d caractères ecrits : %s\\n\", ret, buffer));\n" \
  "        buffer[ret] = SEPARE_LIGNE;\n" \
  "        buffer[ret + 1] = LINE_FEED;\n" \
  "        buffer[ret + 2] = '\\0';\n" \
  "        return (ret + 2);\n" \
  "    }\n" \
  "    else\n" \
  "        return (0);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritDonEnr()                                               */\n" \
  "/*             lecture xmltype via clob                                       */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les données enrichies liées à l'établissement            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification () :                                                          */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritDonEnr(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i, j = 0;\n" \
  "    int4 k, x = 0;\n" \
  "    int4 iDebut = 1;\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    char* pt_debut_element, *pt_debut_obj, *pt_debut_liste, *pt_debut_ref;\n" \
  "    char* pt_fin_element, *pt_fin_obj, *pt_fin_liste, *pt_fin_ref;\n" \
  "    char tcObj[GYBIamicLgNumobj2];\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_a_ecrire;\n" \
  "    int4 ret = 0;\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    i = 0;\n" \
  "    /* lecture données enrichies */\n" \
  "    iRet = givLectureEtabDonSupp((doc + i)->value.a_classer.etab, \"\", \"EN\", giv_ENR);\n" \
  "\n" \
  "    if (0 != strlen(GIVBuffInter))\n" \
  "    {\n" \
  "        if (1 == iDebut)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"affscppar\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            iDebut = 0;\n" \
  "        }\n" \
  "\n" \
  "        strcpy(buf_pos, \"<annonceur etablissement=\\\"\\\" id=\\\"\");\n" \
  "        strcat(buf_pos, (doc + i)->value.a_classer.etab);\n" \
  "        strcat(buf_pos, \"\\\">\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "        *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "        buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "        /* analyse <prestationsMenuPayant> */\n" \
  "        pt_debut_liste = NULL;\n" \
  "        pt_fin_liste = GIVBuffInter;\n" \
  "        pt_debut_element = NULL;\n" \
  "        pt_fin_element = NULL;\n" \
  "        pt_debut_ref = NULL;\n" \
  "        pt_fin_ref = NULL;\n" \
  "\n" \
  "        while (NULL != pt_fin_liste)\n" \
  "        {\n" \
  "            pt_debut_element = strstr(pt_fin_liste, \"<prestationsMenuPayant \");\n" \
  "            pt_fin_element = strstr(pt_fin_liste, \"</prestationsMenuPayant>\");\n" \
  "\n" \
  "            if (NULL == pt_fin_element || NULL == pt_debut_element)\n" \
  "            {\n" \
  "                /* pas d'élément */\n" \
  "                break;\n" \
  "            }\n" \
  "\n" \
  "            if (NULL == pt_debut_liste)\n" \
  "                pt_debut_liste = pt_debut_element;\n" \
  "\n" \
  "            pt_fin_element += strlen(\"</prestationsMenuPayant>\");\n" \
  "            pt_fin_element++;\n" \
  "            pt_fin_liste = pt_fin_element;\n" \
  "            pt_debut_obj = strstr(pt_debut_element, \"numobj=\\\"\");\n" \
  "\n" \
  "            if ((NULL != pt_debut_obj) && (pt_debut_obj < pt_fin_element) && (NULL == pt_debut_ref))\n" \
  "            {\n" \
  "                pt_debut_obj += strlen(\"numobj=\\\"\");\n" \
  "                pt_fin_obj = strchr(pt_debut_obj, '\\\"');\n" \
  "\n" \
  "                if (NULL == pt_fin_obj)\n" \
  "                {\n" \
  "                    /* pas d'objet */\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                if (GYBIamicLgNumobj != (pt_fin_obj - pt_debut_obj))\n" \
  "                {\n" \
  "                    /* pas d'objet */\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"pas d'objet lg %d\\n\", (pt_fin_obj - pt_debut_obj)));\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                memcpy(tcObj, pt_debut_obj, (pt_fin_obj - pt_debut_obj));\n" \
  "                tcObj[(pt_fin_obj - pt_debut_obj)] = '\\0';\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Obj BOC <%s>\\n\", tcObj));\n" \
  "\n" \
  "                for (j = 0; j < indice; j++)\n" \
  "                {\n" \
  "                    for (x = 0; x < (doc + j)->value.objets_pub.nb_micro; x++)\n" \
  "                    {\n" \
  "                        if ((0 == strcmp((doc + j)->value.objets_pub.micro[x].stype, \"SC\")) && (0 == strcmp((doc + j)->value.objets_pub.micro[x].sstype, \"PV\")\n" \
  "                                || 0 == strcmp((doc + j)->value.objets_pub.micro[x].sstype, \"PB\")) && (0 == strcmp((doc + j)->value.objets_pub.micro[x].id, tcObj)))\n" \
  "                        {\n" \
  "                            GWTTrace(GWT_NIV_FONCT, (\"objet menu trouvé\\n\"));\n" \
  "                            pt_debut_ref = pt_debut_element;\n" \
  "                            pt_fin_ref = pt_fin_element;\n" \
  "                            break;\n" \
  "                        }\n" \
  "                    }\n" \
  "\n" \
  "                    if ((doc + j)->value.objets_pub.nb_micro != x)\n" \
  "                        break;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((NULL == pt_debut_ref) && (NULL == pt_debut_liste))\n" \
  "        {\n" \
  "            if (NULL != strstr(GIVBuffInter, \"<prestationsMenuGratuit>\"))\n" \
  "                strcpy(buf_pos, \"<prmenu>1</prmenu>\");\n" \
  "            else\n" \
  "                strcpy(buf_pos, \"<prmenu>0</prmenu>\");\n" \
  "\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            /* BOCG-442 : Ajout d'une date de fraicheur dans les DE */\n" \
  "            ret = generer_fraicheur_ameli(buf_pos);\n" \
  "            buf_pos += ret;\n" \
  "            /* Fin BOCG-442 */\n" \
  "            strcpy(buf_pos, GIVBuffInter);\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            if (NULL != pt_debut_ref)\n" \
  "                strcpy(buf_pos, \"<prmenu>1</prmenu>\");\n" \
  "            else if (NULL != strstr(GIVBuffInter, \"<prestationsMenuGratuit>\"))\n" \
  "                strcpy(buf_pos, \"<prmenu>1</prmenu>\");\n" \
  "            else\n" \
  "                strcpy(buf_pos, \"<prmenu>0</prmenu>\");\n" \
  "\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            /* BOCG-442 : Ajout d'une date de fraicheur dans les DE */\n" \
  "            ret = generer_fraicheur_ameli(buf_pos);\n" \
  "            buf_pos += ret;\n" \
  "            /* Fin BOCG-442 */\n" \
  "            memcpy(buf_pos, GIVBuffInter, (pt_debut_liste - GIVBuffInter));\n" \
  "            lg_ecr = (pt_debut_liste - GIVBuffInter);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "\n" \
  "            if (NULL != pt_debut_ref)\n" \
  "            {\n" \
  "                memcpy(buf_pos, pt_debut_ref, (pt_fin_ref - pt_debut_ref));\n" \
  "                lg_ecr = (pt_fin_ref - pt_debut_ref);\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "            }\n" \
  "\n" \
  "            strcpy(buf_pos, pt_fin_liste);\n" \
  "            lg_ecr = strlen(pt_fin_liste);\n" \
  "        }\n" \
  "\n" \
  "        buf_pos = (buf_pos + lg_ecr);\n" \
  "        strcpy(buf_pos, \"</annonceur>\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "        *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "        buf_pos = buf_pos + strlen(buf_pos);\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    if (0 == iDebut)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"affscppar\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Données enrichies par établissement\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritDonAnnonceur()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les contenus liées à l'annonceur                         */\n" \
  "/*             lecture xmltype via clob                                       */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification () :                                                          */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritDonAnnonceur(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 iDoc, int4 iRef, int4 indice, char* pcBalise, int4 iBalise)\n" \
  "\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char* pt_debut_liste, *pt_fin_liste, *pcFin;\n" \
  "    int4 lg_ecr;\n" \
  "    int4 i, k, iNbCRC;\n" \
  "\n" \
  "    if (0 == strlen((doc + iDoc)->value.objets_pub.micro[iRef].id))\n" \
  "    {\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    iCodRet = GIV::GWCCodeKO;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "\n" \
  "    /* lecture des contenus */\n" \
  "    if (0 == (doc + iDoc)->value.objets_pub.micro[iRef].iCVI)\n" \
  "        iRet = givLectureEtabDonSupp(\"\", (doc + iDoc)->value.objets_pub.micro[iRef].id, (doc + iDoc)->value.objets_pub.micro[iRef].stype, giv_ANN);\n" \
  "    else\n" \
  "        iRet = givLectureEtabDonSupp(\"\", (doc + iDoc)->value.objets_pub.micro[iRef].id, doc->value.objets_pub.micro[iRef].stypcvi, giv_ANN);\n" \
  "\n" \
  "    iNbCRC = giviNbCRC;\n" \
  "\n" \
  "    if (0 != strlen(GIVBuffInter))\n" \
  "    {\n" \
  "        if (buf_pos == *buf_pos_in)\n" \
  "        {\n" \
  "            if (((int4)GIV::GIXCodeKO == iBalise) || ((int4)GIV::GIXCodeRIEN == iBalise))\n" \
  "            {\n" \
  "                lg_ecr = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "                buf_pos = buf_pos + lg_ecr;\n" \
  "            }\n" \
  "\n" \
  "            iRet = giv_ecrit_objet_pub(&buf_pos, (doc + iDoc), 0, iRef, \"objetcontenu\");\n" \
  "        }\n" \
  "\n" \
  "        pt_fin_liste = GIVBuffInter;\n" \
  "        pt_debut_liste = strstr(pt_fin_liste, \"<sgipro>\");\n" \
  "        pt_debut_liste += strlen(\"<sgipro>\");\n" \
  "        pt_debut_liste++;\n" \
  "        pt_fin_liste = strstr(pt_debut_liste, \"</sgipro>\");\n" \
  "        *pt_fin_liste = '\\0';\n" \
  "        iRet = givAnalyseObjetXML((doc + iDoc)->value.objets_pub.micro[iRef].stype, (doc + iDoc), pt_debut_liste, &buf_pos);\n" \
  "\n" \
  "        if ('\\0' != GIVBuffXML[0])\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"EtabDonSupp : %s, %s, %d, %s\\n\", (doc + iDoc)->value.objets_pub.micro[iRef].id, (doc + iDoc)->value.objets_pub.micro[iRef].stype, strlen(GIVBuffInter), GIVBuffInter));\n" \
  "\n" \
  "            if ((0 == strcmp(\"SC\", (doc + iDoc)->value.objets_pub.micro[iRef].stype)) && (0 != strcmp(\"SR\", (doc + iDoc)->value.objets_pub.micro[iRef].sstype)))\n" \
  "            {\n" \
  "                (void)strcpy(GIVBuffClob, GIVBuffXML);\n" \
  "                pcFin = strstr(GIVBuffClob, \"</pvi>\");\n" \
  "\n" \
  "                if (0 != pcFin)\n" \
  "                {\n" \
  "                    /* pour PVI inclusion du contenu \"IP\" */\n" \
  "                    iRet = givLectureEtabDonSupp(\"\", (doc + iDoc)->value.objets_pub.micro[iRef].id, \"IP\", giv_ANN);\n" \
  "\n" \
  "                    if (0 != strlen(GIVBuffInter))\n" \
  "                    {\n" \
  "                        /* copie de la fin de contenu SC */\n" \
  "                        strcat(GIVBuffInter, pcFin);\n" \
  "                        strcpy(pcFin, GIVBuffInter);\n" \
  "                        strcpy(GIVBuffXML, GIVBuffClob);\n" \
  "                        buf_pos = GIVBuffXML;\n" \
  "                        lg_ecr = strlen(GIVBuffXML);\n" \
  "                        buf_pos = (buf_pos + lg_ecr);\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        /* pour PVI inclusion du fichier \"IP\" */\n" \
  "                        pcFin = strstr(GIVBuffXML, \"</pvi>\");\n" \
  "                        strcpy(GIVBuffInter, pcFin);\n" \
  "                        buf_pos = pcFin;\n" \
  "                        iRet = givEcritImages(&buf_pos, (doc + iDoc), iRef);\n" \
  "                        strcpy(buf_pos, GIVBuffInter);\n" \
  "                        lg_ecr = strlen(GIVBuffInter);\n" \
  "                        buf_pos = (buf_pos + lg_ecr);\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if (buf_pos != *buf_pos_in)\n" \
  "                iCodRet = GIV::GWCCodeOK;\n" \
  "\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Contenus par annonceur %s, %s, %d, %d\\n\", (doc + iDoc)->value.objets_pub.micro[iRef].id, (doc + iDoc)->value.objets_pub.micro[iRef].stype, iNbCRC,\n" \
  "                             giviNbCRC));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritDonEtab()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les contenus liées à l'établissement                     */\n" \
  "/*             lecture xmltype via clob                                       */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification () :                                                          */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritDonEtab(char* obj, char* pcBalise, char** buf_pos_in, char* buf_pos_ref, GYBrDOCUMENTEpj* doc, char* tcRub, char* tcDep, char* tcSource, int4* piDeb)\n" \
  "\n" \
  "{\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char* pt_debut_liste, *pt_fin_liste, *pcFin;\n" \
  "    char* pt_debut_element, *pt_fin_element;\n" \
  "    char* pcDebSite, *pcFinSite;\n" \
  "    int4 lg_ecr, iLg;\n" \
  "    int4 i, j, k, iNbCRC, iDeb;\n" \
  "    char tcAn9[GYBPaprofLgCodan9 + 1];\n" \
  "    char cStrRef[100 + 1] = \"\";\n" \
  "    char cStrFinRef[100 + 1] = \"\";\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    for (i = 0; i < giviNbContEtab; i++)\n" \
  "    {\n" \
  "        if (0 == strcmp(doc->value.a_classer.etab, givrListContEtab[i].tcEtab))\n" \
  "        {\n" \
  "            if ((0 == strcmp(obj, givrListContEtab[i].tcType)) && (0 == strlen(tcRub)))\n" \
  "                break;\n" \
  "            else if ((0 == strcmp(obj, givrListContEtab[i].tcType)) && (0 == strcmp(tcRub, givrListContEtab[i].tcThm)))\n" \
  "                break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (giviNbContEtab == i)\n" \
  "    {\n" \
  "        /* contenu absent pour l'epj */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Contenu absent pour l'epj : %s, %s\\n\", obj, doc->value.a_classer.etab));\n" \
  "        GIVBuffInter[0] = '\\0';\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "\n" \
  "    /* lecture des contenus */\n" \
  "    if (0 != strcmp(\"AD\", obj))\n" \
  "        iRet = givLectureEtabDonSupp(doc->value.a_classer.etab, tcRub, obj, giv_EPJ);\n" \
  "    else\n" \
  "        iRet = givLectureEtabDonSupp(doc->value.a_classer.etab, tcSource, obj, giv_ANO);\n" \
  "\n" \
  "    iDeb = *piDeb;\n" \
  "    iNbCRC = giviNbCRC;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "    if (0 == strcmp(\"RA\", obj))\n" \
  "    {\n" \
  "        strcpy(cStrRef, \"<avis>\");\n" \
  "        strcpy(cStrFinRef, \"</avis>\");\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        strcpy(cStrRef, \"<sgipro>\");\n" \
  "        strcpy(cStrFinRef, \"</sgipro>\");\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strlen(GIVBuffInter))\n" \
  "    {\n" \
  "        pcDebSite = strstr(GIVBuffInter, \"<urlSite>\");\n" \
  "\n" \
  "        if ((0 == strcmp(\"EG\", obj)) && (0 != pcDebSite))\n" \
  "        {\n" \
  "            pcDebSite += strlen(\"<urlSite>\");\n" \
  "            pcFinSite = strstr(pcDebSite, \"</urlSite>\");\n" \
  "\n" \
  "            if ((GYBIeinscLgLibUrl2 * 4) > (pcFinSite - pcDebSite))\n" \
  "            {\n" \
  "                memcpy(doc->value.objets_pub.libUrlSite, pcDebSite, pcFinSite - pcDebSite);\n" \
  "                doc->value.objets_pub.libUrlSite[pcFinSite - pcDebSite] = '\\0';\n" \
  "            }\n" \
  "            else\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Taille réservée pour liburlSite insuffisante %d, %s\\n\", (pcFinSite - pcDebSite), doc->value.a_classer.etab));\n" \
  "        }\n" \
  "\n" \
  "        if ((0 == strcmp(\"EG\", obj)) && (1 == doc->value.a_classer.iBLEPJProf))\n" \
  "        {\n" \
  "            pt_debut_liste = NULL;\n" \
  "            pt_debut_element = NULL;\n" \
  "            pt_fin_element = NULL;\n" \
  "            pt_fin_liste = GIVBuffInter;\n" \
  "\n" \
  "            while (NULL != pt_fin_liste)\n" \
  "            {\n" \
  "                pt_debut_element = strstr(pt_fin_liste, \"<lstMarques>\");\n" \
  "\n" \
  "                if (NULL == pt_debut_element)\n" \
  "                {\n" \
  "                    /* fin */\n" \
  "                    pt_fin_liste = pt_debut_element;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    pt_debut_liste = pt_debut_element;\n" \
  "                    pt_fin_element = strstr(pt_debut_element, \"</lstMarques>\");\n" \
  "\n" \
  "                    if (NULL == pt_fin_element)\n" \
  "                    {\n" \
  "                        /* fin */\n" \
  "                        pt_fin_liste = pt_fin_element;\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        pt_fin_liste = pt_fin_element + strlen(\"</lstMarques>\");\n" \
  "                        iLg = strlen(pt_fin_liste) + 1;\n" \
  "                        memmove(pt_debut_liste, pt_fin_liste, iLg);\n" \
  "                        pt_fin_liste = pt_debut_liste;\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "        else if (0 == strcmp(\"RA\", obj))\n" \
  "        {\n" \
  "            pt_debut_liste = NULL;\n" \
  "            pt_debut_element = NULL;\n" \
  "            pt_fin_element = NULL;\n" \
  "            pt_fin_liste = GIVBuffInter;\n" \
  "\n" \
  "            while (NULL != pt_fin_liste)\n" \
  "            {\n" \
  "                pt_debut_element = strstr(pt_fin_liste, \"<fragment\");\n" \
  "\n" \
  "                if (NULL == pt_debut_element)\n" \
  "                {\n" \
  "                    /* fin */\n" \
  "                    pt_fin_liste = pt_debut_element;\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    pt_debut_liste = pt_debut_element;\n" \
  "                    pt_fin_element = strstr(pt_debut_element, \"</fragment\");\n" \
  "\n" \
  "                    if (NULL == pt_fin_element)\n" \
  "                    {\n" \
  "                        /* fin */\n" \
  "                        pt_fin_liste = pt_fin_element;\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        pt_fin_element++;\n" \
  "                        pt_fin_liste = strchr(pt_fin_element, '<');\n" \
  "                        pt_debut_element = strstr(pt_debut_liste, \"rubrique\");\n" \
  "\n" \
  "                        if (NULL != pt_debut_element)\n" \
  "                        {\n" \
  "                            pt_debut_element = strchr(pt_debut_element, '>');\n" \
  "                            pt_fin_element = strchr(pt_debut_element, '<');\n" \
  "\n" \
  "                            if (NULL != pt_fin_element && NULL != pt_debut_element)\n" \
  "                            {\n" \
  "                                pt_debut_element++;\n" \
  "\n" \
  "                                if (GYBPaprofLgCodan9 == (pt_fin_element - pt_debut_element))\n" \
  "                                {\n" \
  "                                    memcpy(tcAn9, pt_debut_element, (pt_fin_element - pt_debut_element));\n" \
  "                                    tcAn9[(pt_fin_element - pt_debut_element)] = '\\0';\n" \
  "                                    GWTTrace(GWT_NIV_FONCT, (\"Rub BOC <%s>\\n\", tcAn9));\n" \
  "\n" \
  "                                    for (i = 0; i < (givrListParu.iNbrTot); i++)\n" \
  "                                    {\n" \
  "                                        j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                                        if (0 == strcmp(givrListParu.trEltList[j].rub, tcRub))\n" \
  "                                            break;\n" \
  "                                    }\n" \
  "\n" \
  "                                    if (i != givrListParu.iNbrTot)\n" \
  "                                    {\n" \
  "                                        /* rubrique commune */\n" \
  "                                        continue;\n" \
  "                                    }\n" \
  "                                }\n" \
  "                            }\n" \
  "                        }\n" \
  "\n" \
  "                        /* pas de rubrique commune : black liste */\n" \
  "                        iLg = strlen(pt_fin_liste) + 1;\n" \
  "                        memmove(pt_debut_liste, pt_fin_liste, iLg);\n" \
  "                        pt_fin_liste = pt_debut_liste;\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"EtabDonSupp : %s, %s, %d, %s\\n\", obj, doc->value.a_classer.etab, strlen(GIVBuffInter), GIVBuffInter));\n" \
  "\n" \
  "        if ((1 == *piDeb) && ((0 == strcmp(\"GS\", obj)) || (0 == strcmp(\"RA\", obj)) || (0 == strcmp(\"AD\", obj)) || (0 == strcmp(\"DC\", obj))))\n" \
  "        {\n" \
  "            lg_ecr = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "            buf_pos = buf_pos + lg_ecr;\n" \
  "            *piDeb = 0;\n" \
  "        }\n" \
  "        else if (1 == *piDeb)\n" \
  "        {\n" \
  "            lg_ecr = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "            buf_pos = buf_pos + lg_ecr;\n" \
  "            strcpy(buf_pos, \"<sgipro>\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            *piDeb = 0;\n" \
  "        }\n" \
  "\n" \
  "        pt_fin_liste = GIVBuffInter;\n" \
  "        pt_debut_liste = strstr(pt_fin_liste, cStrRef);\n" \
  "\n" \
  "        if (NULL != pt_debut_liste)\n" \
  "        {\n" \
  "            pt_debut_liste += strlen(cStrRef);\n" \
  "            pt_debut_liste++;\n" \
  "            pt_fin_liste = strstr(pt_debut_liste, cStrFinRef);\n" \
  "            *pt_fin_liste = '\\0';\n" \
  "        }\n" \
  "        else\n" \
  "            pt_debut_liste = GIVBuffInter;\n" \
  "\n" \
  "        iRet = givAnalyseObjetXML(obj, doc, pt_debut_liste, &buf_pos);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeKO == iRet)\n" \
  "        {\n" \
  "            /* fichier global non inclus : retour à état à l'appel */\n" \
  "            buf_pos = *buf_pos_in;\n" \
  "            *piDeb = iDeb;\n" \
  "            *buf_pos = '\\0';\n" \
  "            giviNbCRC = iNbCRC;\n" \
  "            givrListCRC.iNbr = giviNbCRC;\n" \
  "        }\n" \
  "\n" \
  "        if ((0 == strcmp(\"RA\", obj)) || (0 == strcmp(\"DC\", obj)))\n" \
  "            lg_ecr = giv_ecrit_fin_noeud(&buf_pos, pcBalise);\n" \
  "\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Contenus par établissement %s, %s, %s, %d, %d\\n\", doc->value.a_classer.etab, tcRub, obj, iNbCRC, giviNbCRC));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritDonRelais()                                            */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les données relais liées à l'établissement               */\n" \
  "/*             lecture xmltype via clob                                       */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification () :                                                          */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritDonRelais(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 aindice, int4 aindmax)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i = 0;\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    char* pt_debut_element, *pt_debut_obj, *pt_debut_liste, *pt_debut_ref;\n" \
  "    char* pt_fin_element, *pt_fin_obj, *pt_fin_liste, *pt_fin_ref;\n" \
  "    char tcObj[GYBIamicLgNumobj2];\n" \
  "    int4 iCodRet, iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_a_ecrire;\n" \
  "\n" \
  "    if (0 == strlen(doc->value.a_classer.etab))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    /* lecture données relais */\n" \
  "    iRet = givLectureEtabDonSupp(doc->value.a_classer.etab, \"\", \"RL\", giv_REL);\n" \
  "\n" \
  "    if ((0 != strlen(GIVBuffInter)) && (NULL == strstr(GIVBuffInter, \"<lstde/>\")))\n" \
  "    {\n" \
  "        strcpy(buf_pos, GIVBuffInter);\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        buf_pos = (buf_pos + lg_ecr);\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Données Relais par établissement\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givProfURLGratuite\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de rubrique de suppression de CRC\n" \
  " *               dans le fichier GS lié à l'URL Gratuite\n" \
  " *               dans la table GYTTabURLGrProf.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLectureProfURLGratuite(char* apcCodAn8)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrIaprofT rIaprof;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    int4 i;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    (void)strcpy(rIaprof.acCodan8, apcCodAn8);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLectureProfURLGr\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLectureProfURLGr\n" \
  "    USING: rIaprof.acCodan8;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLectureProfURLGr %s: [COD=%d TXT=%s]\\n\", rIaprof.acCodan8, iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLectureProfURLGr\");\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" ProfURLGr... %s\\n\", rIaprof.acCodan8));\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLectureProfURLGr\n" \
  "            INTO: rIaprof.acCodan8;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* sortie sur opposition trouvée */\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLectureProfURLGr;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLectureProfURLGr: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----------------------------------Fonction----------------------------------*\n" \
  " * Fonction : givPrioProfCRC\n" \
  " *\n" \
  " * But : numcli\n" \
  " *\n" \
  " * Description : Lecture de priorité de CRC\n" \
  " *               du le fichier contenu\n" \
  " *               dans la table GYTTabCRCPrioProf.\n" \
  " *\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 givLecturePrioProfCRC(char* apcCodAn8, char* apcCRC)\n" \
  "{\n" \
  "    int4 iCodRet = 0; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = 0; /* Code retour des appels internes */\n" \
  "    int1 indFinFetch;/* Indicateur de fin de balayage du curseur */\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    GYBrPrioCRCT rPrioCRC;\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    int4 i;\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    iIntRet = (int4)GIV::GIXCodeOK;\n" \
  "\n" \
  "    if (0 == strcmp(GXWDepartMultiNat, GIXcDepartement))\n" \
  "        return (iCodRet);\n" \
  "\n" \
  "    (void)strcpy(rPrioCRC.acCodan8, apcCodAn8);\n" \
  "    (void)strcpy(rPrioCRC.acCRC, apcCRC);\n" \
  "    /* Traitement des erreurs SQL */\n" \
  "    (void)strcpy(vErreurSQL.acOrdre_sql, \"open crsLecturePrioProfCRC\");\n" \
  "    EXEC SQL\n" \
  "    OPEN crsLecturePrioProfCRC\n" \
  "    USING :rPrioCRC.acCodan8,\n" \
  "    :rPrioCRC.acCRC;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur open crsLecturePrioProfCRC %s,%s: [COD=%d TXT=%s]\\n\", rPrioCRC.acCodan8, rPrioCRC.acCRC, iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    if ((int4)GIV::GYBok == iIntRet)\n" \
  "    {\n" \
  "        indFinFetch = (int1)GIV::GIXCodeOK;\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"fetch crsLecturePrioProfCRC\");\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" PrioProfCRC... %s,%s\\n\", rPrioCRC.acCodan8, rPrioCRC.acCRC));\n" \
  "\n" \
  "        while ((int1)GIV::GIXCodeOK == indFinFetch)\n" \
  "        {\n" \
  "            EXEC SQL\n" \
  "            FETCH crsLecturePrioProfCRC\n" \
  "            INTO: rPrioCRC.acCodan8;\n" \
  "            iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "            if ((int4)GIV::GYBok != iIntRet)\n" \
  "            {\n" \
  "                indFinFetch = (int1)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* sortie sur opposition trouvée */\n" \
  "                indFinFetch = (int4)GIV::GIXCodeKO;\n" \
  "                iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    EXEC SQL\n" \
  "    close crsLecturePrioProfCRC;\n" \
  "    iIntRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "    if ((int4)GIV::GYBok != iIntRet)\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur close crsLecturePrioProfCRC: [COD=%d TXT=%s]\\n\", iIntRet, vErreurSQL.acDonnees_retour));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givAnalyseContenu()                                            */\n" \
  "/*                                                                            */\n" \
  "/* But       : conflits dans les contenus SGIPRO                              */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification (Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givAnalyseContenu(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iRet, i, iCVI;\n" \
  "    char* pt_fin_liste;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_mil_element;\n" \
  "    char* pt_suite_element;\n" \
  "    char* pt_fin_lst;\n" \
  "    char* pt_debut;\n" \
  "    char* pt_fin;\n" \
  "    char* pt_debut_CVI;\n" \
  "    char tcType[3 + 1];\n" \
  "    char tcTYPE[3 + 1];\n" \
  "    int4 lg_write;\n" \
  "    int4 iNbCVI;\n" \
  "    /* Analyse des contenus prioritaires */\n" \
  "    pt_fin_liste = givtcPrioCont + strlen(givtcPrioCont);\n" \
  "    /* table des contenus prioritaires vide */\n" \
  "    giviConflitCRC = GIV::GWCCodeOK;\n" \
  "    /* pas d'analyse des cvi */\n" \
  "    iCVI = GIV::GIXCodeKO;\n" \
  "    iNbCVI = givNbCVI;\n" \
  "\n" \
  "    for (pt_debut_element = givtcPrioCont; pt_debut_element < pt_fin_liste;)\n" \
  "    {\n" \
  "        pt_fin_element = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "        if (pt_fin_element == 0)\n" \
  "            pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "        pt_mil_element = strchr(pt_debut_element, '/');\n" \
  "\n" \
  "        if (pt_mil_element == 0)\n" \
  "            pt_mil_element = pt_fin_element;\n" \
  "\n" \
  "        /* analyse type et balise associés */\n" \
  "        memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));\n" \
  "        tcType[(pt_mil_element - pt_debut_element)] = '\\0';\n" \
  "        strcpy(tcTYPE, tcType);\n" \
  "        tcTYPE[0] = toupper(tcTYPE[0]);\n" \
  "        tcTYPE[1] = toupper(tcTYPE[1]);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Contenu prioritaire : %s\\n\", tcType));\n" \
  "\n" \
  "        if ((0 == strcmp(tcTYPE, \"DC\")) || (0 == strcmp(tcTYPE, \"RA\")) || (0 == strcmp(tcTYPE, \"PR\")) || (0 == strcmp(tcTYPE, \"OM\")) || (0 == strcmp(tcTYPE, \"DA\")))\n" \
  "        {\n" \
  "            pt_debut_element = pt_fin_element + 1;\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        if ((0 == strcmp(\"EG\", tcTYPE)) || (0 == strcmp(\"EM\", tcTYPE)) || (0 == strcmp(\"GS\", tcTYPE)) || (0 == strcmp(\"ED\", tcTYPE)) || (0 == strcmp(\"EE\", tcTYPE)) || (0 == strcmp(\"BB\", tcTYPE))\n" \
  "                || (0 == strcmp(\"AD\", tcTYPE)) || (0 == strcmp(\"DV\", tcTYPE)) || (0 == strcmp(\"MV\", tcTYPE)))\n" \
  "            iCodRet = givEcritContenuEDEtab(tcType, buf_pos_in, doc, indice);\n" \
  "        else\n" \
  "        {\n" \
  "            for (i = 0; (i < iNbCVI && 0 != strcmp(givTabCVI[i], tcTYPE)); i++)\n" \
  "                ;\n" \
  "\n" \
  "            if ((iNbCVI != i) && (GIV::GIXCodeKO == iCVI))\n" \
  "            {\n" \
  "                /* premier CVI prioritaire : nouveau CVI */\n" \
  "                pt_debut_CVI = pt_debut_element;\n" \
  "                iCVI = GIV::GIXCodeOK;\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"CVI Prio 1 : %d,%s\\n\", iCVI, tcType));\n" \
  "                iCodRet = givEcritContenu(tcType, buf_pos_in, doc, indice, &iCVI);\n" \
  "            }\n" \
  "            else if ((iNbCVI == i) && (GIV::GIXCodeKO != iCVI))\n" \
  "            {\n" \
  "                /* premier CVI prioritaire : vintage/ancien CVI */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"CVI Prio 2 : %d,%s\\n\", iCVI, tcType));\n" \
  "\n" \
  "                if (GIV::GIXCodeOK != iCVI)\n" \
  "                {\n" \
  "                    /* dernier CVI prioritaire : nouveau CVI */\n" \
  "                    lg_write = giv_ecrit_fin_noeud(buf_pos_in, \"affcviv\");\n" \
  "                    *buf_pos_in = *buf_pos_in + lg_write;\n" \
  "                }\n" \
  "\n" \
  "                pt_debut_element = pt_debut_CVI;\n" \
  "                iNbCVI = 0;\n" \
  "                iCVI = GIV::GIXCodeKO;\n" \
  "                continue;\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"CVI Prio 3 : %d,%s\\n\", iCVI, tcType));\n" \
  "                iCodRet = givEcritContenu(tcType, buf_pos_in, doc, indice, &iCVI);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        pt_debut_element = pt_fin_element + 1;\n" \
  "    }\n" \
  "\n" \
  "    /* Analyse des autres contenus non prioritaires */\n" \
  "    pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "    /* table des contenus prioritaires inutilisée */\n" \
  "    giviConflitCRC = GIV::GWCCodeKO;\n" \
  "\n" \
  "    for (pt_debut_element = givtcObjCont; pt_debut_element < pt_fin_liste;)\n" \
  "    {\n" \
  "        pt_fin_element = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "        if (pt_fin_element == 0)\n" \
  "            pt_fin_element = pt_fin_liste;\n" \
  "\n" \
  "        pt_mil_element = strchr(pt_debut_element, '/');\n" \
  "\n" \
  "        if (pt_mil_element == 0)\n" \
  "            break;\n" \
  "\n" \
  "        /* analyse premier type et balise associés */\n" \
  "        pt_suite_element = strchr(pt_debut_element, '|');\n" \
  "\n" \
  "        if ((pt_suite_element != 0) && (pt_suite_element < pt_mil_element))\n" \
  "        {\n" \
  "            memcpy(tcType, pt_debut_element, (pt_suite_element - pt_debut_element));\n" \
  "            tcType[(pt_suite_element - pt_debut_element)] = '\\0';\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            memcpy(tcType, pt_debut_element, (pt_mil_element - pt_debut_element));\n" \
  "            tcType[(pt_mil_element - pt_debut_element)] = '\\0';\n" \
  "        }\n" \
  "\n" \
  "        strcpy(tcTYPE, tcType);\n" \
  "        tcTYPE[0] = toupper(tcTYPE[0]);\n" \
  "        tcTYPE[1] = toupper(tcTYPE[1]);\n" \
  "\n" \
  "        if (0 != strstr(givtcPrioCont, tcType))\n" \
  "        {\n" \
  "            /* contenu prioritaire déjà traité */\n" \
  "            pt_debut_element = pt_fin_element + 1;\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Contenu non prioritaire : %s\\n\", tcType));\n" \
  "\n" \
  "        if ((0 == strcmp(tcTYPE, \"DC\")) || (0 == strcmp(tcTYPE, \"RA\")) || (0 == strcmp(tcTYPE, \"PR\")) || (0 == strcmp(tcTYPE, \"OM\")) || (0 == strcmp(tcTYPE, \"DA\")))\n" \
  "        {\n" \
  "            pt_debut_element = pt_fin_element + 1;\n" \
  "            continue;\n" \
  "        }\n" \
  "\n" \
  "        if ((0 == strcmp(\"EG\", tcTYPE)) || (0 == strcmp(\"EM\", tcTYPE)) || (0 == strcmp(\"GS\", tcTYPE)) || (0 == strcmp(\"ED\", tcTYPE)) || (0 == strcmp(\"EE\", tcTYPE)) || (0 == strcmp(\"BB\", tcTYPE))\n" \
  "                || (0 == strcmp(\"AD\", tcTYPE)) || (0 == strcmp(\"DV\", tcTYPE)) || (0 == strcmp(\"MV\", tcTYPE)))\n" \
  "            iCodRet = givEcritContenuEDEtab(tcType, buf_pos_in, doc, indice);\n" \
  "        else\n" \
  "        {\n" \
  "            iCVI = GIV::GIXCodeKO;\n" \
  "            iCodRet = givEcritContenu(tcType, buf_pos_in, doc, indice, &iCVI);\n" \
  "        }\n" \
  "\n" \
  "        pt_debut_element = pt_fin_element + 1;\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givAnalyseObjetXML()                                           */\n" \
  "/*                                                                            */\n" \
  "/* But       : analyse des objets dans un fichier SGIPRO                      */\n" \
  "/*             modification au format mongoDB                                 */\n" \
  "/* Entree(s) : chaîne                                                         */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification :                                                             */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givAnalyseObjetXML(char* apcType, GYBrDOCUMENTEpj* doc, char* apcChaine, char** buf_pos_in)\n" \
  "{\n" \
  "    char cStr1[4098 + 1] = \"\";\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBaliseFin[50 + 1];\n" \
  "    char* pt_debut_element, *pt_debut_liste;\n" \
  "    char* pt_fin_element, *pt_fin_liste;\n" \
  "    char* pt_debut_prtann, *pt_fin_prtann;\n" \
  "    char* buf_pos;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 iRet, iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "    pt_debut_liste = NULL;\n" \
  "    pt_debut_element = NULL;\n" \
  "    pt_fin_element = NULL;\n" \
  "    pt_fin_liste = apcChaine;\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    pt_debut_prtann = strstr(pt_fin_liste, \"<donneesprt_annotees\");\n" \
  "    pt_fin_prtann = strstr(pt_fin_liste, \"</donneesprt_annotees>\");\n" \
  "\n" \
  "    while (NULL != pt_fin_liste)\n" \
  "    {\n" \
  "        pt_debut_element = strchr(pt_fin_liste, '<');\n" \
  "\n" \
  "        if (NULL == pt_debut_element)\n" \
  "        {\n" \
  "            strcpy(buf_pos, pt_fin_liste);\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            /* fin */\n" \
  "            pt_fin_liste = pt_debut_element;\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "        }\n" \
  "        else if (0 == memcmp(pt_debut_element, \"<normale\", strlen(\"<normale\")))\n" \
  "        {\n" \
  "            pt_debut_liste = strchr(pt_debut_element, '>');\n" \
  "            pt_debut_liste++;\n" \
  "            memcpy(buf_pos, pt_fin_liste, (pt_debut_element - pt_fin_liste));\n" \
  "            lg_ecr = (pt_debut_element - pt_fin_liste);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = '\\0';\n" \
  "            pt_fin_element = strstr(pt_debut_liste, \"</normale>\");\n" \
  "            pt_fin_element += strlen(\"</normale>\");\n" \
  "            pt_fin_liste = pt_fin_element;\n" \
  "            memcpy(cStr1, pt_debut_element, (pt_fin_element - pt_debut_element));\n" \
  "            cStr1[pt_fin_element - pt_debut_element] = '\\0';\n" \
  "            /* analyse CRC */\n" \
  "            iRet = givAnalyseCRC(apcType, -1, doc, cStr1, tcBalise, tcBaliseFin);\n" \
  "\n" \
  "            if ((int4)GIV::GIXCodeOK == iRet)\n" \
  "            {\n" \
  "                /* ne pas inclure le contenu */\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            }\n" \
  "\n" \
  "            strcpy(buf_pos, cStr1);\n" \
  "            buf_pos = buf_pos + strlen(cStr1);\n" \
  "        }\n" \
  "        else if ((0 == memcmp(pt_debut_element, \"<text>\", strlen(\"<text>\"))) && (0 == strcmp(\"OUI\", givtcContText)) && (0 != strcmp(apcType, \"PR\") || (0 == strcmp(apcType, \"PR\") && NULL != pt_debut_prtann\n" \
  "                 && pt_debut_prtann < pt_debut_element && pt_fin_prtann > pt_debut_element)))\n" \
  "        {\n" \
  "            pt_debut_liste = strchr(pt_debut_element, '>');\n" \
  "            pt_debut_liste++;\n" \
  "            memcpy(buf_pos, pt_fin_liste, (pt_debut_liste - pt_fin_liste));\n" \
  "            lg_ecr = (pt_debut_liste - pt_fin_liste);\n" \
  "            pt_fin_element = strstr(pt_debut_liste, \"</text>\");\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = SEPARE_LIGNE;\n" \
  "            *(buf_pos + 1) = LINE_FEED;\n" \
  "            *(buf_pos + 2) = '\\0';\n" \
  "            buf_pos = (buf_pos + 2);\n" \
  "            strcpy(buf_pos, \"<contenu>\");\n" \
  "            buf_pos = buf_pos + strlen(\"<contenu>\");\n" \
  "            memcpy(buf_pos, pt_debut_liste, (pt_fin_element - pt_debut_liste));\n" \
  "            lg_ecr = (pt_fin_element - pt_debut_liste);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            strcpy(buf_pos, \"</contenu>\");\n" \
  "            lg_ecr = strlen(\"</contenu>\");\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = SEPARE_LIGNE;\n" \
  "            *(buf_pos + 1) = LINE_FEED;\n" \
  "            *(buf_pos + 2) = '\\0';\n" \
  "            buf_pos = (buf_pos + 2);\n" \
  "            *buf_pos = '\\0';\n" \
  "            pt_fin_liste = pt_fin_element;\n" \
  "        }\n" \
  "        else if ((0 == memcmp(pt_debut_element, \"<surface>\", strlen(\"<surface>\"))) && (0 != strcmp(\"MO\", apcType)))\n" \
  "        {\n" \
  "            pt_debut_liste = strchr(pt_debut_element, '>');\n" \
  "            pt_debut_liste++;\n" \
  "            memcpy(buf_pos, pt_fin_liste, (pt_debut_element - pt_fin_liste));\n" \
  "            lg_ecr = (pt_debut_element - pt_fin_liste);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = '\\0';\n" \
  "            /* remplacement par text */\n" \
  "            strcpy(buf_pos, \"<text>\");\n" \
  "            buf_pos = buf_pos + strlen(\"<text>\");\n" \
  "            pt_fin_element = strstr(pt_debut_liste, \"</surface>\");\n" \
  "\n" \
  "            if (0 == strcmp(\"NON\", givtcContText))\n" \
  "            {\n" \
  "                memcpy(buf_pos, pt_debut_liste, (pt_fin_element - pt_debut_liste));\n" \
  "                lg_ecr = (pt_fin_element - pt_debut_liste);\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                *buf_pos = SEPARE_LIGNE;\n" \
  "                *(buf_pos + 1) = LINE_FEED;\n" \
  "                *(buf_pos + 2) = '\\0';\n" \
  "                buf_pos = (buf_pos + 2);\n" \
  "                strcpy(buf_pos, \"<contenu>\");\n" \
  "                buf_pos = buf_pos + strlen(\"<contenu>\");\n" \
  "                memcpy(buf_pos, pt_debut_liste, (pt_fin_element - pt_debut_liste));\n" \
  "                lg_ecr = (pt_fin_element - pt_debut_liste);\n" \
  "                buf_pos = (buf_pos + lg_ecr);\n" \
  "                strcpy(buf_pos, \"</contenu>\");\n" \
  "                lg_ecr = strlen(\"</contenu>\");\n" \
  "            }\n" \
  "\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = '\\0';\n" \
  "            pt_fin_element += strlen(\"</surface>\");\n" \
  "            pt_fin_liste = pt_fin_element;\n" \
  "        }\n" \
  "        else if ((0 == memcmp(pt_debut_element, \"<terme>\", strlen(\"<terme>\"))) && (0 != strcmp(\"MO\", apcType)))\n" \
  "        {\n" \
  "            pt_debut_liste = strchr(pt_debut_element + 1, '<');\n" \
  "            memcpy(buf_pos, pt_fin_liste, (pt_debut_element - pt_fin_liste));\n" \
  "            lg_ecr = (pt_debut_element - pt_fin_liste);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = '\\0';\n" \
  "            /* suppression */\n" \
  "            pt_fin_element = pt_debut_liste;\n" \
  "            pt_fin_liste = pt_fin_element;\n" \
  "        }\n" \
  "        else if ((0 == memcmp(pt_debut_element, \"</terme>\", strlen(\"</terme>\"))) && (0 != strcmp(\"MO\", apcType)))\n" \
  "        {\n" \
  "            pt_debut_liste = strchr(pt_debut_element, '>');\n" \
  "            pt_debut_liste++;\n" \
  "            memcpy(buf_pos, pt_fin_liste, (pt_debut_element - pt_fin_liste));\n" \
  "            lg_ecr = (pt_debut_element - pt_fin_liste);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = '\\0';\n" \
  "            /* remplacement par /text */\n" \
  "            strcpy(buf_pos, \"</text>\");\n" \
  "            buf_pos = buf_pos + strlen(\"</text>\");\n" \
  "            pt_fin_element = pt_debut_liste;\n" \
  "            pt_fin_liste = pt_fin_element;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            pt_debut_liste = strchr(pt_debut_element, '>');\n" \
  "            pt_debut_liste++;\n" \
  "            memcpy(buf_pos, pt_fin_liste, (pt_debut_liste - pt_fin_liste));\n" \
  "            lg_ecr = (pt_debut_liste - pt_fin_liste);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "            *buf_pos = '\\0';\n" \
  "            /* suite */\n" \
  "            pt_fin_element = pt_debut_liste;\n" \
  "            pt_fin_liste = pt_fin_element;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givAnalyseTerme()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : analyse des objets terme dans un fichier SGIPRO                */\n" \
  "/*             modification au format mongoDB                                  */\n" \
  "/* Entree(s) : chaîne                                                         */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification :                                                             */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givAnalyseTerme(char* apcChaine)\n" \
  "{\n" \
  "    int4 iCodRet = (int4)GIV::GIXCodeKO; /* Code retour de la fonction */\n" \
  "    char* pcDeb, *pcFin, *pcDebStr, *pcFinStr;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"0 Test Texte/Contenu ... %s\\n\", apcChaine));\n" \
  "    pcDeb = strstr(apcChaine, \"<terme>\");\n" \
  "\n" \
  "    if ((0 != pcDeb) && (0 == strcmp(\"NON\", givtcContText)))\n" \
  "    {\n" \
  "        /* balise supprimée */\n" \
  "        *apcChaine = '\\0';\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "    else if (0 != pcDeb)\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDeb += strlen(\"<terme>\");\n" \
  "        pcFin = apcChaine + strlen(apcChaine);\n" \
  "        (void)strcpy(apcChaine, \"<text>\");\n" \
  "        memmove(apcChaine + strlen(\"<text>\"), pcDeb, pcFin - pcDeb);\n" \
  "        *(apcChaine + strlen(\"<text>\") + (pcFin - pcDeb)) = '\\0';\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    pcDeb = strstr(apcChaine, \"<surface>\");\n" \
  "\n" \
  "    if ((0 != pcDeb) && (0 == strcmp(\"NON\", givtcContText)))\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDeb += strlen(\"<surface>\");\n" \
  "        pcFin = strstr(apcChaine, \"</surface>\");\n" \
  "        pcFinStr = apcChaine + strlen(apcChaine);\n" \
  "\n" \
  "        if (0 == pcFin)\n" \
  "        {\n" \
  "            pcFin = pcFinStr;\n" \
  "            pcDebStr = pcFin;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* balise supprimée */\n" \
  "            pcDebStr = pcFin + strlen(\"</surface>\");\n" \
  "        }\n" \
  "\n" \
  "        (void)strcpy(apcChaine, \"<text>\");\n" \
  "        memmove(apcChaine + strlen(\"<text>\"), pcDeb, pcFin - pcDeb);\n" \
  "        memmove(apcChaine + strlen(\"<text>\") + (pcFin - pcDeb), pcDebStr, pcFinStr - pcDebStr);\n" \
  "        *(apcChaine + strlen(\"<text>\") + (pcFin - pcDeb) + (pcFinStr - pcDebStr)) = '\\0';\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "    else if (0 != pcDeb)\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDeb += strlen(\"<surface>\");\n" \
  "        pcFin = strstr(apcChaine, \"</surface>\");\n" \
  "        pcFinStr = apcChaine + strlen(apcChaine);\n" \
  "\n" \
  "        if (0 == pcFin)\n" \
  "        {\n" \
  "            pcFin = pcFinStr;\n" \
  "            pcDebStr = pcFin;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* balise supprimée */\n" \
  "            pcDebStr = pcFin + strlen(\"</surface>\");\n" \
  "        }\n" \
  "\n" \
  "        memmove(apcChaine + strlen(\"<contenu>\"), pcDeb, pcFin - pcDeb);\n" \
  "\n" \
  "        if (pcFin == pcFinStr)\n" \
  "        {\n" \
  "            memmove(apcChaine + strlen(\"<contenu>\") + (pcFin - pcDeb), pcDebStr, pcFinStr - pcDebStr);\n" \
  "            (void)memcpy(apcChaine, \"<contenu>\", strlen(\"<contenu>\"));\n" \
  "            *(apcChaine + strlen(\"<contenu>\") + (pcFin - pcDeb) + (pcFinStr - pcDebStr)) = '\\0';\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            memmove(apcChaine + strlen(\"<contenu>\") + strlen(\"</contenu>\") + (pcFin - pcDeb), pcDebStr, pcFinStr - pcDebStr);\n" \
  "            (void)memcpy(apcChaine, \"<contenu>\", strlen(\"<contenu>\"));\n" \
  "            (void)memcpy(apcChaine + strlen(\"<contenu>\") + (pcFin - pcDeb), \"</contenu>\", strlen(\"</contenu>\"));\n" \
  "            *(apcChaine + strlen(\"<contenu>\") + strlen(\"</contenu>\") + (pcFin - pcDeb) + (pcFinStr - pcDebStr)) = '\\0';\n" \
  "        }\n" \
  "\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    pcDeb = strstr(apcChaine, \"<text>\");\n" \
  "\n" \
  "    if ((0 != pcDeb) && (0 == strcmp(\"OUI\", givtcContText)))\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDeb += strlen(\"<text>\");\n" \
  "        pcFin = strstr(apcChaine, \"</text>\");\n" \
  "        pcFinStr = apcChaine + strlen(apcChaine);\n" \
  "\n" \
  "        if (0 == pcFin)\n" \
  "        {\n" \
  "            pcFin = pcFinStr;\n" \
  "            pcDebStr = pcFin;\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* balise supprimée */\n" \
  "            pcDebStr = pcFin + strlen(\"</text>\");\n" \
  "        }\n" \
  "\n" \
  "        memmove(apcChaine + strlen(\"<contenu>\"), pcDeb, pcFin - pcDeb);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"1 Test Texte/Contenu ... %s\\n\", apcChaine));\n" \
  "\n" \
  "        if (pcFin == pcFinStr)\n" \
  "        {\n" \
  "            memmove(apcChaine + strlen(\"<contenu>\") + (pcFin - pcDeb), pcDebStr, pcFinStr - pcDebStr);\n" \
  "            (void)memcpy(apcChaine, \"<contenu>\", strlen(\"<contenu>\"));\n" \
  "            *(apcChaine + strlen(\"<contenu>\") + (pcFin - pcDeb) + (pcFinStr - pcDebStr)) = '\\0';\n" \
  "        }\n" \
  "        else if (0 == strchr(pcDebStr, '<'))\n" \
  "        {\n" \
  "            memmove(apcChaine + strlen(\"<contenu>\") + strlen(\"</contenu>\") + (pcFin - pcDeb), pcDebStr, pcFinStr - pcDebStr);\n" \
  "            (void)memcpy(apcChaine, \"<contenu>\", strlen(\"<contenu>\"));\n" \
  "            (void)memcpy(apcChaine + strlen(\"<contenu>\") + (pcFin - pcDeb), \"</contenu>\", strlen(\"</contenu>\"));\n" \
  "            *(apcChaine + strlen(\"<contenu>\") + strlen(\"</contenu>\") + (pcFin - pcDeb) + (pcFinStr - pcDebStr)) = '\\0';\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            memmove(apcChaine + strlen(\"<contenu>\") + strlen(\"</contenu>\") + strlen(\"</text>\") + (pcFin - pcDeb), pcDebStr, pcFinStr - pcDebStr);\n" \
  "            (void)memcpy(apcChaine, \"<contenu>\", strlen(\"<contenu>\"));\n" \
  "            (void)memcpy(apcChaine + strlen(\"<contenu>\") + (pcFin - pcDeb), \"</contenu></text>\", strlen(\"</contenu></text>\"));\n" \
  "            *(apcChaine + strlen(\"<contenu>\") + strlen(\"</contenu>\") + strlen(\"</text>\") + (pcFin - pcDeb) + (pcFinStr - pcDebStr)) = '\\0';\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"2 Test Texte/Contenu ... %s\\n\", apcChaine));\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    pcDeb = strstr(apcChaine, \"</surface>\");\n" \
  "\n" \
  "    if ((0 != pcDeb) && (0 == strcmp(\"NON\", givtcContText)))\n" \
  "    {\n" \
  "        /* balise supprimée */\n" \
  "        pcDebStr = pcDeb + strlen(\"</surface>\");\n" \
  "        pcFinStr = apcChaine + strlen(apcChaine);\n" \
  "        memmove(pcDeb, pcDebStr, pcFinStr - pcDebStr);\n" \
  "        *(pcDeb + (pcFinStr - pcDebStr)) = '\\0';\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "    else if (0 != pcDeb)\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDeb += strlen(\"</surface>\");\n" \
  "        pcFin = apcChaine + strlen(apcChaine);\n" \
  "        memmove(apcChaine + strlen(\"</contenu>\"), pcDeb, pcFin - pcDeb);\n" \
  "        (void)memcpy(apcChaine, \"</contenu>\", strlen(\"</contenu>\"));\n" \
  "        *(apcChaine + strlen(\"</contenu>\") + (pcFin - pcDeb)) = '\\0';\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    pcDeb = strstr(apcChaine, \"</terme>\");\n" \
  "\n" \
  "    if (0 != pcDeb)\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDeb += strlen(\"</terme>\");\n" \
  "        pcFin = apcChaine + strlen(apcChaine);\n" \
  "        (void)strcpy(apcChaine, \"</text>\");\n" \
  "        memmove(apcChaine + strlen(\"</text>\"), pcDeb, pcFin - pcDeb);\n" \
  "        *(apcChaine + strlen(\"</text>\") + (pcFin - pcDeb)) = '\\0';\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    pcDeb = strstr(apcChaine, \"</text>\");\n" \
  "\n" \
  "    if ((0 != pcDeb) && (0 == strcmp(\"OUI\", givtcContText)))\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDebStr = pcDeb;\n" \
  "        pcDeb += strlen(\"</text>\");\n" \
  "        pcFin = apcChaine + strlen(apcChaine);\n" \
  "        /* modif */\n" \
  "        pcFinStr = strchr(pcDeb, '<');\n" \
  "\n" \
  "        if (0 == pcFinStr)\n" \
  "        {\n" \
  "            memmove(pcDebStr + strlen(\"</contenu>\"), pcDeb, pcFin - pcDeb);\n" \
  "            (void)memcpy(pcDebStr, \"</contenu>\", strlen(\"</contenu>\"));\n" \
  "            *(pcDebStr + strlen(\"</contenu>\") + (pcFin - pcDeb)) = '\\0';\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            memmove(pcDebStr + strlen(\"</contenu>\") + strlen(\"</text>\"), pcDeb, pcFin - pcDeb);\n" \
  "            (void)memcpy(pcDebStr, \"</contenu>\", strlen(\"</contenu>\"));\n" \
  "            (void)memcpy(pcDebStr + strlen(\"</contenu>\"), \"</text>\", strlen(\"</text>\"));\n" \
  "            *(pcDebStr + strlen(\"</contenu>\") + strlen(\"</text>\") + (pcFin - pcDeb)) = '\\0';\n" \
  "        }\n" \
  "\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "    else if ((0 != pcDeb) && (0 == strcmp(\"OUI\", givtcContText)) && (pcDeb != apcChaine))\n" \
  "    {\n" \
  "        /* balise remplacée */\n" \
  "        pcDeb += strlen(\"</text>\");\n" \
  "        pcFin = apcChaine + strlen(apcChaine);\n" \
  "        memmove(pcDeb + strlen(\"</contenu>\") - strlen(\"</text>\"), pcDeb, pcFin - pcDeb);\n" \
  "        (void)memcpy(pcDeb - strlen(\"</text>\"), \"</contenu>\", strlen(\"</contenu>\"));\n" \
  "        *(pcDeb + strlen(\"</contenu>\") - strlen(\"</text>\") + (pcFin - pcDeb)) = '\\0';\n" \
  "        iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givAnalyseCRC()                                                */\n" \
  "/*                                                                            */\n" \
  "/* But       : analyse CRC dans un fichier SGIPRO                             */\n" \
  "/*             modification de balise normale en SCG_                         */\n" \
  "/*             . selon rubrique du bloc                                       */\n" \
  "/*             . selon analyse de fichier GS                                  */\n" \
  "/*             . selon priorité                                               */\n" \
  "/* Entree(s) : etab,an9,CRC                                                   */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification :                                                             */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givAnalyseCRC(char* apcType, int4 aiRef, GYBrDOCUMENTEpj* doc, char* apcCRC, char* apcBalise, char* apcBaliseFin)\n" \
  "\n" \
  "{\n" \
  "    int4 iIntRet, iCodRet = (int4)GIV::GIXCodeKO; /* Code retour de la fonction */\n" \
  "    int4 iRet;\n" \
  "    int4 i, j;\n" \
  "    char* pcStr, *pcDeb, *pcFin, *pcDebStr, *pcFinStr;\n" \
  "    int4 iLg;\n" \
  "    GYBrPrioCRCT rPrioCRC;\n" \
  "    char tcAn9Courant[GYBPaprofLgCodan9 + 1];\n" \
  "    (void)strcpy(rPrioCRC.acTpdsob, apcType);\n" \
  "    rPrioCRC.acType[0] = '\\0';\n" \
  "    (void)strcpy(rPrioCRC.acEtab, doc->value.a_classer.etab);\n" \
  "    (void)strcpy(rPrioCRC.acCodan8, givcR000000);\n" \
  "    pcDeb = strstr(apcCRC, \"<normale\");\n" \
  "    strcpy(apcBalise, \"\");\n" \
  "    strcpy(apcBaliseFin, \"\");\n" \
  "\n" \
  "    if (0 == pcDeb)\n" \
  "    {\n" \
  "        /* pas de balise normale correcte : sans changement */\n" \
  "        for (i = 0; (i < givNbCVI && ((0 != strcmp(givTabCVI[i], doc->value.objets_pub.micro[aiRef].stype)) || (2 != doc->value.objets_pub.micro[aiRef].iCVI))); i++)\n" \
  "            ;\n" \
  "\n" \
  "        if ((givNbCVI != i) || (0 == strcmp(\"DV\", apcType)) || (0 == strcmp(\"MO\", apcType)))\n" \
  "        {\n" \
  "            /* pas de traitement de \"terme\" pour CVIV nouvelle ou fichier DV ou Mot Clé */\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        pcDeb = strstr(apcCRC, \"<text>\");\n" \
  "        pcStr = strstr(apcCRC, \"<surface>\");\n" \
  "\n" \
  "        if (0 == pcStr)\n" \
  "            pcStr = strstr(apcCRC, \"</surface>\");\n" \
  "\n" \
  "        if ((0 != pcDeb) && (0 == strcmp(\"OUI\", givtcContText)))\n" \
  "        {\n" \
  "            /* analyse des blocs \"texte\" */\n" \
  "            strcpy(apcBalise, \"text\");\n" \
  "        }\n" \
  "\n" \
  "        /* analyse des blocs \"terme\" */\n" \
  "        iIntRet = givAnalyseTerme(apcCRC);\n" \
  "        /* analyse des blocs \"texte\" */\n" \
  "        pcDeb = strstr(apcCRC, \"</contenu>\");\n" \
  "\n" \
  "        if ((0 != pcDeb) && (0 == pcStr) && (0 == strcmp(\"OUI\", givtcContText)))\n" \
  "        {\n" \
  "            pcDeb = strstr(apcCRC, \"</text>\");\n" \
  "\n" \
  "            if (0 == pcDeb)\n" \
  "                strcpy(apcBaliseFin, \"text\");\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Balise Text <%s> <%s> <%s>\\n\", apcCRC, apcBalise, apcBaliseFin));\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        pcFin = strstr(pcDeb, \">\");\n" \
  "\n" \
  "        if (0 == pcFin)\n" \
  "        {\n" \
  "            /* pas de balise normale correcte : sans changement */\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        pcStr = pcDeb;\n" \
  "        pcDebStr = strstr(pcDeb, \" type=\\\"\");\n" \
  "\n" \
  "        if ((0 != pcDebStr) && (pcDebStr < pcFin))\n" \
  "        {\n" \
  "            pcStr = pcDebStr + strlen(\" type=\\\"\");\n" \
  "\n" \
  "            if ('\"' != *pcStr)\n" \
  "            {\n" \
  "                pcFinStr = strstr(pcStr, \"\\\"\");\n" \
  "\n" \
  "                if (0 != pcFinStr)\n" \
  "                {\n" \
  "                    if (GYBLgPrioType2 <= (pcFinStr - pcStr))\n" \
  "                    {\n" \
  "                        memcpy(rPrioCRC.acType, pcStr, GYBLgPrioType2 - 1);\n" \
  "                        rPrioCRC.acType[GYBLgPrioType2 - 1] = '\\0';\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        memcpy(rPrioCRC.acType, pcStr, pcFinStr - pcStr);\n" \
  "                        rPrioCRC.acType[pcFinStr - pcStr] = '\\0';\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        pcDebStr = strstr(pcDeb, \" an8=\\\"\");\n" \
  "\n" \
  "        if ((0 != pcDebStr) && (pcDebStr < pcFin))\n" \
  "        {\n" \
  "            pcStr = pcDebStr + strlen(\" an8=\\\"\");\n" \
  "\n" \
  "            if ('\"' != *pcStr)\n" \
  "            {\n" \
  "                pcFinStr = strstr(pcStr, \"\\\"\");\n" \
  "\n" \
  "                if (0 != pcFinStr)\n" \
  "                {\n" \
  "                    if (GYBIaprofLgCodan8 <= (pcFinStr - pcStr))\n" \
  "                        memcpy(rPrioCRC.acCodan8, pcFinStr - GYBIaprofLgCodan8, GYBIaprofLgCodan8);\n" \
  "                    else\n" \
  "                        memcpy(&rPrioCRC.acCodan8[GYBIaprofLgCodan8 - (pcFinStr - pcStr)], pcStr, pcFinStr - pcStr);\n" \
  "\n" \
  "                    /* rubrique cadrée sur 6 caractères */\n" \
  "                    iLg = GYBPaprofLgCodan8 + strlen(pcFinStr);\n" \
  "                    memmove(pcStr + GYBIaprofLgCodan8, pcFinStr, strlen(pcFinStr));\n" \
  "                    memcpy(pcStr, rPrioCRC.acCodan8, GYBIaprofLgCodan8);\n" \
  "                    *(pcStr + iLg) = '\\0';\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        pcStr = strstr(pcStr, \">\");\n" \
  "    }\n" \
  "\n" \
  "    pcStr = pcStr + strlen(\">\");\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" Analyse SCG_... %s\\n\", rPrioCRC.acCodan8));\n" \
  "    /* recherche de la rubrique de CRC hors exception parmi les rubriques du bloc */\n" \
  "    i = 0;\n" \
  "\n" \
  "    if ((NULL == strstr(givtcExceptCont, rPrioCRC.acCodan8)) && (0 != strcmp(\"EE\", apcType)) && (0 != strcmp(\"EM\", apcType)) && (0 != strcmp(\"MO\", apcType)))\n" \
  "    {\n" \
  "        if (-1 != aiRef)\n" \
  "        {\n" \
  "            /* inclusion par objet */\n" \
  "            iRet = givInclusionRubrique(rPrioCRC.acCodan8, doc, aiRef);\n" \
  "\n" \
  "            if ((int4)GIV::GWCCodeKO == iRet)\n" \
  "            {\n" \
  "                /* pas d'inclusion dans les rubriques de l'objet */\n" \
  "                i = givrListParu.iNbr;\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* inclusion par bloc */\n" \
  "            strcpy(tcAn9Courant, givcR00000000);\n" \
  "\n" \
  "            for (i = 0; i < (givrListParu.iNbr); i++)\n" \
  "            {\n" \
  "                j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                if (0 != strcmp(tcAn9Courant, givrListParu.trEltList[j].rub))\n" \
  "                {\n" \
  "                    strcpy(tcAn9Courant, givrListParu.trEltList[j].rub);\n" \
  "\n" \
  "                    if (0 == strcmp(rPrioCRC.acCodan8, givrListParu.trEltList[j].rubinit))\n" \
  "                        break;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((givrListParu.iNbr == i) && (0 != strcmp(givcR000000, rPrioCRC.acCodan8)))\n" \
  "    {\n" \
  "        /* rubrique de CRC absente des rubriques du bloc */\n" \
  "        /* balise CRC marquée supprimée */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" SCG_IAPROF... %s\\n\", apcCRC));\n" \
  "        iLg = strlen(apcCRC);\n" \
  "        memmove(pcStr + strlen(\"SCG_\"), pcStr, strlen(pcStr));\n" \
  "        memcpy(pcStr, \"SCG_\", strlen(\"SCG_\"));\n" \
  "        *(apcCRC + iLg + strlen(\"SCG_\")) = '\\0';\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\" SCG_IAPROF... %s\\n\", apcCRC));\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    if ((0 == strcmp(\"GS\", apcType)) && (0 != strcmp(givcR000000, rPrioCRC.acCodan8)))\n" \
  "    {\n" \
  "        /* liste d'opposition CRC de fichier GS */\n" \
  "        iCodRet = givOppositionURLGratuite(doc->value.a_classer.etab, rPrioCRC.acCodan8);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "        {\n" \
  "            /* fichier non inclus */\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    /* priorité du CRC du fichier contenu */\n" \
  "    pcFinStr = strstr(pcStr, \"</normale>\");\n" \
  "\n" \
  "    if (0 == pcFinStr)\n" \
  "    {\n" \
  "        /* balise absente : sans changement */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "    else if ((pcFinStr - pcStr) < 0)\n" \
  "    {\n" \
  "        /* balise absente : sans changement */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* CRC */\n" \
  "    if (GYBLgPrioCRC2 <= (pcFinStr - pcStr))\n" \
  "    {\n" \
  "        memcpy(rPrioCRC.acCRC, pcStr, GYBLgPrioCRC2 - 1);\n" \
  "        rPrioCRC.acCRC[GYBLgPrioCRC2 - 1] = '\\0';\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        memcpy(rPrioCRC.acCRC, pcStr, pcFinStr - pcStr);\n" \
  "        rPrioCRC.acCRC[pcFinStr - pcStr] = '\\0';\n" \
  "    }\n" \
  "\n" \
  "    if (0 != strcmp(\"MO\", apcType))\n" \
  "    {\n" \
  "        /* analyse du black-listage en liste réponse */\n" \
  "        iCodRet = givLectureBListCRCLR(&rPrioCRC);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "        {\n" \
  "            /* balise CRC marquée supprimée */\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" SCG_BL_LR... %s\\n\", apcCRC));\n" \
  "            iLg = strlen(apcCRC);\n" \
  "            memmove(pcStr + strlen(\"SCG_\"), pcStr, strlen(pcStr));\n" \
  "            memcpy(pcStr, \"SCG_\", strlen(\"SCG_\"));\n" \
  "            *(apcCRC + iLg + strlen(\"SCG_\")) = '\\0';\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" SCG_BL_LR... %s\\n\", apcCRC));\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        /* analyse du black-listage en fiche détaillée */\n" \
  "        iCodRet = givLectureBListCRCFD(&rPrioCRC);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "        {\n" \
  "            /* balise CRC marquée supprimée */\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" SCG_BL_FD... %s\\n\", apcCRC));\n" \
  "            iLg = strlen(apcCRC);\n" \
  "            memmove(pcStr + strlen(\"SCG_\"), pcStr, strlen(pcStr));\n" \
  "            memcpy(pcStr, \"SCG_\", strlen(\"SCG_\"));\n" \
  "            *(apcCRC + iLg + strlen(\"SCG_\")) = '\\0';\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" SCG_BL_FD... %s\\n\", apcCRC));\n" \
  "            /* balise conservée à l'affichage en fiche détaillée */\n" \
  "            rPrioCRC.iPrioCRC = GIV::GIXCodeKO;\n" \
  "            iIntRet = givAjoutListCRC(rPrioCRC);\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((0 == strcmp(\"GS\", apcType)) && (0 != strcmp(givcR000000, rPrioCRC.acCodan8)))\n" \
  "    {\n" \
  "        /* suppression de CRC de fichier GS */\n" \
  "        iCodRet = givLectureProfURLGratuite(rPrioCRC.acCodan8);\n" \
  "\n" \
  "        for (i = 0; i < nb_micro && !(0 == strcmp(doc->value.objets_pub.micro[i].type, \"X\") && 0 == strcmp(doc->value.objets_pub.micro[i].stype, \" U\")); i++)\n" \
  "            ;\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"GS et U... %d, %d\\n\", i, nb_micro));\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeKO == iCodRet)\n" \
  "        {\n" \
  "            /* balise CRC marquée supprimée */\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" SCG_GS... %s\\n\", apcCRC));\n" \
  "            iLg = strlen(apcCRC);\n" \
  "            memmove(pcStr + strlen(\"SCG_\"), pcStr, strlen(pcStr));\n" \
  "            memcpy(pcStr, \"SCG_\", strlen(\"SCG_\"));\n" \
  "            *(apcCRC + iLg + strlen(\"SCG_\")) = '\\0';\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\" SCG_GS... %s\\n\", apcCRC));\n" \
  "        }\n" \
  "\n" \
  "        if (nb_micro != i)\n" \
  "        {\n" \
  "            /* coexistence avec type U */\n" \
  "            /* balise non conservée à l'affichage en fiche détaillée */\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (GIV::GWCCodeOK != giviConflitCRC)\n" \
  "    {\n" \
  "        /* pas de conflit hors priorité */\n" \
  "        rPrioCRC.iPrioCRC = GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* conflit si priorité */\n" \
  "        rPrioCRC.iPrioCRC = GIV::GIXCodeOK;\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\" Analyse SCG_... %s\\n\", rPrioCRC.acCRC));\n" \
  "\n" \
  "    for (i = 0; (i < giviNbCRC && GIV::GIXCodeOK == rPrioCRC.iPrioCRC); i++)\n" \
  "    {\n" \
  "        /* contenu prioritaire pour la rubrique */\n" \
  "        if ((0 == strcmp(givrListCRC.trEltList[i].acCodan8, rPrioCRC.acCodan8)) && (0 == strcmp(givrListCRC.trEltList[i].acCRC, rPrioCRC.acCRC)) && (GIV::GIXCodeOK == givrListCRC.trEltList[i].iPrioCRC))\n" \
  "        {\n" \
  "            /* balise sans changement */\n" \
  "            break;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (GIV::GIXCodeOK != rPrioCRC.iPrioCRC)\n" \
  "    {\n" \
  "        rPrioCRC.iPrioCRC = GIV::GIXCodeKO;\n" \
  "        iIntRet = givAjoutListCRC(rPrioCRC);\n" \
  "    }\n" \
  "    else if (giviNbCRC == i)\n" \
  "    {\n" \
  "        iCodRet = givLecturePrioProfCRC(rPrioCRC.acCodan8, rPrioCRC.acCRC);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "        {\n" \
  "            /* contenu soumis à priorité pour la rubrique */\n" \
  "            for (j = 0; j < giviNbCRC; j++)\n" \
  "            {\n" \
  "                /* contenu non prioritaire pour la rubrique */\n" \
  "                if ((0 == strcmp(givrListCRC.trEltList[j].acCodan8, rPrioCRC.acCodan8)) && (0 != strcmp(givrListCRC.trEltList[j].acTpdsob, rPrioCRC.acTpdsob)) && (GIV::GIXCodeOK == givrListCRC.trEltList[j].iPrioCRC))\n" \
  "                    break;\n" \
  "            }\n" \
  "\n" \
  "            if (giviNbCRC == j)\n" \
  "            {\n" \
  "                /* contenu prioritaire pour la rubrique */\n" \
  "                /* balise sans changement */\n" \
  "                iIntRet = givAjoutListCRC(rPrioCRC);\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* contenu non prioritaire pour la rubrique */\n" \
  "                /* balise CRC marquée supprimée */\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" SCG_PRIO... %s\\n\", apcCRC));\n" \
  "                iLg = strlen(apcCRC);\n" \
  "                memmove(pcStr + strlen(\"SCG_\"), pcStr, strlen(pcStr));\n" \
  "                memcpy(pcStr, \"SCG_\", strlen(\"SCG_\"));\n" \
  "                *(apcCRC + iLg + strlen(\"SCG_\")) = '\\0';\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\" SCG_PRIO... %s\\n\", apcCRC));\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "                return (iCodRet);\n" \
  "            }\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            rPrioCRC.iPrioCRC = GIV::GIXCodeKO;\n" \
  "            iIntRet = givAjoutListCRC(rPrioCRC);\n" \
  "        }\n" \
  "\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "    else if (0 != strcmp(givrListCRC.trEltList[i].acEtab, rPrioCRC.acEtab))\n" \
  "    {\n" \
  "        rPrioCRC.iPrioCRC = GIV::GIXCodeKO;\n" \
  "        iIntRet = givAjoutListCRC(rPrioCRC);\n" \
  "    }\n" \
  "\n" \
  "    givrListCRC.iNbr = giviNbCRC;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritContenuED()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les contenus SGIPRO                                      */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification (Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritContenuED(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr_micro = 0;\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i = 0;\n" \
  "    int4 j = 0;\n" \
  "    int4 k = 0;\n" \
  "    int4 l = 0;\n" \
  "    int4 iDebut;\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_a_ecrire;\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    iDebut = 1;\n" \
  "\n" \
  "    for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "    {\n" \
  "        /* inscription locale */\n" \
  "        l = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "        if (GIV::giv_LOC == givrListParu.trEltList[l].iGeoLoc)\n" \
  "        {\n" \
  "            /* écriture SGIPRO */\n" \
  "            iCodRet = givEcritSgiProED(\"ED\", \"affedito\", &buf_pos, *buf_pos_in, doc, givrListParu.trEltList[l].rub, givrListParu.trEltList[l].dep, givrListParu.trEltList[l].loc, &iDebut);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (buf_pos != *buf_pos_in)\n" \
  "    {\n" \
  "        strcpy(buf_pos, \"</sgipro>\");\n" \
  "        lg_ecr = strlen(buf_pos);\n" \
  "        *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "        *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "        *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "        buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"affedito\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Contenu ED\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritContenuEDEtab()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit les contenus SGIPRO                                      */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, valeur_id_parution                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/* Modification (Jui/20/2006 - mb) : création de plusieurs fichiers de sortie */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "\n" \
  "static int4 givEcritContenuEDEtab(char* obj, char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice)\n" \
  "\n" \
  "{\n" \
  "    int4 lg_ecr = 0;\n" \
  "    int4 i = 0;\n" \
  "    int4 j = 0;\n" \
  "    int4 k = 0;\n" \
  "    int4 l = 0;\n" \
  "    int4 iDebut;\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos, *buf_pos_ref;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char tcAn9Courant[GYBPaprofLgCodan9 + 1];\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char* pt_fin_liste;\n" \
  "    char tcType[3 + 1];\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBaliseFin[50 + 1];\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "\n" \
  "    /* Ecriture dans le fichier de sortie */\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie_ISO(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    strcpy(tcType, obj);\n" \
  "    strcat(tcType, \"/\");\n" \
  "    tcBalise[0] = '\\0';\n" \
  "    pt_debut_element = strstr(givtcObjCont, tcType);\n" \
  "    pt_fin_liste = givtcObjCont + strlen(givtcObjCont);\n" \
  "\n" \
  "    if (0 != pt_debut_element)\n" \
  "    {\n" \
  "        /* pas de balise associée */\n" \
  "        pt_debut_element += strlen(tcType);\n" \
  "        pt_fin_element = strchr(pt_debut_element, ',');\n" \
  "\n" \
  "        if (0 != pt_fin_element)\n" \
  "        {\n" \
  "            memcpy(tcBalise, (pt_debut_element), (pt_fin_element - pt_debut_element));\n" \
  "            tcBalise[(pt_fin_element - pt_debut_element)] = '\\0';\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            memcpy(tcBalise, (pt_debut_element), (pt_fin_liste - pt_debut_element));\n" \
  "            tcBalise[(pt_fin_liste - pt_debut_element)] = '\\0';\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if (0 == strlen(tcBalise))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_GRAVE, (\"Balise de contenu non configurée %s\\n\", obj));\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Ecriture Contenu %s,%s\\n\", obj, tcBalise));\n" \
  "    strcpy(tcType, obj);\n" \
  "    tcType[0] = toupper(tcType[0]);\n" \
  "    tcType[1] = toupper(tcType[1]);\n" \
  "\n" \
  "    if ((0 == strcmp(\"ED\", tcType)) || (0 == strcmp(\"EE\", tcType)))\n" \
  "    {\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        strcpy(tcAn9Courant, givcR00000000);\n" \
  "        iDebut = 1;\n" \
  "\n" \
  "        for (j = 0; j < (givrListParu.iNbr); j++)\n" \
  "        {\n" \
  "            /* inscription à thème */\n" \
  "            l = givrListParu.trEltRangList[j];\n" \
  "\n" \
  "            if (0 != strcmp(tcAn9Courant, givrListParu.trEltList[l].rub))\n" \
  "            {\n" \
  "                strcpy(tcAn9Courant, givrListParu.trEltList[l].rub);\n" \
  "                /* Appel a la fonction de lecture du theme de rubrique */\n" \
  "                iCodRet = givLectureThemeED(givrListParu.trEltList[l].rub);\n" \
  "\n" \
  "                if (0 != strlen(buf_concat))\n" \
  "                {\n" \
  "                    for (i = 0; i < j; i++)\n" \
  "                    {\n" \
  "                        k = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                        if (0 == strcmp(buf_concat, givrListParu.trEltList[k].thm))\n" \
  "                            break;\n" \
  "                    }\n" \
  "\n" \
  "                    if (i == j)\n" \
  "                    {\n" \
  "                        i = 0;\n" \
  "\n" \
  "                        /* écriture SGIPRO */\n" \
  "                        if (0 == strcmp(tcType, obj))\n" \
  "                        {\n" \
  "                            /* accès à un fichier */\n" \
  "                            iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, buf_concat, \"\", \"\", &iDebut);\n" \
  "                        }\n" \
  "                        else\n" \
  "                        {\n" \
  "                            /* accès à la base */\n" \
  "                            iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, buf_concat, \"\", \"\", &iDebut);\n" \
  "                        }\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                strcpy(givrListParu.trEltList[l].thm, buf_concat);\n" \
  "            }\n" \
  "            else\n" \
  "                strcpy(givrListParu.trEltList[l].thm, \"\");\n" \
  "        }\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            strcpy(buf_pos, \"</sgipro>\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"BB\", tcType))\n" \
  "    {\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        iDebut = 1;\n" \
  "        i = 0;\n" \
  "\n" \
  "        /* écriture SGIPRO */\n" \
  "        if (0 == strcmp(tcType, obj))\n" \
  "        {\n" \
  "            /* accès à un fichier */\n" \
  "            iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", \"\", &iDebut);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* accès à la base hors service */\n" \
  "            /* iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc+i, \"\", \"\", \"\", &iDebut); */\n" \
  "        }\n" \
  "\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Eciture BB fichier SGIPRO ED : %d\\n\", iDebut));\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            strcpy(buf_pos, \"</sgipro>\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            if ('\\0' != GIVBuffXML[0])\n" \
  "            {\n" \
  "                /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "                iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"EG\", tcType))\n" \
  "    {\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        iDebut = 1;\n" \
  "        i = 0;\n" \
  "\n" \
  "        if (-1 == (doc + i)->value.a_classer.iBLEPJProf)\n" \
  "        {\n" \
  "            strcpy(tcAn9Courant, givcR00000000);\n" \
  "            (doc + i)->value.a_classer.iBLEPJProf = 0;\n" \
  "\n" \
  "            for (k = 0; k < (givrListParu.iNbr); k++)\n" \
  "            {\n" \
  "                l = givrListParu.trEltRangList[k];\n" \
  "\n" \
  "                if ((0 != strcmp(tcAn9Courant, givrListParu.trEltList[l].rub)) && (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000)))\n" \
  "                {\n" \
  "                    strcpy(tcAn9Courant, givrListParu.trEltList[l].rub);\n" \
  "                    /* liste d'opposition CRC de fichier GS */\n" \
  "                    iCodRet = givLectureBListEPJProf((doc + i)->value.a_classer.etab, givrListParu.trEltList[l].rubinit);\n" \
  "\n" \
  "                    if ((int4)GIV::GIXCodeKO == iCodRet)\n" \
  "                    {\n" \
  "                        /* balises à inclure */\n" \
  "                        (doc + i)->value.a_classer.iBLEPJProf = 0;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    (doc + i)->value.a_classer.iBLEPJProf = 1;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        /* écriture SGIPRO */\n" \
  "        if (0 == strcmp(tcType, obj))\n" \
  "        {\n" \
  "            /* accès à un fichier */\n" \
  "            iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", \"\", &iDebut);\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            /* accès à la base */\n" \
  "            iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", \"\", &iDebut);\n" \
  "        }\n" \
  "\n" \
  "        if ((1 == iDebut) && (0 != strlen(doc->value.objets_pub.libUrlSite)))\n" \
  "        {\n" \
  "            i = 0;\n" \
  "            iDebut = 0;\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"sgipro\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            strcat(buf_pos, \"<annonceur etablissement=\\\"\\\" id=\\\"\");\n" \
  "\n" \
  "            if ((0 == strlen((doc + i)->value.a_classer.etab)) && (i + 1 == indice))\n" \
  "                strcat(buf_pos, (doc + i)->value.numero_client);\n" \
  "            else\n" \
  "                strcat(buf_pos, (doc + i)->value.a_classer.etab);\n" \
  "\n" \
  "            strcat(buf_pos, \"\\\">\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"1\", \"prcplt\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, \"0\", \"prdura\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, \"infosCpltDonneesEnrichies\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_balise(buf_pos, (doc + i)->value.objets_pub.libUrlSite, \"urlSite\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"infosCpltDonneesEnrichies\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, \"annonceur\");\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            strcpy(buf_pos, \"</sgipro>\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            if ('\\0' != GIVBuffXML[0])\n" \
  "            {\n" \
  "                /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "                iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"EM\", tcType))\n" \
  "    {\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        iDebut = 1;\n" \
  "        i = 0;\n" \
  "\n" \
  "        if (-1 == (doc + i)->value.a_classer.iBLEPJProf)\n" \
  "        {\n" \
  "            strcpy(tcAn9Courant, givcR00000000);\n" \
  "            (doc + i)->value.a_classer.iBLEPJProf = 0;\n" \
  "\n" \
  "            for (k = 0; k < givrListParu.iNbr; k++)\n" \
  "            {\n" \
  "                l = givrListParu.trEltRangList[k];\n" \
  "\n" \
  "                if ((0 != strcmp(tcAn9Courant, givrListParu.trEltList[l].rub)) && (0 != strcmp(givrListParu.trEltList[l].rub, givcR00000000)))\n" \
  "                {\n" \
  "                    strcpy(tcAn9Courant, givrListParu.trEltList[l].rub);\n" \
  "                    /* liste d'opposition CRC de fichier GS */\n" \
  "                    iCodRet = givLectureBListEPJProf((doc + i)->value.a_classer.etab, givrListParu.trEltList[l].rubinit);\n" \
  "\n" \
  "                    if ((int4)GIV::GIXCodeKO == iCodRet)\n" \
  "                    {\n" \
  "                        /* fichier à inclure */\n" \
  "                        (doc + i)->value.a_classer.iBLEPJProf = 0;\n" \
  "                        break;\n" \
  "                    }\n" \
  "\n" \
  "                    (doc + i)->value.a_classer.iBLEPJProf = 1;\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 == (doc + i)->value.a_classer.iBLEPJProf)\n" \
  "        {\n" \
  "            /* écriture SGIPRO */\n" \
  "            if (0 == strcmp(tcType, obj))\n" \
  "            {\n" \
  "                /* accès à un fichier */\n" \
  "                iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "                for (j = 0; j < giviNbProfEtab; j++)\n" \
  "                {\n" \
  "                    if ((0 == strcmp(givrListProfEtab[j].tcEtab, (doc + i)->value.a_classer.etab)) && ('V' == givrListProfEtab[j].cIndic))\n" \
  "                    {\n" \
  "                        /* accès à un fichier DV avec an8 */\n" \
  "                        iRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, givrListProfEtab[j].tcAn8, \"\", \"\", &iDebut);\n" \
  "\n" \
  "                        if ('\\0' != GIVBuffXML[0])\n" \
  "                        {\n" \
  "                            /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "                            iRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                            iCodRet = (int4)GIV::GIXCodeOK;\n" \
  "                        }\n" \
  "                    }\n" \
  "                }\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeKO == iCodRet)\n" \
  "                {\n" \
  "                    /* accès à un fichier DE sans an8 */\n" \
  "                    iRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", \"\", &iDebut);\n" \
  "                }\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* accès à la base */\n" \
  "                iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", \"\", &iDebut);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            strcpy(buf_pos, \"</sgipro>\");\n" \
  "            lg_ecr = strlen(buf_pos);\n" \
  "            *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "            *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "            *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            if ('\\0' != GIVBuffXML[0])\n" \
  "            {\n" \
  "                /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "                iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"DV\", tcType))\n" \
  "    {\n" \
  "        /* DV ou Marques par an8 pour CVIV */\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        iDebut = 1;\n" \
  "\n" \
  "        for (j = 0; j < giviNbProfEtab; j++)\n" \
  "        {\n" \
  "            if ('V' == givrListProfEtab[j].cIndic)\n" \
  "            {\n" \
  "                /* accès à un fichier */\n" \
  "                iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc, givrListProfEtab[j].tcAn8, \"\", \"\", &iDebut);\n" \
  "\n" \
  "                if ('\\0' != GIVBuffXML[0])\n" \
  "                {\n" \
  "                    /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "                    iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            if ('\\0' != GIVBuffXML[0])\n" \
  "            {\n" \
  "                /* Ecriture dans le fichier de sortie sans changement de format */\n" \
  "                iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"GS\", tcType))\n" \
  "    {\n" \
  "        *buf_pos_in = buf_pos;\n" \
  "        iDebut = 1;\n" \
  "        i = 0;\n" \
  "        /* liste d'opposition fichier GS complet */\n" \
  "        iCodRet = givOppositionURLGratuite((doc + i)->value.a_classer.etab, givcR000000);\n" \
  "\n" \
  "        /* écriture SGIPRO */\n" \
  "        if ((int4)GIV::GIXCodeKO == iCodRet)\n" \
  "        {\n" \
  "            if (0 == strcmp(tcType, obj))\n" \
  "            {\n" \
  "                /* accès à un fichier */\n" \
  "                iCodRet = givEcritSgiProED(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", \"\", &iDebut);\n" \
  "            }\n" \
  "            else\n" \
  "            {\n" \
  "                /* accès à la base */\n" \
  "                iCodRet = givEcritDonEtab(tcType, tcBalise, &buf_pos, *buf_pos_in, doc + i, \"\", \"\", \"\", &iDebut);\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "    }\n" \
  "    else if (0 == strcmp(\"AD\", tcType))\n" \
  "    {\n" \
  "        /* données additionnelles annotées */\n" \
  "        iCodRet = givEcritDonAdd(tcType, &buf_pos, doc, indice);\n" \
  "    }\n" \
  "\n" \
  "    if ('\\0' != GIVBuffXML[0])\n" \
  "    {\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Sortie Ecriture Contenu ED par établissement\\n\"));\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritImages ()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit le corps PHOTOS des PVI                                  */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 givEcritImages(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 iRef)\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_tmp;\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cStr[4096 + 1] = \"\";\n" \
  "    char* pcDebut, *pcFin;\n" \
  "    int4 i;\n" \
  "    struct timeval sTemps1;\n" \
  "    struct timeval sTemps2;\n" \
  "    long double iDureeAppelMilliSec;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    (void)memset((void*)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));\n" \
  "\n" \
  "    /* ouverture du fichier des mouvements CD2G */\n" \
  "    /* constitution du nom du fichier */\n" \
  "    if (0 == strlen(doc->value.numero_client))\n" \
  "        (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, \"IP\", doc->value.objets_pub.micro[iRef].id[4], doc->value.objets_pub.micro[iRef].id[5],\n" \
  "                      doc->value.objets_pub.micro[iRef].id[6], doc->value.objets_pub.micro[iRef].id[7], doc->value.objets_pub.micro[iRef].id[8], doc->value.objets_pub.micro[iRef].stype,\n" \
  "                      doc->value.objets_pub.micro[iRef].id);\n" \
  "    else\n" \
  "        (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, \"IP\", doc->value.numero_client[0], doc->value.numero_client[1], doc->value.numero_client[2], doc->value.numero_client[3],\n" \
  "                      doc->value.numero_client[4], \"IP\", doc->value.objets_pub.micro[iRef].id);\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nom fichier PHOTOS <%s>\\n\", cNomFichier));\n" \
  "    /* temps d'accès SGIPro */\n" \
  "    /* gettimeofday(&sTemps1, NULL); */\n" \
  "    /* Ouverture fichier SGIPRO */\n" \
  "    GIVfDescFicPhotos = fopen(cNomFichier, \"r\");\n" \
  "\n" \
  "    if (NULL == GIVfDescFicPhotos)\n" \
  "    {\n" \
  "        /* Echec ouverture fichier mouvements => erreur */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur FOPEN fichier Photos : [ERR=%02Xh, PTH=%s]\\n\", errno, cNomFichier));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    pcDebut = 0;\n" \
  "    pcFin = 0;\n" \
  "\n" \
  "    do\n" \
  "    {\n" \
  "        /* lecture de la ligne suivante */\n" \
  "        (void)fgets(cStr, sizeof(cStr), GIVfDescFicPhotos);\n" \
  "\n" \
  "        /* suppression des espaces en début de ligne */\n" \
  "        for (i = 0; ((isblank((unsigned char)cStr[i])) && (i < strlen(cStr))); i++)\n" \
  "            ;\n" \
  "\n" \
  "        /* ligne de liste associée à SGIPRO */\n" \
  "        if ((0 != pcDebut) && (0 == pcFin))\n" \
  "        {\n" \
  "            pcFin = strstr(&cStr[i], \"</photos>\");\n" \
  "\n" \
  "            if (0 == pcFin)\n" \
  "            {\n" \
  "                if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)))\n" \
  "                {\n" \
  "                    /* Ecriture dans le fichier de sortie */\n" \
  "                    iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* écriture de ligne courante entre début et fin */\n" \
  "            strcpy(buf_pos, &cStr[i]);\n" \
  "            buf_pos = buf_pos + strlen(buf_pos);\n" \
  "        }\n" \
  "\n" \
  "        if (0 == pcDebut)\n" \
  "        {\n" \
  "            pcDebut = strstr(&cStr[i], \"<photos>\");\n" \
  "\n" \
  "            if (0 != pcDebut)\n" \
  "            {\n" \
  "                strcpy(buf_pos, &cStr[i]);\n" \
  "                buf_pos = buf_pos + strlen(buf_pos);\n" \
  "                pcFin = 0;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != pcDebut) && (0 == pcFin))\n" \
  "        {\n" \
  "            pcFin = strstr(&cStr[i], \"</photos>\");\n" \
  "\n" \
  "            if (0 != pcFin)\n" \
  "            {\n" \
  "                strcpy(buf_pos, &cStr[i]);\n" \
  "                buf_pos = buf_pos + strlen(buf_pos);\n" \
  "                pcDebut = 0;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "    while (0 == feof(GIVfDescFicPhotos));\n" \
  "\n" \
  "    /* Fermeture fichier SGIPRO */\n" \
  "    iIntRet = fclose(GIVfDescFicPhotos);\n" \
  "#if 0\n" \
  "    /* temps d'accès SGIPro */\n" \
  "    gettimeofday(&sTemps2, NULL);\n" \
  "    iDureeAppelMilliSec = (double)((double)((sTemps2.tv_sec - sTemps1.tv_sec) * 1000000) +\n" \
  "                                   (double)(sTemps2.tv_usec - sTemps1.tv_usec));\n" \
  "    GIViCumulDureeIncl += iDureeAppelMilliSec;\n" \
  "    GIViCumulNbreIncl ++;\n" \
  "    GWTTrace(GWT_NIV_FONCT,\n" \
  "             (\"Durée inclusion %s : %0.Lf microsecondes, Cumul : %0.Lf, %0.Lf microsecondes\\n\", givtcRepSgiPro,\n" \
  "              iDureeAppelMilliSec, GIViCumulNbreIncl, GIViCumulDureeIncl));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Debut %d, %d\\n\", sTemps1.tv_sec, sTemps1.tv_usec));\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Fin %d, %d\\n\", sTemps2.tv_sec, sTemps2.tv_usec));\n" \
  "#endif\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritSgiPro ()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit le corps SGIPRO des contenus                             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 givEcritSgiPro(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 iDoc, int4 iRef, int4 indice, char* pcBalise, int4 iBalise)\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_tmp;\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cStr[4096 + 1] = \"\";\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBaliseFin[50 + 1];\n" \
  "    char* pcDebut, *pcFin;\n" \
  "    int4 i, k, iNbCRC;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    (void)memset((void*)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));\n" \
  "\n" \
  "    /* constitution du nom du fichier */\n" \
  "    if (0 != (doc + iDoc)->value.objets_pub.micro[iRef].iCVI)\n" \
  "    {\n" \
  "        /* CVI vintage ou nouvel objet */\n" \
  "        if (0 == strlen((doc + iDoc)->value.numero_client))\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, (doc + iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc + iDoc)->value.objets_pub.micro[iRef].id[4],\n" \
  "                          (doc + iDoc)->value.objets_pub.micro[iRef].id[5], (doc + iDoc)->value.objets_pub.micro[iRef].id[6], (doc + iDoc)->value.objets_pub.micro[iRef].id[7], (doc + iDoc)->value.objets_pub.micro[iRef].id[8],\n" \
  "                          (doc + iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc + iDoc)->value.objets_pub.micro[iRef].id);\n" \
  "        else\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, (doc + iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc + iDoc)->value.numero_client[0],\n" \
  "                          (doc + iDoc)->value.numero_client[1], (doc + iDoc)->value.numero_client[2], (doc + iDoc)->value.numero_client[3], (doc + iDoc)->value.numero_client[4],\n" \
  "                          (doc + iDoc)->value.objets_pub.micro[iRef].stypcvi, (doc + iDoc)->value.objets_pub.micro[iRef].id);\n" \
  "    }\n" \
  "    else if (0 == strlen((doc + iDoc)->value.numero_client))\n" \
  "    {\n" \
  "        if (' ' == (doc + iDoc)->value.objets_pub.micro[iRef].stype[0])\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, &(doc + iDoc)->value.objets_pub.micro[iRef].stype[1], (doc + iDoc)->value.objets_pub.micro[iRef].id[4],\n" \
  "                          (doc + iDoc)->value.objets_pub.micro[iRef].id[5], (doc + iDoc)->value.objets_pub.micro[iRef].id[6], (doc + iDoc)->value.objets_pub.micro[iRef].id[7], (doc + iDoc)->value.objets_pub.micro[iRef].id[8],\n" \
  "                          &(doc + iDoc)->value.objets_pub.micro[iRef].stype[1], (doc + iDoc)->value.objets_pub.micro[iRef].id);\n" \
  "        else\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, (doc + iDoc)->value.objets_pub.micro[iRef].stype, (doc + iDoc)->value.objets_pub.micro[iRef].id[4],\n" \
  "                          (doc + iDoc)->value.objets_pub.micro[iRef].id[5], (doc + iDoc)->value.objets_pub.micro[iRef].id[6], (doc + iDoc)->value.objets_pub.micro[iRef].id[7], (doc + iDoc)->value.objets_pub.micro[iRef].id[8],\n" \
  "                          (doc + iDoc)->value.objets_pub.micro[iRef].stype, (doc + iDoc)->value.objets_pub.micro[iRef].id);\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        if (' ' == (doc + iDoc)->value.objets_pub.micro[iRef].stype[0])\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, &(doc + iDoc)->value.objets_pub.micro[iRef].stype[1], (doc + iDoc)->value.numero_client[0],\n" \
  "                          (doc + iDoc)->value.numero_client[1], (doc + iDoc)->value.numero_client[2], (doc + iDoc)->value.numero_client[3], (doc + iDoc)->value.numero_client[4],\n" \
  "                          &(doc + iDoc)->value.objets_pub.micro[iRef].stype[1], (doc + iDoc)->value.objets_pub.micro[iRef].id);\n" \
  "        else\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, (doc + iDoc)->value.objets_pub.micro[iRef].stype, (doc + iDoc)->value.numero_client[0],\n" \
  "                          (doc + iDoc)->value.numero_client[1], (doc + iDoc)->value.numero_client[2], (doc + iDoc)->value.numero_client[3], (doc + iDoc)->value.numero_client[4],\n" \
  "                          (doc + iDoc)->value.objets_pub.micro[iRef].stype, (doc + iDoc)->value.objets_pub.micro[iRef].id);\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nom fichier SGIPRO <%s>\\n\", cNomFichier));\n" \
  "    /* Ouverture fichier SGIPRO */\n" \
  "    GIVfDescFicSGIPRO = fopen(cNomFichier, \"r\");\n" \
  "\n" \
  "    if (NULL == GIVfDescFicSGIPRO)\n" \
  "    {\n" \
  "        /* Echec ouverture fichier mouvements => erreur */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur FOPEN fichier SGIPRO : [ERR=%02Xh, PTH=%s]\\n\", errno, cNomFichier));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    pcDebut = 0;\n" \
  "    pcFin = 0;\n" \
  "\n" \
  "    do\n" \
  "    {\n" \
  "        /* lecture de la ligne suivante */\n" \
  "        (void)fgets(cStr, sizeof(cStr), GIVfDescFicSGIPRO);\n" \
  "\n" \
  "        /* ligne de liste associée à SGIPRO */\n" \
  "        if ((0 != pcDebut) && (0 == pcFin))\n" \
  "        {\n" \
  "            pcFin = strstr(cStr, \"</sgipro>\");\n" \
  "\n" \
  "            if (0 == pcFin)\n" \
  "            {\n" \
  "                if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)))\n" \
  "                {\n" \
  "                    /* Ecriture dans le fichier de sortie */\n" \
  "                    iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                }\n" \
  "\n" \
  "                /* écriture de ligne courante entre début et fin */\n" \
  "                iNbCRC = giviNbCRC;\n" \
  "                iCodRet = givAnalyseCRC((doc + iDoc)->value.objets_pub.micro[iRef].stype, iRef, (doc + iDoc), cStr, tcBalise, tcBaliseFin);\n" \
  "\n" \
  "                if ((0 == strcmp(\"SC\", (doc + iDoc)->value.objets_pub.micro[iRef].stype)) && (0 != strcmp(\"SR\", (doc + iDoc)->value.objets_pub.micro[iRef].sstype)) && (0 != strstr(cStr, \"</pvi>\")))\n" \
  "                {\n" \
  "                    /* pour PVI inclusion du fichier \"IP\" */\n" \
  "                    iIntRet = givEcritImages(&buf_pos, (doc + iDoc), iRef);\n" \
  "                }\n" \
  "\n" \
  "                lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                strcpy(buf_pos, cStr);\n" \
  "                buf_pos = buf_pos + strlen(buf_pos);\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBaliseFin);\n" \
  "            }\n" \
  "\n" \
  "            buf_pos = buf_pos + strlen(buf_pos);\n" \
  "        }\n" \
  "\n" \
  "        if (0 == pcDebut)\n" \
  "        {\n" \
  "            pcDebut = strstr(cStr, \"<sgipro>\");\n" \
  "\n" \
  "            if (0 != pcDebut)\n" \
  "            {\n" \
  "                buf_pos = buf_pos + strlen(buf_pos);\n" \
  "                pcFin = 0;\n" \
  "\n" \
  "                if (buf_pos == *buf_pos_in)\n" \
  "                {\n" \
  "                    if (((int4)GIV::GIXCodeKO == iBalise) || ((int4)GIV::GIXCodeRIEN == iBalise))\n" \
  "                    {\n" \
  "                        lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "                        buf_pos = buf_pos + lg_write;\n" \
  "                    }\n" \
  "\n" \
  "                    iIntRet = giv_ecrit_objet_pub(&buf_pos, (doc + iDoc), 0, iRef, \"objetcontenu\");\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != pcDebut) && (0 == pcFin))\n" \
  "        {\n" \
  "            pcFin = strstr(cStr, \"</sgipro>\");\n" \
  "\n" \
  "            if (0 != pcFin)\n" \
  "                pcDebut = 0;\n" \
  "        }\n" \
  "    }\n" \
  "    while (0 == feof(GIVfDescFicSGIPRO));\n" \
  "\n" \
  "    /* Fermeture fichier SGIPRO */\n" \
  "    iIntRet = fclose(GIVfDescFicSGIPRO);\n" \
  "    iCodRet = GIV::GWCCodeKO;\n" \
  "\n" \
  "    if (buf_pos != *buf_pos_in)\n" \
  "        iCodRet = GIV::GWCCodeOK;\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritSgiProPart ()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit le corps SGIPRO des contenus des partenaires             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 givEcritSgiProPart(char** buf_pos_in, GYBrDOCUMENTEpj* doc, char* pcEtab, char* pcRef, char* pcType, char* pcBalise, int4* piDeb)\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cStr[4096 + 1] = \"\";\n" \
  "    char cStr1[4098 + 1] = \"\";\n" \
  "    char cNomBalise[100];\n" \
  "    char cNomBalises[100];\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBaliseFin[50 + 1];\n" \
  "    int4 iDebut;\n" \
  "    int4 j, jRef;\n" \
  "    char tcType[3];\n" \
  "    /* Initialisation des variables locales */\n" \
  "    (void)memset((void*)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));\n" \
  "    /* mutalisation */\n" \
  "    strcpy(tcType, pcType);\n" \
  "    strcpy(cNomBalises, pcBalise);\n" \
  "    sprintf(cNomBalise, \"elempart_%s\", &pcRef[strlen(pcRef) - 4]);\n" \
  "    /* ouverture du fichier des mouvements CD2G */\n" \
  "    /* constitution du nom du fichier */\n" \
  "    (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s.xml\", givtcRepSgiPro, tcType, pcRef[0], pcRef[1], pcRef[2], pcRef[3], pcRef[4], pcRef);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nom fichier SGIPRO <%s>\\n\", cNomFichier));\n" \
  "    /* Ouverture fichier SGIPRO */\n" \
  "    GIVfDescFicSGIPRO = fopen(cNomFichier, \"r\");\n" \
  "\n" \
  "    if (NULL == GIVfDescFicSGIPRO)\n" \
  "    {\n" \
  "        /* Echec ouverture fichier mouvements => erreur */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fichier SGIPRO Partenaire absent: [ERR=%02Xh, PTH=%s]\\n\", errno, cNomFichier));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    iDebut = (int4) - 1;\n" \
  "\n" \
  "    do\n" \
  "    {\n" \
  "        /* lecture de la ligne suivante */\n" \
  "        (void)fgets(cStr, sizeof(cStr), GIVfDescFicSGIPRO);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fichier Part <%s>\\n\", cStr));\n" \
  "\n" \
  "        /* ligne de liste associée à SGIPRO */\n" \
  "        if ((1 == iDebut) && (0 != strcmp(cStr1, cStr)))\n" \
  "        {\n" \
  "            if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)))\n" \
  "            {\n" \
  "                /* Ecriture dans le fichier de sortie */\n" \
  "                iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            }\n" \
  "\n" \
  "            iCodRet = givAnalyseCRC(tcType, -1, doc, cStr, tcBalise, tcBaliseFin);\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            strcpy(buf_pos, cStr);\n" \
  "            buf_pos = buf_pos + strlen(buf_pos);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBaliseFin);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "        else if ((0 == iDebut) && (cStr[0] == '<'))\n" \
  "        {\n" \
  "            iDebut = 1;\n" \
  "            (void)strcpy(&cStr1[2], &cStr[1]);\n" \
  "            cStr1[0] = '<';\n" \
  "            cStr1[1] = '/';\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            for (j = 0; j < doc->value.a_classer.iNbPart; j++)\n" \
  "            {\n" \
  "                if (0 == strcmp(pcRef, doc->value.a_classer.trpart[j].rpart))\n" \
  "                    jRef = j;\n" \
  "            }\n" \
  "\n" \
  "            lg_write = giv_ecrit_element_partenaire(cNomBalise, buf_pos, pcRef, pcEtab, doc->value.a_classer.trpart[jRef].parent);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "        else if (((int4) - 1 == iDebut) && (0 == memcmp(\"]>\", cStr, 2)))\n" \
  "            iDebut = 0;\n" \
  "    }\n" \
  "    while (0 == feof(GIVfDescFicSGIPRO));\n" \
  "\n" \
  "    /* Fermeture fichier SGIPRO */\n" \
  "    iIntRet = fclose(GIVfDescFicSGIPRO);\n" \
  "\n" \
  "    if (buf_pos != *buf_pos_in)\n" \
  "    {\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, cNomBalise);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, pcBalise);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritSgiProPartEtab ()                                      */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit le corps SGIPRO des contenus des partenaires             */\n" \
  "/*             par établissement                                              */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 givEcritSgiProPartEtab(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice, char* pcEtab, char* pcRef, char* pcType, char* pcBalise, int4* piDeb)\n" \
  "{\n" \
  "    int4 lg_write, lg_ecr = 0;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iCrcRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char cNomBalise[100];\n" \
  "    char cNomBalises[100];\n" \
  "    char tcType[3];\n" \
  "    char* pt_debut_element, *pt_debut_liste;\n" \
  "    char* pt_fin_element, *pt_fin_liste;\n" \
  "    GYBrIapartT rIapart;\n" \
  "    int4 i, j, iRef, jRef;\n" \
  "    int4 iRgParent, iNbParent;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    strcpy(tcType, pcType);\n" \
  "    strcpy(cNomBalises, pcBalise);\n" \
  "    strcat(cNomBalises, \"s\");\n" \
  "    sprintf(cNomBalise, \"elempart_%s\", &pcRef[strlen(pcRef) - 4]);\n" \
  "    /* référence de partenaire */\n" \
  "    (void)strcpy(rIapart.acOriPart, &pcRef[strlen(pcRef) - 4]);\n" \
  "    memcpy(rIapart.acRefPart, pcRef, strlen(pcRef) - 4);\n" \
  "    rIapart.acRefPart[strlen(pcRef) - 4] = '\\0';\n" \
  "    rIapart.acParentRefPart[0] = '\\0';\n" \
  "    rIapart.acTypeRefPart[0] = '\\0';\n" \
  "    iRef = 0;\n" \
  "    jRef = 0;\n" \
  "\n" \
  "    for (i = 0; i < indice; i++)\n" \
  "    {\n" \
  "        for (j = 0; j < (doc + i)->value.a_classer.iNbPart; j++)\n" \
  "        {\n" \
  "            if (0 == strcmp(pcRef, (doc + i)->value.a_classer.trpart[j].rpart))\n" \
  "            {\n" \
  "                strcpy(rIapart.acParentRefPart, (doc + i)->value.a_classer.trpart[j].parent);\n" \
  "                strcpy(rIapart.acTypeRefPart, (doc + i)->value.a_classer.trpart[j].typepart);\n" \
  "                iRgParent = (doc + i)->value.a_classer.trpart[j].iRgParent;\n" \
  "                iNbParent = (doc + i)->value.a_classer.trpart[j].iNbParent;\n" \
  "                iRef = i;\n" \
  "                jRef = j;\n" \
  "            }\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    /* lecture donnée \"complément\" */\n" \
  "    iRet = givLecturePartEtab(&rIapart, GIV::GIXCodeOK);\n" \
  "\n" \
  "    if ((0 != strlen(GIVBuffInter)) && (NULL == strstr(GIVBuffInter, \"<complement/>\")))\n" \
  "    {\n" \
  "        if (1 == *piDeb)\n" \
  "            *piDeb = 0;\n" \
  "\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_element_partenaire(cNomBalise, buf_pos, pcRef, pcEtab, rIapart.acParentRefPart);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* analyse CRC <normale> */\n" \
  "        pt_fin_liste = GIVBuffInter;\n" \
  "        pt_debut_liste = strstr(pt_fin_liste, \"<complement>\");\n" \
  "        pt_debut_liste += strlen(\"<complement>\");\n" \
  "        pt_debut_liste++;\n" \
  "        pt_fin_liste = strstr(pt_debut_liste, \"</complement>\");\n" \
  "        *pt_fin_liste = '\\0';\n" \
  "        iCodRet = givAnalyseObjetXML(pcType, doc, pt_debut_liste, &buf_pos);\n" \
  "        lg_ecr = strlen(GIVBuffXML);\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "\n" \
  "        if (0 == strcmp(giv_PJDC, rIapart.acOriPart))\n" \
  "        {\n" \
  "            /* analyse parent pour c et pr */\n" \
  "            if (giv_cPJDC == rIapart.acTypeRefPart[0])\n" \
  "            {\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Cle annexe <%s> \\n\", (doc + iRef)->value.a_classer.trpart[jRef].clenav));\n" \
  "                lg_write = giv_ecrit_noeud_attr(buf_pos, \"equipe\", (doc + iRef)->value.a_classer.trpart[jRef].clenav);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            if ((giv_prPJDC == rIapart.acTypeRefPart[0]) || (giv_cPJDC == rIapart.acTypeRefPart[0]))\n" \
  "            {\n" \
  "                for (i = iRgParent; i < (iRgParent + iNbParent); i++)\n" \
  "                {\n" \
  "                    if ((giv_cPJDC == givtrPart[i].acTypeRefPart[0]) || (giv_prPJDC == givtrPart[i].acTypeRefPart[0]))\n" \
  "                    {\n" \
  "                        lg_write = GIV_ecrit_element_parent(&buf_pos, &givtrPart[i]);\n" \
  "                        buf_pos = buf_pos + lg_write;\n" \
  "                    }\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            if (giv_cPJDC == rIapart.acTypeRefPart[0])\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_fin_noeud(&buf_pos, \"equipe\");\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            /* analyse parent pour o, sv, c et pr */\n" \
  "            iCodRet = (int4)giv_ecrit_navigation(&buf_pos, iRgParent, iNbParent, doc->value.a_classer.trpart[giviRefPJDC].typepart[0], &rIapart, (doc + iRef)->value.a_classer.trpart[jRef].clenav);\n" \
  "        }\n" \
  "\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "    }\n" \
  "\n" \
  "    /* lecture donnée \"photos\" */\n" \
  "    if ((int4)GIV::GWCCodeOK == iRet)\n" \
  "    {\n" \
  "        iRet = givLecturePartEtab(&rIapart, GIV::GIXCodeKO);\n" \
  "\n" \
  "        if ((0 != strlen(GIVBuffInter)) && (NULL == strstr(GIVBuffInter, \"<photos/>\")))\n" \
  "        {\n" \
  "            if (1 == *piDeb)\n" \
  "                *piDeb = 0;\n" \
  "\n" \
  "            if (0 == lg_ecr)\n" \
  "            {\n" \
  "                lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "                lg_write = giv_ecrit_element_partenaire(cNomBalise, buf_pos, pcRef, pcEtab, rIapart.acParentRefPart);\n" \
  "                buf_pos = buf_pos + lg_write;\n" \
  "            }\n" \
  "\n" \
  "            lg_ecr = strlen(GIVBuffInter);\n" \
  "            strcpy(buf_pos, GIVBuffInter);\n" \
  "            buf_pos = (buf_pos + lg_ecr);\n" \
  "        }\n" \
  "\n" \
  "        if (0 != lg_ecr)\n" \
  "        {\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, cNomBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, pcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritSgiProBOC ()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit le corps SGIPRO des contenus BOC Contributifs            */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 givEcritSgiProBOC(char** buf_pos_in, GYBrDOCUMENTEpj* doc, int4 indice, char* pcRef, char* pcType, char* pcBalise)\n" \
  "{\n" \
  "    int4 lg_write;\n" \
  "    char* buf_pos;\n" \
  "    char* deb_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cStr[4096 + 1] = \"\";\n" \
  "    char cStr1[4098 + 1] = \"\";\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBaliseFin[50 + 1];\n" \
  "    int4 iDebut, i, j;\n" \
  "    char* pt_debut_element;\n" \
  "    char* pt_fin_element;\n" \
  "    char tcRub[GYBPaprofLgCodan9 + 1];\n" \
  "    /* Initialisation des variables locales */\n" \
  "    (void)memset((void*)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));\n" \
  "    /* ouverture du fichier des mouvements CD2G */\n" \
  "    /* constitution du nom du fichier */\n" \
  "    (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s.xml\", givtcRepSgiPro, pcType, pcRef[0], pcRef[1], pcRef[2], pcRef[3], pcRef[4], pcRef);\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nom fichier SGIPRO BOC <%s>\\n\", cNomFichier));\n" \
  "    /* Ouverture fichier SGIPRO */\n" \
  "    GIVfDescFicSGIPRO = fopen(cNomFichier, \"r\");\n" \
  "\n" \
  "    if (NULL == GIVfDescFicSGIPRO)\n" \
  "    {\n" \
  "        /* Echec ouverture fichier mouvements => erreur */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fichier SGIPRO BOC absent: [ERR=%02Xh, PTH=%s]\\n\", errno, cNomFichier));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        /* contenu absent pour l'epj */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    deb_pos = buf_pos;\n" \
  "    iDebut = (int4) - 2;\n" \
  "    /* lecture de la ligne */\n" \
  "    (void)fgets(cStr, sizeof(cStr), GIVfDescFicSGIPRO);\n" \
  "\n" \
  "    while (0 == feof(GIVfDescFicSGIPRO))\n" \
  "    {\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Fichier BOC %d,<%s>\\n\", iDebut, cStr));\n" \
  "\n" \
  "        /* ligne de liste associée à SGIPRO */\n" \
  "        if ((2 == iDebut) && (NULL == strstr(cStr, cStr1)))\n" \
  "        {\n" \
  "            if (NULL != strstr(cStr, \"rubrique\"))\n" \
  "            {\n" \
  "                pt_debut_element = strchr(&cStr[1], '>');\n" \
  "                pt_fin_element = strchr(&cStr[1], '<');\n" \
  "\n" \
  "                if (NULL == pt_fin_element || NULL == pt_debut_element)\n" \
  "                {\n" \
  "                    /* pas de rubrique commune */\n" \
  "                    iDebut = 1;\n" \
  "                    buf_pos = deb_pos;\n" \
  "                    (void)strcpy(&cStr1[1], \"fragment\");\n" \
  "                    cStr1[0] = '<';\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                pt_debut_element++;\n" \
  "\n" \
  "                if (GYBPaprofLgCodan9 != (pt_fin_element - pt_debut_element))\n" \
  "                {\n" \
  "                    iDebut = 1;\n" \
  "                    buf_pos = deb_pos;\n" \
  "                    (void)strcpy(&cStr1[1], \"fragment\");\n" \
  "                    cStr1[0] = '<';\n" \
  "                    continue;\n" \
  "                }\n" \
  "\n" \
  "                memcpy(tcRub, pt_debut_element, (pt_fin_element - pt_debut_element));\n" \
  "                tcRub[(pt_fin_element - pt_debut_element)] = '\\0';\n" \
  "                GWTTrace(GWT_NIV_FONCT, (\"Rub BOC <%s>\\n\", tcRub));\n" \
  "\n" \
  "                for (i = 0; i < (givrListParu.iNbrTot); i++)\n" \
  "                {\n" \
  "                    j = givrListParu.trEltRangList[i];\n" \
  "\n" \
  "                    if (0 == strcmp(givrListParu.trEltList[j].rub, tcRub))\n" \
  "                        break;\n" \
  "                }\n" \
  "\n" \
  "                if (i == givrListParu.iNbrTot)\n" \
  "                {\n" \
  "                    /* pas de rubrique commune */\n" \
  "                    iDebut = 1;\n" \
  "                    buf_pos = deb_pos;\n" \
  "                    (void)strcpy(&cStr1[1], \"fragment\");\n" \
  "                    cStr1[0] = '<';\n" \
  "                    continue;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            iCodRet = givAnalyseCRC(pcType, -1, doc, cStr, tcBalise, tcBaliseFin);\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            strcpy(buf_pos, cStr);\n" \
  "            buf_pos = buf_pos + strlen(buf_pos);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBaliseFin);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "        }\n" \
  "        else if ((2 == iDebut) && (NULL != strstr(cStr, cStr1)))\n" \
  "        {\n" \
  "            iDebut = 1;\n" \
  "            (void)strcpy(&cStr1[1], \"fragment\");\n" \
  "            cStr1[0] = '<';\n" \
  "            strcpy(buf_pos, cStr);\n" \
  "            buf_pos = buf_pos + strlen(cStr);\n" \
  "            /* Ecriture dans le fichier de sortie */\n" \
  "            iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "            deb_pos = buf_pos;\n" \
  "        }\n" \
  "        else if ((1 == iDebut) && (NULL != strstr(cStr, cStr1)))\n" \
  "        {\n" \
  "            iDebut = 2;\n" \
  "            (void)strcpy(&cStr1[2], \"fragment\");\n" \
  "            cStr1[0] = '<';\n" \
  "            cStr1[1] = '/';\n" \
  "            strcpy(buf_pos, cStr);\n" \
  "            buf_pos = buf_pos + strlen(cStr);\n" \
  "        }\n" \
  "        else if (0 == iDebut)\n" \
  "        {\n" \
  "            iCodRet = givAnalyseCRC(pcType, -1, doc, cStr, tcBalise, tcBaliseFin);\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            strcpy(buf_pos, cStr);\n" \
  "            buf_pos = buf_pos + strlen(buf_pos);\n" \
  "            lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBaliseFin);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "\n" \
  "            if ((NULL == strstr(cStr, cStr1)) && (NULL == strstr(cStr, \"annonceur\")))\n" \
  "                deb_pos = buf_pos - strlen(cStr);\n" \
  "            else if (NULL != strstr(cStr, \"annonceur\"))\n" \
  "                deb_pos = buf_pos;\n" \
  "            else\n" \
  "            {\n" \
  "                iDebut = 2;\n" \
  "                (void)strcpy(&cStr1[2], \"fragment\");\n" \
  "                cStr1[0] = '<';\n" \
  "                cStr1[1] = '/';\n" \
  "            }\n" \
  "        }\n" \
  "        else if ((-1 == iDebut) && (cStr[0] == '<'))\n" \
  "        {\n" \
  "            iDebut = 0;\n" \
  "            (void)strcpy(&cStr1[1], \"fragment\");\n" \
  "            cStr1[0] = '<';\n" \
  "            lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "            buf_pos = buf_pos + lg_write;\n" \
  "            deb_pos = buf_pos;\n" \
  "        }\n" \
  "        else if (((int4) - 2 == iDebut) && (0 == memcmp(\"]>\", cStr, 2)))\n" \
  "            iDebut = -1;\n" \
  "\n" \
  "        /* lecture de la ligne suivante */\n" \
  "        (void)fgets(cStr, sizeof(cStr), GIVfDescFicSGIPRO);\n" \
  "    }\n" \
  "\n" \
  "    /* Fermeture fichier SGIPRO */\n" \
  "    iIntRet = fclose(GIVfDescFicSGIPRO);\n" \
  "\n" \
  "    if ((-1 != iDebut) && (-2 != iDebut))\n" \
  "    {\n" \
  "        if (0 == iDebut)\n" \
  "        {\n" \
  "            buf_pos = deb_pos;\n" \
  "            /* contenu absent pour l'epj */\n" \
  "        }\n" \
  "\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, pcBalise);\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "    }\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : givEcritSgiProED ()                                              */\n" \
  "/*                                                                            */\n" \
  "/* But       : ecrit le corps SGIPRO des contenus                             */\n" \
  "/*                                                                            */\n" \
  "/*                                                                            */\n" \
  "/* Entree(s) : un buffer, Structure Document                                  */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) : OK ou KO                                                       */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Transparent                                                    */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "static int4 givEcritSgiProED(char* acobj, char* pcBalise, char** buf_pos_in, char* buf_pos_ref, GYBrDOCUMENTEpj* doc, char* tcRub, char* tcDep, char* tcSource, int4* piDeb)\n" \
  "{\n" \
  "    int4 lg_write, lg_ecr = 0;\n" \
  "    char* buf_pos;\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 lg_tmp;\n" \
  "    int4 iBLEPJProf = 0;\n" \
  "    char cNomFichier[128] = \"\";\n" \
  "    char obj[3 + 1] = \"\";\n" \
  "    char tcBalise[50 + 1];\n" \
  "    char tcBaliseFin[50 + 1];\n" \
  "    /* Pathname des fichiers utilises */\n" \
  "    char cStr[4096 + 1] = \"\";\n" \
  "    char cStrRef[100 + 1] = \"\";\n" \
  "    char cStrFinRef[100 + 1] = \"\";\n" \
  "    char cStrSupp[100 + 1] = \"\";\n" \
  "    char cStrFinSupp[100 + 1] = \"\";\n" \
  "    char* pcDebut, *pcFin;\n" \
  "    /* Initialisation des variables locales */\n" \
  "    (void)memset((void*)cNomFichier, 0x00, (size_t)sizeof(cNomFichier));\n" \
  "    /* type d'objet */\n" \
  "    strcpy(obj, acobj);\n" \
  "\n" \
  "    /* ouverture du fichier des mouvements CD2G */\n" \
  "    /* constitution du nom du fichier */\n" \
  "    if ((0 == strcmp(givtcRapED, \"ETAB\")) && (0 != strcmp(\"EG\", obj)) && (0 != strcmp(\"EM\", obj)) && (0 != strcmp(\"DV\", obj)) && (0 != strcmp(\"MV\", obj)) && (0 != strcmp(\"GS\", obj))\n" \
  "            && (0 != strcmp(\"BB\", obj)) && (0 != strcmp(\"AD\", obj)))\n" \
  "    {\n" \
  "        if (0 == strlen(doc->value.a_classer.etab))\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Pas Nom fichier SGIPRO %s\\n\", obj));\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s_%s.xml\", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2],\n" \
  "                      doc->value.a_classer.etab[3], doc->value.a_classer.etab[4], obj, doc->value.a_classer.etab, tcRub);\n" \
  "    }\n" \
  "    else if ((0 == strcmp(givtcRapED, \"ETAB\")) && (0 == strcmp(\"EG\", obj) || 0 == strcmp(\"EM\", obj) || 0 == strcmp(\"DV\", obj) || 0 == strcmp(\"MV\", obj) || 0 == strcmp(\"GS\", obj)\n" \
  "             || 0 == strcmp(\"BB\", obj)))\n" \
  "    {\n" \
  "        if (0 == strlen(doc->value.a_classer.etab))\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Pas Nom fichier SGIPRO %s\\n\", obj));\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != strlen(tcRub)) && (((0 == strcmp(\"DV\", obj))) || (0 == strcmp(\"EM\", obj))))\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s_%s.xml\", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2],\n" \
  "                          doc->value.a_classer.etab[3], doc->value.a_classer.etab[4], obj, doc->value.a_classer.etab, tcRub);\n" \
  "        else\n" \
  "            (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s.xml\", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2],\n" \
  "                          doc->value.a_classer.etab[3], doc->value.a_classer.etab[4], obj, doc->value.a_classer.etab);\n" \
  "    }\n" \
  "    else if ((0 == strcmp(givtcRapED, \"ETAB\")) && (0 == strcmp(\"AD\", obj)))\n" \
  "    {\n" \
  "        if (0 == strlen(doc->value.a_classer.etab))\n" \
  "        {\n" \
  "            GWTTrace(GWT_NIV_FONCT, (\"Pas Nom fichier SGIPRO %s\\n\", obj));\n" \
  "            iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "            return (iCodRet);\n" \
  "        }\n" \
  "\n" \
  "        (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c%c%c/%s_%s_%s.xml\", givtcRepSgiPro, obj, doc->value.a_classer.etab[0], doc->value.a_classer.etab[1], doc->value.a_classer.etab[2],\n" \
  "                      doc->value.a_classer.etab[3], doc->value.a_classer.etab[4], obj, doc->value.a_classer.etab, tcSource);\n" \
  "    }\n" \
  "    else if (0 == strcmp(givtcRapED, \"OUI\"))\n" \
  "        (void)sprintf(&cNomFichier[0], \"%s/%s/%c%c/%c/%s_%s_%s_%s_%s.xml\", givtcRepSgiPro, obj, tcDep[0], tcDep[1], tcDep[2], obj, tcDep, tcSource, doc->value.inscription[0].val_num, tcRub);\n" \
  "\n" \
  "    /* balise de référence à rechercher */\n" \
  "    strcpy(cStrRef, \"<sgipro>\");\n" \
  "    strcpy(cStrFinRef, \"</sgipro>\");\n" \
  "    strcpy(cStrSupp, \"<lstMarques>\");\n" \
  "    strcpy(cStrFinSupp, \"</lstMarques>\");\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"Nom fichier SGIPRO %s <%s>\\n\", obj, cNomFichier));\n" \
  "    /* Ouverture fichier SGIPRO */\n" \
  "    GIVfDescFicSGIPRO = fopen(cNomFichier, \"r\");\n" \
  "\n" \
  "    if (NULL == GIVfDescFicSGIPRO)\n" \
  "    {\n" \
  "        /* Echec ouverture fichier mouvements => erreur */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Erreur FOPEN fichier SGIPRO ED : [ERR=%02Xh, PTH=%s]\\n\", errno, cNomFichier));\n" \
  "        iCodRet = (int4)GIV::GIXCodeKO;\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    /* Initialisation pointeur */\n" \
  "    buf_pos = *buf_pos_in;\n" \
  "    pcDebut = 0;\n" \
  "    pcFin = 0;\n" \
  "\n" \
  "    do\n" \
  "    {\n" \
  "        /* lecture de la ligne suivante */\n" \
  "        (void)fgets(cStr, sizeof(cStr), GIVfDescFicSGIPRO);\n" \
  "\n" \
  "        /* ligne de liste associée à SGIPRO */\n" \
  "        if ((0 != pcDebut) && (0 == pcFin))\n" \
  "        {\n" \
  "            pcFin = strstr(cStr, cStrFinRef);\n" \
  "\n" \
  "            if (0 == pcFin)\n" \
  "            {\n" \
  "                if (sizeof(GIVBuffXML) < (strlen(GIVBuffXML) + strlen(cStr)))\n" \
  "                {\n" \
  "                    /* Ecriture dans le fichier de sortie */\n" \
  "                    iCodRet = (int4)giv_sortie(&buf_pos, GIVfDescFicBloc);\n" \
  "                }\n" \
  "\n" \
  "                if ((0 == strcmp(\"EG\", obj)) && (0 != strstr(cStr, \"<urlSite>\")) && (0 != strlen(doc->value.objets_pub.libUrlSite)))\n" \
  "                {\n" \
  "                    strcpy(&cStr[0], \"<urlSite>\");\n" \
  "                    strcat(cStr, doc->value.objets_pub.libUrlSite);\n" \
  "                    strcat(cStr, \"</urlSite>\");\n" \
  "                    lg_ecr = strlen(cStr);\n" \
  "                    *(cStr + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(cStr + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                    *(cStr + (lg_ecr + 2)) = '\\0';\n" \
  "                    (void)strcpy(doc->value.objets_pub.libUrlSite, \"\");\n" \
  "                }\n" \
  "\n" \
  "                /* écriture de ligne courante entre début et fin */\n" \
  "                iCodRet = givAnalyseCRC(obj, -1, doc, cStr, tcBalise, tcBaliseFin);\n" \
  "\n" \
  "                if ((int4)GIV::GIXCodeOK == iCodRet)\n" \
  "                {\n" \
  "                    /* fichier global non inclus */\n" \
  "                    buf_pos = *buf_pos_in;\n" \
  "                    *buf_pos = '\\0';\n" \
  "                    break;\n" \
  "                }\n" \
  "\n" \
  "                if (0 == strcmp(\"EG\", obj))\n" \
  "                {\n" \
  "                    if ((0 != strstr(cStr, cStrSupp)) && (1 == doc->value.a_classer.iBLEPJProf))\n" \
  "                    {\n" \
  "                        /* Black-listage de balise */\n" \
  "                        iBLEPJProf = 1;\n" \
  "                    }\n" \
  "\n" \
  "                    if (0 == iBLEPJProf)\n" \
  "                    {\n" \
  "                        lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "                        buf_pos = buf_pos + lg_write;\n" \
  "                        strcpy(buf_pos, cStr);\n" \
  "                        buf_pos = buf_pos + strlen(buf_pos);\n" \
  "                        lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBaliseFin);\n" \
  "                    }\n" \
  "\n" \
  "                    if ((0 != strstr(cStr, cStrFinSupp)) && (1 == doc->value.a_classer.iBLEPJProf))\n" \
  "                    {\n" \
  "                        /* Fin du Black-listage de balise */\n" \
  "                        iBLEPJProf = 0;\n" \
  "                    }\n" \
  "                }\n" \
  "                else\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, tcBalise);\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    strcpy(buf_pos, cStr);\n" \
  "                    buf_pos = buf_pos + strlen(buf_pos);\n" \
  "                    lg_write = giv_ecrit_fin_noeud(&buf_pos, tcBaliseFin);\n" \
  "                }\n" \
  "            }\n" \
  "            else if ((0 == strcmp(\"AD\", obj)) && (0 != pcFin))\n" \
  "            {\n" \
  "                strcpy(buf_pos, \"</Search_\");\n" \
  "                strcat(buf_pos, tcSource);\n" \
  "                strcat(buf_pos, \">\");\n" \
  "                lg_ecr = strlen(buf_pos);\n" \
  "                *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "            }\n" \
  "\n" \
  "            buf_pos = buf_pos + strlen(buf_pos);\n" \
  "        }\n" \
  "\n" \
  "        if (0 == pcDebut)\n" \
  "        {\n" \
  "            pcDebut = strstr(cStr, cStrRef);\n" \
  "\n" \
  "            if (0 != pcDebut)\n" \
  "            {\n" \
  "                buf_pos = buf_pos + strlen(buf_pos);\n" \
  "                pcFin = 0;\n" \
  "\n" \
  "                if ((buf_pos == buf_pos_ref) && (1 == *piDeb) && ((0 == strcmp(\"GS\", obj)) || (0 == strcmp(\"AD\", obj)) || (0 == strcmp(\"DV\", obj))))\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    *piDeb = 0;\n" \
  "                }\n" \
  "                else if ((buf_pos == buf_pos_ref) && (1 == *piDeb))\n" \
  "                {\n" \
  "                    lg_write = giv_ecrit_noeud_simple(buf_pos, pcBalise);\n" \
  "                    buf_pos = buf_pos + lg_write;\n" \
  "                    strcpy(buf_pos, cStrRef);\n" \
  "                    lg_ecr = strlen(buf_pos);\n" \
  "                    *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                    *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "                    buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "                    *piDeb = 0;\n" \
  "                }\n" \
  "\n" \
  "                if (0 == strcmp(\"AD\", obj))\n" \
  "                {\n" \
  "                    strcpy(buf_pos, \"<Search_\");\n" \
  "                    strcat(buf_pos, tcSource);\n" \
  "                    strcat(buf_pos, \" etablissement=\\\"\\\" id=\\\"\");\n" \
  "                    strcat(buf_pos, doc->value.a_classer.etab);\n" \
  "                    strcat(buf_pos, \"\\\">\");\n" \
  "                    lg_ecr = strlen(buf_pos);\n" \
  "                    *(buf_pos + lg_ecr) = SEPARE_LIGNE;\n" \
  "                    *(buf_pos + (lg_ecr + 1)) = LINE_FEED;\n" \
  "                    *(buf_pos + (lg_ecr + 2)) = '\\0';\n" \
  "                    buf_pos = (buf_pos + lg_ecr + 2);\n" \
  "                }\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        if ((0 != pcDebut) && (0 == pcFin))\n" \
  "        {\n" \
  "            pcFin = strstr(cStr, cStrFinRef);\n" \
  "\n" \
  "            if (0 != pcFin)\n" \
  "                pcDebut = 0;\n" \
  "        }\n" \
  "    }\n" \
  "    while (0 == feof(GIVfDescFicSGIPRO));\n" \
  "\n" \
  "    *buf_pos_in = buf_pos;\n" \
  "    /* Fermeture fichier SGIPRO */\n" \
  "    iIntRet = fclose(GIVfDescFicSGIPRO);\n" \
  "    iCodRet = GIV::GWCCodeOK;\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : GIVMiseEnFormeMvtSuppEpj ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Remplissage du buffer d'ecriture avec uniquement les champs    */\n" \
  "/*             renseignes (variables indicatrices nulles)  pour suppression   */\n" \
  "/*             de blocs                                                       */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Surement portable                                              */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :   Oct/03/2006  (mb)\n" \
  " *\n" \
  " * Modification (MM/JJ/AAAA - xx) :\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 GIVMiseEnFormeMvtSuppEpj(char* blocid, char* pcCodope, int4 dernier_ligne, int4 aiMaxBloc, int4 aiMaxBlocEcrit)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK;\n" \
  "    EXEC SQL\n" \
  "    begin declare\n" \
  "    section;\n" \
  "    char cBlocid[26 + 1];\n" \
  "    char tcRequete[1024];\n" \
  "    char cDepart[GYBIeinscLgDeppar + 1];\n" \
  "    EXEC SQL\n" \
  "    end declare\n" \
  "    section;\n" \
  "    GYBrParam_erreurT vErreurSQL; /* Traitement des erreurs SQL */\n" \
  "    char* buf_pos;\n" \
  "    int4 lg_write;\n" \
  "    int4 lg_a_ecrire;\n" \
  "    char nom_bloc_sup[50 + 1];\n" \
  "    char chaine_id[7 + 1]; /* Numero qui s'incremente    */\n" \
  "    char nom_test[50 + 1]; /* Nom du test                */\n" \
  "    char cChemin[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cNomFichier1[256] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    int4 lg_ecrit_entete = 0;\n" \
  "    char cEntete_xml[100] = \"<?xml version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\" ?>\";\n" \
  "    char conf[50];\n" \
  "    char* pcVersion = NULL;\n" \
  "\n" \
  "    if ((0 == strcmp(givRecreerCD, GIXcNomIntf)) && (0 != strcmp(GIXcValUrg, GWZUrgent)) && (0 == dernier_ligne))\n" \
  "    {\n" \
  "        /* pas de suppression en sortie en création */\n" \
  "        return (iCodRet);\n" \
  "    }\n" \
  "\n" \
  "    GWTTrace(GWT_NIV_FONCT, (\"dernier = %d\\n\", dernier_ligne));\n" \
  "    /* pas de commit */\n" \
  "    GIViCommit = (int4)GIV::GIXCodeKO;\n" \
  "\n" \
  "    if (obtention_iden == 0)\n" \
  "        givInitConfGXX();\n" \
  "\n" \
  "    strcpy(nom_bloc_ref, blocid);\n" \
  "\n" \
  "    if (0 == dernier_ligne)\n" \
  "    {\n" \
  "        /* Pointeur sur debut du buffer */\n" \
  "        buf_pos = GIVBuffXML;\n" \
  "        /* écriture d'un bloc */\n" \
  "        strcpy(nom_bloc_sup, blocid);\n" \
  "        lg_write = giv_ecrit_noeud_simple(buf_pos, \"OPERATION\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, \"delete\", \"TYPE_OPERATION\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_balise(buf_pos, nom_bloc_sup, \"NAME\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        lg_write = giv_ecrit_fin_noeud(&buf_pos, \"OPERATION\");\n" \
  "        buf_pos = buf_pos + lg_write;\n" \
  "        /* Calcul du numero d'identifiant parution_id */\n" \
  "        num_id = num_id + 1;\n" \
  "        iIntRet = giv_fichier_sortie(&buf_pos, &GIVfDescFicMCD);\n" \
  "\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur ecriture fin document */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur sur ecriture fin document dans partie_3 ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        pcVersion = strchr(pcVersionInsFour[0], (char)'.');\n" \
  "        pcVersion++;\n" \
  "        /* fermeture du fichier */\n" \
  "        iIntRet = (int4)giv_fermeture_fichier_sortie(&buf_pos, nom_bloc_sup);\n" \
  "        GIVBuffXML[0] = '\\0';\n" \
  "        /* suppressions de lignes du blocid */\n" \
  "        (void)strcpy(vErreurSQL.acOrdre_sql, \"Suppression anciens blocs GYTtabIeBloc\");\n" \
  "        (void)strcpy((char*)cDepart, (const char*)GIXcDepartement);\n" \
  "        (void)strcpy(cBlocid, blocid);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"blocid  : %s\\n\", cBlocid));\n" \
  "        EXEC SQL\n" \
  "        execute rqtDelIeBloc\n" \
  "        using\n" \
  "        :cDepart,\n" \
  "        :cBlocid;\n" \
  "        iCodRet = GIVBlocErreur(&vErreurSQL);\n" \
  "\n" \
  "        /* Analyse du code resultat SQL */\n" \
  "        if (((int4)GIV::GWCCodeOK != iCodRet) && ((int4)GIV::GYBnodata != iCodRet))\n" \
  "            GWTTrace(GWT_NIV_BIZAR, (\"Erreur : [COD=%d TXT=%s]\\n\", iCodRet, vErreurSQL.acOrdre_sql));\n" \
  "\n" \
  "        if (0 == strcmp(\"OUI\", givtcGeneIeBlocCRC))\n" \
  "        {\n" \
  "            /* suppression sur blocid dans GYTtabIeBlocCRC */\n" \
  "            iIntRet = givDelIeBlocCRC(blocid);\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((1 == dernier_ligne) && (NULL == GIVfDescFicMCD) && (0 == obtention_iden))\n" \
  "    {\n" \
  "        /* Pointeur sur debut du buffer */\n" \
  "        buf_pos = GIVBuffXML;\n" \
  "        GIVBuffXML[0] = '\\0';\n" \
  "        iIntRet = giv_fichier_sortie(&buf_pos, &GIVfDescFicMCD);\n" \
  "\n" \
  "        if ((int4)GIV::GWCCodeOK != iIntRet)\n" \
  "        {\n" \
  "            /* Erreur sur ecriture fin document */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Erreur sur ecriture fin document dans partie_3 ...\\n\"));\n" \
  "            iCodRet = (int4)GIV::GWCCodeKO;\n" \
  "        }\n" \
  "    }\n" \
  "\n" \
  "    if ((1 == dernier_ligne) && (NULL != GIVfDescFicMCD))\n" \
  "    {\n" \
  "        /* Initialisation pointeur */\n" \
  "        buf_pos = GIVBuffXML;\n" \
  "        /* Calcul de la longueur a ecrire */\n" \
  "        lg_a_ecrire = giv_ecrit_fin_noeud(&buf_pos, \"documents\");\n" \
  "        /* ecriture de l'enregistrement dans le fichier de sortie */\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Taille du buff a ecrire dans le fic XML : %d\\n\", lg_a_ecrire));\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Buff a ecrire dans le fic XML : %s\\n\", GIVBuffXML));\n" \
  "        /* Ecriture dans le fichier de sortie */\n" \
  "        iIntRet = (int4)fwrite(GIVBuffXML, lg_a_ecrire, 1, GIVfDescFicMCD);\n" \
  "\n" \
  "        if (1 != iIntRet)\n" \
  "        {\n" \
  "            /* probleme d'écriture de fichier */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Probleme d'écriture de fichier EPJ : %d\\n\", iIntRet));\n" \
  "            iCodRet = GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        /* fichier rempli */\n" \
  "        iIntRet = fclose(GIVfDescFicMCD);\n" \
  "\n" \
  "        if (iIntRet != (int4)GIV::GWCCodeOK)\n" \
  "        {\n" \
  "            /* probleme de fermeture de fichier */\n" \
  "            GWTTrace(GWT_NIV_GRAVE, (\"Probleme de fermeture de fichier EPJ : %d\\n\", iIntRet));\n" \
  "            iCodRet = GIV::GIXCodeKO;\n" \
  "        }\n" \
  "\n" \
  "        GIVfDescFicMCD = NULL;\n" \
  "\n" \
  "        if (NULL != GIVfDescFicCFLT)\n" \
  "        {\n" \
  "            iIntRet = fclose(GIVfDescFicCFLT);\n" \
  "\n" \
  "            if (iIntRet != (int4)GIV::GWCCodeOK)\n" \
  "            {\n" \
  "                /* probleme de fermeture de fichier */\n" \
  "                GWTTrace(GWT_NIV_GRAVE, (\"Probleme de fermeture de fichier CFLT\"));\n" \
  "                iCodRet = GIV::GIXCodeKO;\n" \
  "            }\n" \
  "        }\n" \
  "\n" \
  "        GIVfDescFicCFLT = NULL;\n" \
  "        giviClose = (int4)GIV::GIXCodeKO;\n" \
  "    }\n" \
  "\n" \
  "    /* Pour ne plus recaluler au prochain passage */\n" \
  "    obtention_iden = 1;\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n" \
  "\n" \
  "/*----Fonction----------------------------------------------------------------*/\n" \
  "/*                                                                            */\n" \
  "/* Fonction  : GIVMiseEnFormeEPJ ()                                         */\n" \
  "/*                                                                            */\n" \
  "/* But       : Remplissage du buffer d'ecriture avec uniquement les champs    */\n" \
  "/*             renseignes (variables indicatrices nulles) pour création       */\n" \
  "/*             de blocs EPJ                                                      */\n" \
  "/* Entree(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Sortie(s) :                                                                */\n" \
  "/*                                                                            */\n" \
  "/* Portable  : Surement portable                                              */\n" \
  "/*                                                                            */\n" \
  "/*----------------------------------------------------------------------------*/\n" \
  "/*---------------------------------Historique----------------------------------\n" \
  " *\n" \
  " * Création :\n" \
  " *\n" \
  " * Modification (Dec/13/2001 - mb) : différenciation MOG/MOI\n" \
  " *\n" \
  " * Modification (Jui/20/2006 - mb) : création de plusieurs fichiers de sortie\n" \
  " *\n" \
  " *---------------------------Fin de l'en-tête fonction------------------------*/\n" \
  "\n" \
  "int4 GIVMiseEnFormeEPJ(GYBrMouvementsBlocT* prMouvement, char* pcCodope, int4 dernier_ligne)\n" \
  "\n" \
  "{\n" \
  "    int4 iCodRet = GIV::GWCCodeOK; /* Code retour de la fonction */\n" \
  "    int4 iIntRet = GIV::GWCCodeOK; /* Code retour interne */\n" \
  "    int2 sSaveNogrouI = -1;\n" \
  "    int2 sSaveNoseloI = -1;\n" \
  "    int2 sSaveNoselsI = -1;\n" \
  "    struct timeval sDate;\n" \
  "    int4 jncompteur;\n" \
  "    int4 lg_a_ecrire; /* Longueur du contenu de buffer : a ecrire */\n" \
  "    int4 lg_IG; /* longueur du champ nogrou_courant */\n" \
  "    int4 i, j, k;\n" \
  "    int4 iRes, iAcc;\n" \
  "    char cInscSante;\n" \
  "    char cPrtSante;\n" \
  "    GYBrIapartT rPart;\n" \
  "    char* buf_pos;\n" \
  "    char cChemin[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    char cNomFichier[128] = \"\"; /* Pathname des fichiers utilises */\n" \
  "    time_t date;\n" \
  "    date = time(NULL);\n" \
  "    /* Pointeur sur debut du buffer */\n" \
  "    buf_pos = GIVBuffXML;\n" \
  "    /* pas de bloc écrit */\n" \
  "    iMaxBlocEcritAvant = (int4) - 1;\n" \
  "    /* pas de commit */\n" \
  "    GIViCommit = (int4)GIV::GIXCodeKO;\n" \
  "    /* écriture bloc dans buffer */\n" \
  "    giviCodRetEcr = (int4)GIV::GIXCodeOK;\n" \
  "    /* récupération des paramètres d'appel */\n" \
  "    /* pour les rendre visibles des sous-programmes sans etre obligé de les repasser à chaque fois */\n" \
  "    strcpy(cCodope, pcCodope);\n" \
  "    prMouvement->copyMvtBloc(cNumlot, cNummvt, cNumnat, cNumlo, cNumls);\n" \
  "    strcpy(cBlocidPrec, prMouvement->acBlocid);\n" \
  "    /* Initialisation structure du bloc */\n" \
  "    iCodRet = givInitBlocParution(&doc);\n" \
  "\n" \
  "    if (dernier_ligne == 0)\n" \
  "    {\n" \
  "        /* analyse MC */\n" \
  "        iCodRet = givMefEnsemble(&doc, nb_inscription);\n" \
  "        memcpy(&(doc2[nb_inscription]), &doc, sizeof(GYBrDOCUMENTEpj));\n" \
  "        nb_inscription++;\n" \
  "    }\n" \
  "    else\n" \
  "    {\n" \
  "        /* analyse Etab */\n" \
  "        iCodRet = GIVLectureTabPeEtab(doc2->value.a_classer.etab);\n" \
  "\n" \
  "        if ((int4)GIV::GIXCodeKO == iCodRet)\n" \
  "        {\n" \
  "            for (i = 0; (i < nb_inscription && givcParuSSAdr == doc2[i].value.inscription[0].adresse.parution[givcIndParuAdr]); i++)\n" \
  "                ;\n" \
  "\n" \
  "            if (nb_inscription == i)\n" \
  "                memcpy(&doc, &(doc2[0]), sizeof(GYBrDOCUMENTEpj));\n" \
  "            else\n" \
  "                memcpy(&doc, &(doc2[i]), sizeof(GYBrDOCUMENTEpj));\n" \
  "        }\n" \
  "        else\n" \
  "        {\n" \
  "            iCodRet = givMefDonneesParution(&doc, nb_inscription);\n" \
  "            iCodRet = givMefMoyensTelecom(&doc, nb_inscription);\n" \
  "            iCodRet = givMefLieuInstallation(&doc, nb_inscription);\n" \
  "        }\n" \
  "\n" \
  "        /* données de partenaire liées à l'établissement */\n" \
  "        iIntRet = GIVLectureTabPartEtab(doc2->value.a_classer.etab, givtcCleNav);\n" \
  "        GWTTrace(GWT_NIV_FONCT, (\"Nb IaPart : %d\\n\", GIViNbTupleIapart));\n" \
  "\n" \
  "        if (0 != GIViNbTupleIapart)\n" \
  "        {\n" \
  "            iRes = 0;\n" \
  "            iAcc = 0;\n" \
  "\n" \
  "            for (i = 0; i < GIViNbTupleIapart; i++)\n" \
  "            {\n" \
  "            	 if(GIVtrPart[i].isPartenaireValide(giv_RESA, givtcFourPart))\n" \
  "                    iRes = 1;\n" \
  "            	 else if(GIVtrPart[i].isPartenaireValide(giv_ACCO, givtcFourPart))\n" \
  "                {\n" \
  "                    iAcc = 1;\n" \
  "                    break;\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            /* analyse type d'inscription */\n" \
  "            cInscSante = givcParuSante;\n" \
  "\n" \
  "            for (i = 0; (i < nb_inscription && giv_orPJDC != doc2[i].value.intitule.parution[0]); i++)\n" \
  "                ;\n" \
  "\n" \
  "            if (nb_inscription == i)\n" \
  "            {\n" \
  "                for (i = 0; (i < nb_inscription && giv_svPJDC != doc2[i].value.intitule.parution[0]); i++)\n" \
  "                    ;\n" \
  "            }\n" \
  "\n" \
  "            if (nb_inscription == i)\n" \
  "            {\n" \
  "                for (i = 0; (i < nb_inscription && giv_cPJDC != doc2[i].value.intitule.parution[0]); i++)\n" \
  "                    ;\n" \
  "            }\n" \
  "\n" \
  "            if (nb_inscription == i)\n" \
  "            {\n" \
  "                for (i = 0; (i < nb_inscription && giv_prPJDC != doc2[i].value.intitule.parution[0]); i++)\n" \
  "                    ;\n" \
  "            }\n" \
  "\n" \
  "            if (nb_inscription != i)\n" \
  "                cInscSante = doc2[i].value.intitule.parution[0];\n" \
  "\n" \
  "            /* analyse type de partenaire */\n" \
  "            cPrtSante = givcParuSante;\n" \
  "\n" \
  "            for (i = 0; (i < GIViNbTupleIapart && GIVtrPart[i].analyseTypePartenaire(giv_orPJDC, giv_PJDC)); i++)\n" \
  "                ;\n" \
  "\n" \
  "            if (GIViNbTupleIapart == i)\n" \
  "            {\n" \
  "            	 for (i = 0; (i < GIViNbTupleIapart && GIVtrPart[i].analyseTypePartenaire(giv_svPJDC, giv_PJDC)); i++)\n" \
  "                    ;\n" \
  "            }\n" \
  "\n" \
  "            if (GIViNbTupleIapart == i)\n" \
  "            {\n" \
  "            	 for (i = 0; (i < GIViNbTupleIapart && GIVtrPart[i].analyseTypePartenaire(giv_cPJDC, giv_PJDC)); i++)\n" \
  "                    ;\n" \
  "            }\n" \
  "\n" \
  "            if (GIViNbTupleIapart == i)\n" \
  "            {\n" \
  "            	 for (i = 0; (i < GIViNbTupleIapart && GIVtrPart[i].analyseTypePartenaire(giv_prPJDC, giv_PJDC)); i++)\n" \
  "                    ;\n" \
  "            }\n" \
  "\n" \
  "            if (GIViNbTupleIapart != i)\n" \
  "                cPrtSante = GIVtrPart[i].acTypeRefPart[0];\n" \
  "\n" \
  "            j = doc2->value.a_classer.iNbPart;\n" \
  "            giviNbIapartPJDC = 0;\n" \
  "            giviNbTupleIapart = j;\n" \
  "            strcpy(rPart.acOriPart, \"    \");\n" \
  "\n" \
  "            for (i = 0; i < GIViNbTupleIapart; i++)\n" \
  "            {\n" \
  "                if ((NULL == strstr(givtcFourPart, GIVtrPart[i].acOriPart)) || ('0' != GIVvInscrip.acIndPart[0]))\n" \
  "                {\n" \
  "                    if ((1 == iAcc) && GIVtrPart[i].isOriginePartenaires(giv_RESA, giv_EXPD))\n" \
  "                    {\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Part resa/expd non prioritaire : %s, %s\\n\", GIVtrPart[i].acRefPart, doc2->value.a_classer.etab));\n" \
  "                        continue;\n" \
  "                    }\n" \
  "                    else if ((1 == iRes) && (0 == strcmp(GIVtrPart[i].acOriPart, giv_EXPD)))\n" \
  "                    {\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Part expd non prioritaire : %s, %s\\n\", GIVtrPart[i].acRefPart, doc2->value.a_classer.etab));\n" \
  "                        continue;\n" \
  "                    }\n" \
  "                    else if ((0 == strcmp(GIVtrPart[i].acOriPart, rPart.acOriPart)) && (0 != strcmp(GIVtrPart[i].acOriPart, giv_PJDC)))\n" \
  "                    {\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Part expd (hors pjdc) double non prioritaire : %s, %s\\n\", GIVtrPart[i].acRefPart, doc2->value.a_classer.etab));\n" \
  "                        continue;\n" \
  "                    }\n" \
  "\n" \
  "                    /* Analyse santé PJDOC */\n" \
  "                    if ((cInscSante != GIVtrPart[i].acTypeRefPart[0]) && (0 == strcmp(GIVtrPart[i].acOriPart, giv_PJDC)) && ((giv_orPJDC == cInscSante) || (giv_cPJDC == cInscSante)))\n" \
  "                    {\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Type santé non retenu : %c, %s, %s, %s\\n\", cInscSante, GIVtrPart[i].acTypeRefPart, GIVtrPart[i].acRefPart, doc2->value.a_classer.etab));\n" \
  "                        continue;\n" \
  "                    }\n" \
  "\n" \
  "                    if ((cPrtSante != GIVtrPart[i].acTypeRefPart[0]) && (0 == strcmp(GIVtrPart[i].acOriPart, giv_PJDC)) && (giv_prPJDC == cInscSante))\n" \
  "                    {\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Type santé non retenu : %c, %s, %s, %s\\n\", cInscSante, GIVtrPart[i].acTypeRefPart, GIVtrPart[i].acRefPart, doc2->value.a_classer.etab));\n" \
  "                        continue;\n" \
  "                    }\n" \
  "\n" \
  "                    if (((cPrtSante != GIVtrPart[i].acTypeRefPart[0]) || (giv_orPJDC != cPrtSante && giv_svPJDC != cPrtSante)) && (0 == strcmp(GIVtrPart[i].acOriPart, giv_PJDC)) && (giv_svPJDC == cInscSante))\n" \
  "                    {\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Type santé non retenu : %c, %s, %s, %s\\n\", cInscSante, GIVtrPart[i].acTypeRefPart, GIVtrPart[i].acRefPart, doc2->value.a_classer.etab));\n" \
  "                        continue;\n" \
  "                    }\n" \
  "\n" \
  "                    doc2->value.a_classer.trpart[j].iForPJDC = GIV::GIXCodeKO;\n" \
  "                    strcpy(doc2->value.a_classer.trpart[j].rpart, GIVtrPart[i].acRefPart);\n" \
  "                    strcat(doc2->value.a_classer.trpart[j].rpart, GIVtrPart[i].acOriPart);\n" \
  "                    strcpy(doc2->value.a_classer.trpart[j].typepart, GIVtrPart[i].acTypeRefPart);\n" \
  "                    strcpy(doc2->value.a_classer.trpart[j].parent, GIVtrPart[i].acParentRefPart);\n" \
  "                    strcpy(doc2->value.a_classer.trpart[j].idmed, GIVtrPart[i].acIdMed);\n" \
  "                    strcpy(doc2->value.a_classer.trpart[j].isdoc, GIVtrPart[i].acIsDoc);\n" \
  "\n" \
  "                    for (k = 0; (k < givNbPart && (0 != strcmp(GIVtrPart[i].acOriPart, givTabPart[k].tcPart))); k++)\n" \
  "                        ;\n" \
  "\n" \
  "                    if (givNbPart == k)\n" \
  "                        doc2->value.a_classer.trpart[j].prod[0] = '\\0';\n" \
  "                    else\n" \
  "                        strcpy(doc2->value.a_classer.trpart[j].prod, givTabPart[k].tcProd);\n" \
  "\n" \
  "                    strcpy(doc2->value.a_classer.trpart[j].clenav, givtcCleNav[i]);\n" \
  "                    GWTTrace(GWT_NIV_FONCT, (\"Part : %s,%s\\n\", doc2->value.a_classer.trpart[j].rpart, doc2->value.a_classer.trpart[j].prod));\n" \
  "\n" \
  "                    if ((0 == strcmp(GIVtrPart[i].acOriPart, rPart.acOriPart)) && (0 == strcmp(GIVtrPart[i].acOriPart, giv_PJDC)))\n" \
  "                    {\n" \
  "                        /* une seule référence partenaire pour l'origine PJDC */\n" \
  "                        GWTTrace(GWT_NIV_FONCT, (\"Part pjdc double non prioritaire : %s, %s\\n\", GIVtrPart[i].acRefPart, doc2->value.a_classer.etab));\n" \
  "                        giviNbIapartPJDC++;\n" \
  "                        doc2->value.a_classer.trpart[j].iRgParent = giviNbParentPart;\n" \
  "                        doc2->value.a_classer.trpart[j].iNbParent = 1;\n" \
  "                        strcpy(givtrPart[giviNbParentPart].acOriPart, GIVtrPart[i].acOriPart);\n" \
  "                        strcpy(givtrPart[giviNbParentPart].acRefPart, GIVtrPart[i].acRefPart);\n" \
  "                        strcpy(givtrPart[giviNbParentPart].acDenom, GIVtrPart[i].acDenom);\n" \
  "                        strcpy(givtrPart[giviNbParentPart].acPrenom, GIVtrPart[i].acPrenom);\n" \
  "                        giviNbParentPart++;\n" \
  "                        j++;\n" \
  "                    }\n" \
  "                    else\n" \
  "                    {\n" \
  "                        j++;\n" \
  "                        giviNbTupleIapart = j;\n" \
  "                    }\n" \
  "\n" \
  "                    strcpy(rPart.acOriPart, GIVtrPart[i].acOriPart);\n" \
  "                }\n" \
  "            }\n" \
  "\n" \
  "            GIViNbTupleIapart = giviNbTupleIapart;\n" \
  "        }\n" \
  "\n" \
  "        doc2->value.a_classer.iNbPart = GIViNbTupleIapart;\n" \
  "        /* génération du bloc EPJ */\n" \
  "        iCodRet = givGroupement(&buf_pos, &doc, &doc2[0], nb_inscription);\n" \
  "        nb_inscription = 0;\n" \
  "        iMaxBlocEcritAvant++;\n" \
  "    }\n" \
  "\n" \
  "    /* Sortie de la fonction */\n" \
  "    return (iCodRet);\n" \
  "}\n";
